#!/usr/bin/env node

import Database from 'better-sqlite3';
import { execSync } from 'child_process';
import { readFileSync } from 'fs';

const DB_PATH = '.data/today.db';
const db = new Database(DB_PATH);

// Get timezone from config
function getTimezone() {
  try {
    const tz = execSync('bin/get-config timezone', { encoding: 'utf8' }).trim();
    return tz || 'America/New_York';
  } catch {
    return 'America/New_York';
  }
}

// Get current date/time in timezone
function getCurrentDateTime(tz) {
  const result = execSync(`TZ=${tz} date "+%A, %B %d, %Y at %I:%M %p %Z"`, { encoding: 'utf8' });
  return result.trim();
}

// Sync markdown tasks before querying
function syncMarkdownTasks() {
  try {
    // Get the most recent cache update time
    const lastUpdate = db.prepare('SELECT MAX(updated_at) as last_update FROM markdown_tasks').get();
    const lastUpdateTime = lastUpdate?.last_update;

    if (!lastUpdateTime) {
      // No cache yet, skip sync
      return;
    }

    // Convert SQLite datetime to Unix timestamp for find command
    const lastUpdateDate = new Date(lastUpdateTime);
    const minutesAgo = Math.ceil((Date.now() - lastUpdateDate.getTime()) / 60000);

    // Find files modified since last cache update
    const findCmd = `find vault/ -name "*.md" -type f ! -path "*/.*" -mmin -${minutesAgo + 1} 2>/dev/null`;
    const filesOutput = execSync(findCmd, { encoding: 'utf8', timeout: 5000 });
    const files = filesOutput.split('\n').filter(Boolean);

    if (files.length === 0) {
      return; // Nothing to sync
    }

    // For each changed file, delete old entries and re-insert
    const deleteStmt = db.prepare('DELETE FROM markdown_tasks WHERE file_path = ?');
    const insertStmt = db.prepare('INSERT INTO markdown_tasks (file_path, line_number, line_text) VALUES (?, ?, ?)');

    for (const filePath of files) {
      try {
        // Delete existing entries for this file
        deleteStmt.run(filePath);

        // Read and re-insert tasks
        const content = readFileSync(filePath, 'utf8');
        const lines = content.split('\n');

        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          // Match tasks including those in blockquotes: >   - [ ]
          if (line.match(/^[>\s]*- \[[ x]\]/)) {
            insertStmt.run(filePath, lineNum + 1, line);
          }
        }
      } catch (err) {
        // Ignore errors, file might have been deleted
      }
    }
  } catch (error) {
    // Silently fail - don't block db-query
  }
}

// Query type handlers
const queries = {
  daily: () => {
    // Sync markdown tasks first
    syncMarkdownTasks();

    const tz = getTimezone();
    const now = new Date();
    const today = now.toISOString().split('T')[0];

    console.log(`Current Time: ${getCurrentDateTime(tz)}`);
    console.log('---');
    
    // Tasks with üìÖ or ‚è≥ dates today or earlier
    console.log('=== TASKS DUE TODAY OR OVERDUE ===');
    const tasks = db.prepare(`
      SELECT line_text, file_path 
      FROM markdown_tasks 
      WHERE line_text LIKE '- [ ]%'
        AND (line_text LIKE '%üìÖ%' OR line_text LIKE '%‚è≥%')
    `).all();
    
    const dueTasks = tasks.filter(task => {
      // Extract date from line (format: üìÖ 2025-10-07 or ‚è≥ 2025-10-07)
      const dateMatch = task.line_text.match(/[üìÖ‚è≥]\s*(\d{4}-\d{2}-\d{2})/);
      if (!dateMatch) return false;
      const taskDate = dateMatch[1];
      return taskDate <= today;
    });
    
    // Add incomplete tasks from past daily plan files (format: YYYY_QN_MM_WWW_DD.md where DD != 00)
    const allPlanTasks = db.prepare(`
      SELECT line_text, file_path
      FROM markdown_tasks
      WHERE line_text LIKE '%- [ ]%'
        AND file_path GLOB 'vault/plans/????_Q?_??_W??_??.md'
        AND file_path NOT GLOB '*_00.md'
    `).all();

    const planTasks = allPlanTasks.filter(task => {
      // Extract date from filename: 2025_Q4_10_W41_06.md -> 2025-10-06
      const match = task.file_path.match(/(\d{4})_Q\d_(\d{2})_W\d+_(\d{2})\.md$/);
      if (!match) return false;
      const fileDate = `${match[1]}-${match[2]}-${match[3]}`;
      return fileDate <= today;
    });
    
    const allTasks = [...dueTasks, ...planTasks].slice(0, 50);
    allTasks.forEach(t => console.log(`${t.line_text}|${t.file_path}`));
    console.log('---');
    
    // Calendar events
    console.log("=== TODAY'S EVENTS ===");
    const events = db.prepare(`
      SELECT title, start_date, end_date, location, start_timezone
      FROM calendar_events
      WHERE DATE(start_date) = DATE('now')
      ORDER BY start_date
    `).all();
    events.forEach(e => console.log(`${e.title}|${e.start_date}|${e.end_date}|${e.location || ''}|${e.start_timezone || ''}`));
    console.log('---');
    
    // Recent emails
    console.log('=== RECENT EMAILS ===');
    const emails = db.prepare(`
      SELECT subject, from_address, date
      FROM emails
      WHERE folder != 'Sent'
        AND date > datetime('now', '-2 days')
      ORDER BY date DESC
      LIMIT 15
    `).all();
    emails.forEach(e => console.log(`${e.subject}|${e.from_address}|${e.date}`));
    console.log('---');
    
    // Guest room status
    console.log('=== GUEST ROOM STATUS ===');
    const guestEmails = db.prepare(`
      SELECT subject, from_address, date
      FROM emails
      WHERE (lower(subject) LIKE '%airbnb%' 
         OR lower(subject) LIKE '%misterb%'
         OR lower(from_address) LIKE '%airbnb%'
         OR lower(from_address) LIKE '%misterb%')
         AND date > datetime('now', '-7 days')
      ORDER BY date DESC
      LIMIT 5
    `).all();
    guestEmails.forEach(e => console.log(`${e.subject}|${e.from_address}|${e.date}`));
    console.log('---');
    
    // Contacts
    console.log('=== CONTACTS ===');
    const contactCount = db.prepare('SELECT COUNT(*) as count FROM contacts').get();
    console.log(`${contactCount.count} contacts in database`);
    console.log('---');
    
    // Time tracking
    console.log('=== TIME TRACKED TODAY ===');
    const timeEntries = db.prepare(`
      SELECT
        project,
        printf('%.2f', SUM(duration_minutes) / 60.0) as hours
      FROM time_entries
      WHERE DATE(start_time) = DATE('now', 'localtime')
        AND end_time IS NOT NULL
      GROUP BY project
      ORDER BY SUM(duration_minutes) DESC
    `).all();

    if (timeEntries.length > 0) {
      timeEntries.forEach(e => console.log(`${e.project}|${e.hours}`));
    } else {
      console.log('No time tracked yet today');
    }
  },
  
  tasks: () => {
    console.log('Tasks are tracked in markdown files.');
    console.log('Use: rg \'- [ ]\' vault/ to see uncompleted tasks');
    console.log('Or check markdown_tasks table for cached data');
  },

  events: () => {
    // Calendar events for next 7 days
    const events = db.prepare(`
      SELECT title, start_date, end_date, location
      FROM calendar_events
      WHERE DATE(start_date) <= DATE('now', '+7 days')
        AND DATE(start_date) >= DATE('now')
      ORDER BY start_date
    `).all();
    events.forEach(e => console.log(`${e.title}|${e.start_date}|${e.end_date}|${e.location || ''}`));
  },

  emails: () => {
    // Recent emails (last 3 days)
    const emails = db.prepare(`
      SELECT subject, from_address, date,
             CASE WHEN folder = 'Sent' THEN '‚Üí SENT' ELSE '‚Üê RECEIVED' END as direction
      FROM emails
      WHERE date > datetime('now', '-3 days')
      ORDER BY date DESC
      LIMIT 30
    `).all();
    emails.forEach(e => console.log(`${e.subject}|${e.from_address}|${e.date}|${e.direction}`));
  },

  contacts: () => {
    // Contacts
    const contacts = db.prepare(`
      SELECT full_name, organization, notes
      FROM contacts
      WHERE full_name IS NOT NULL
      ORDER BY full_name
      LIMIT 20
    `).all();
    contacts.forEach(c => console.log(`${c.full_name}|${c.organization || ''}|${c.notes || ''}`));
  },

  ogm: () => {
    // OGM monitoring data
    console.log('=== OGM ERRORS ===');
    const sentryIssues = db.prepare(`
      SELECT title, count, last_seen
      FROM ogm_sentry_issues
      WHERE status = 'unresolved' AND count > 100
      ORDER BY count DESC
      LIMIT 10
    `).all();
    sentryIssues.forEach(i => console.log(`${i.title}|${i.count}|${i.last_seen}`));
    console.log('---');

    console.log('=== OGM GITHUB ISSUES ===');
    const githubIssues = db.prepare(`
      SELECT title, state, created_at
      FROM ogm_github_issues
      WHERE state = 'open'
      ORDER BY created_at DESC
      LIMIT 10
    `).all();
    githubIssues.forEach(i => console.log(`${i.title}|${i.state}|${i.created_at}`));
  },

  journal: () => {
    // Recent journal entries (using new schema: date, text, metadata)
    const entries = db.prepare(`
      SELECT
        DATE(date) as entry_date,
        SUBSTR(text, 1, 200) as preview,
        metadata
      FROM diary
      WHERE datetime(date) >= datetime('now', '-7 days')
      ORDER BY date DESC
    `).all();
    entries.forEach(e => {
      let starred = '';
      try {
        const meta = e.metadata ? JSON.parse(e.metadata) : {};
        if (meta.starred) starred = '‚≠ê ';
      } catch {}
      console.log(`${e.entry_date}|${starred}${e.preview}`);
    });
  },

  'on-this-day': () => {
    // Entries from this date in previous years
    const now = new Date();
    const monthDay = `${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

    const entries = db.prepare(`
      SELECT
        DATE(date) as entry_date,
        SUBSTR(text, 1, 300) as preview,
        metadata
      FROM diary
      WHERE substr(date, 6, 5) = ?
      ORDER BY date DESC
    `).all(monthDay);

    if (entries.length === 0) {
      console.log(`No entries found for this day (${monthDay}) in previous years`);
      return;
    }

    console.log(`=== ON THIS DAY (${monthDay}) ===`);
    entries.forEach(e => {
      let location = '';
      try {
        const meta = e.metadata ? JSON.parse(e.metadata) : {};
        if (meta.location?.localityName) location = ` [${meta.location.localityName}]`;
      } catch {}
      console.log(`${e.entry_date}${location}|${e.preview}`);
    });
    console.log('---');
    const years = new Set(entries.map(e => e.entry_date.substring(0, 4)));
    console.log(`${entries.length} entries across ${years.size} years`);
  },

  schema: () => {
    // Show all tables
    const tables = db.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table'
      ORDER BY name
    `).all();
    console.log('=== DATABASE TABLES ===');
    tables.forEach(t => console.log(t.name));
  },

  custom: () => {
    // Run custom query (passed as second argument)
    const query = process.argv[3];
    if (!query) {
      console.error('Error: Please provide a query as the second argument');
      console.error('Usage: bin/db-query custom "SELECT * FROM table"');
      process.exit(1);
    }
    const results = db.prepare(query).all();
    console.log(JSON.stringify(results, null, 2));
  }
};

// Main
const command = process.argv[2] || 'daily';
const handler = queries[command];

if (handler) {
  handler();
} else {
  console.error(`Unknown command: ${command}`);
  console.error('Available commands: daily, tasks, events, emails, contacts, ogm, journal, on-this-day, schema, custom');
  process.exit(1);
}

db.close();
