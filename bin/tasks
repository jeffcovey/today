#!/usr/bin/env node

import { TaskManager } from '../src/task-manager.js';
import { TaskStageClassifier } from '../src/task-stage-classifier.js';
import { getDatabase } from '../src/database-service.js';
import { program } from 'commander';
import chalk from 'chalk';
import Table from 'cli-table3';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

// Helper function to find markdown files containing tasks
function findMarkdownFilesWithTasks() {
  // Use -exec instead of xargs to handle large number of files
  return execSync('find vault/ -name "*.md" -type f -not -path "*/templates/*" -exec grep -l "^- \\[ \\]" {} \\; 2>/dev/null || true', { encoding: 'utf8' })
    .split('\n')
    .filter(f => f);
}

program
  .name('tasks')
  .description('Task management for Today system')
  .version('1.0.0');

// Sync command
program
  .command('sync [file]')
  .description('Sync tasks from markdown files')
  .option('-f, --full', 'Force full scan of all files')
  .action(async (file, options) => {
    const tm = new TaskManager();

    try {
      if (file) {
        // Sync specific file
        const updates = await tm.syncMarkdownFile(file);
        console.log(chalk.green(`‚úì Synced ${file} (${updates} updates)`));
      } else {
        // Sync all markdown files in the entire repository
        const fs = await import('fs');
        const { execSync } = await import('child_process');

        // Load last sync state (unless --full flag is used)
        const syncStateFile = '.data/task-sync-state.json';
        let lastSyncTime = null;

        if (!options.full) {
          try {
            if (fs.existsSync(syncStateFile)) {
              const state = JSON.parse(fs.readFileSync(syncStateFile, 'utf8'));
              lastSyncTime = state.lastSyncTime;
            }
          } catch (e) {
            // No previous state
          }
        } else {
          console.log(chalk.yellow('Full scan requested (--full flag)'));
        }

        // Find markdown files
        let allMarkdownFiles;
        let onlyChangedFiles = false;

        if (lastSyncTime) {
          // Try to get only changed files since last sync
          const minutesAgo = Math.ceil((Date.now() - new Date(lastSyncTime).getTime()) / 60000);
          console.log(chalk.blue(`Finding markdown files changed in last ${minutesAgo} minutes...`));

          try {
            // Use find command to get recently modified files
            const changedFiles = execSync(
              `find "vault/" -name "*.md" -type f -mmin -${minutesAgo + 1} -not -path "*/templates/*" -not -path "*/.stversions/*" 2>/dev/null | grep -v node_modules | grep -v .git`,
              { encoding: 'utf8' }
            ).split('\n')
              .filter(f => f)
              .map(f => f.replace(/^\.\//, ''));

            if (changedFiles.length > 0) {
              allMarkdownFiles = changedFiles;
              onlyChangedFiles = true;
              console.log(chalk.gray(`  Found ${changedFiles.length} recently modified files`));
            } else {
              console.log(chalk.gray(`  No files modified since last sync`));
              // Still scan project files in case they need initial setup
              allMarkdownFiles = execSync('find "vault/projects" -name "*.md" -type f -not -path "*/templates/*" -not -path "*/.stversions/*" -not -name "*sync-conflict*" 2>/dev/null || echo ""', { encoding: 'utf8' })
                .split('\n')
                .filter(f => f)
                .map(f => f.replace(/^\.\//, ''));
            }
          } catch (e) {
            // Find command failed, fall back to full scan
            onlyChangedFiles = false;
          }
        }

        // If we don't have changed files or no last sync time, do full scan
        if (!onlyChangedFiles && !lastSyncTime) {
          console.log(chalk.blue('Finding all markdown files (first sync)...'));
          allMarkdownFiles = execSync('find "vault/" -name "*.md" -type f -not -path "*/templates/*" -not -path "*/.stversions/*" -not -name "*sync-conflict*" 2>/dev/null', { encoding: 'utf8' })
            .split('\n')
            .filter(f => f && !f.includes('node_modules') && !f.includes('.git'))
            .map(f => f.replace(/^\.\//, ''));
          console.log(chalk.gray(`  Found ${allMarkdownFiles.length} markdown files`));
        }

        // Always include review files (even if not modified recently)
        // This ensures tasks in review files get their do_date set properly
        try {
          const reviewFiles = execSync('find "vault/plans" -name "*.md" -type f -not -path "*/templates/*" -not -path "*/.stversions/*" -not -name "*sync-conflict*" 2>/dev/null || echo ""', { encoding: 'utf8' })
            .split('\n')
            .filter(f => f)
            .map(f => f.replace(/^\.\//, ''));

          let addedReviewFiles = 0;
          for (const reviewFile of reviewFiles) {
            if (!allMarkdownFiles.includes(reviewFile)) {
              allMarkdownFiles.push(reviewFile);
              addedReviewFiles++;
            }
          }

          if (addedReviewFiles > 0) {
            console.log(chalk.gray(`  Added ${addedReviewFiles} review file(s) to ensure proper date assignment`));
          }
        } catch (e) {
          // If finding review files fails, at least add today's
          const today = new Date();
          const year = today.getFullYear();
          const month = String(today.getMonth() + 1).padStart(2, '0');
          const day = String(today.getDate()).padStart(2, '0');
          const quarter = Math.ceil((today.getMonth() + 1) / 3);
          // Calculate ISO week number
          const onejan = new Date(today.getFullYear(), 0, 1);
          const week = Math.ceil((((today - onejan) / 86400000) + onejan.getDay() + 1) / 7);
          const todayReviewFile = `vault/plans/${year}_Q${quarter}_${month}_W${String(week).padStart(2, '0')}_${day}.md`;
          if (fs.existsSync(todayReviewFile) && !allMarkdownFiles.includes(todayReviewFile)) {
            allMarkdownFiles.push(todayReviewFile);
            console.log(chalk.gray(`  Added today's review file: ${todayReviewFile}`));
          }
        }

        // Always include topic files to sync new tasks and checkbox changes
        try {
          const topicFiles = execSync('find "vault/topics" -name "*.md" -type f -not -path "*/templates/*" -not -path "*/.stversions/*" -not -name "*sync-conflict*" 2>/dev/null || echo ""', { encoding: 'utf8' })
            .split('\n')
            .filter(f => f)
            .map(f => f.replace(/^\.\//, ''));

          let addedTopicFiles = 0;
          for (const topicFile of topicFiles) {
            if (!allMarkdownFiles.includes(topicFile)) {
              allMarkdownFiles.push(topicFile);
              addedTopicFiles++;
            }
          }

          if (addedTopicFiles > 0) {
            console.log(chalk.gray(`  Added ${addedTopicFiles} topic file(s) for task sync`));
          }
        } catch (e) {
          // Topic files not found, continue without them
        }

        // DISABLED: No longer syncing to database - using Obsidian Tasks plugin
        console.log(chalk.green('‚úì Database sync disabled - using Obsidian Tasks plugin'));

        // Save sync state (still needed for change tracking)
        const newState = { lastSyncTime: new Date().toISOString() };
        try {
          const path = await import('path');
          const dir = path.dirname(syncStateFile);
          if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
          }
          fs.writeFileSync(syncStateFile, JSON.stringify(newState, null, 2));
        } catch (e) {
          console.error('Failed to save sync state:', e.message);
        }
      }

      // DISABLED: Repeating tasks now handled by Obsidian Tasks plugin recurrence syntax

      // Disabled - now using static today.md with Obsidian Tasks plugin queries
      // const todayCount = await tm.generateTodayFile();
      // console.log(chalk.green(`‚úì Generated today.md with ${todayCount} tasks`));


      // Disabled - now using static tasks.md with Obsidian Tasks plugin queries
      // const allCount = await tm.generateAllTasksFile();
      // console.log(chalk.green(`‚úì Generated tasks.md with ${allCount} active tasks`));

      // Disabled - now using static stages.md with Obsidian Tasks plugin queries
      // const stagesCount = await tm.generateStagesFile();
      // console.log(chalk.green(`‚úì Generated stages.md with ${stagesCount} staged tasks`));

      // Disabled - replaced with static topic files using Obsidian Tasks queries
      // console.log(chalk.blue('Generating topic files...'));
      // const topicCount = await tm.generateTopicFiles();
      // if (topicCount > 0) {
      //   console.log(chalk.green(`‚úì Generated ${topicCount} topic files`));
      // } else {
      //   console.log(chalk.gray('  ‚Ä¢ No topics with tasks to generate'));
      // }

      // Create topic files for all #topic/ tags found in vault
      console.log(chalk.blue('Creating topic query files...'));

      // Function to create topic query files
      async function createTopicQueryFiles() {
        const fs = (await import('fs')).default;
        const path = await import('path');
        const { execSync } = (await import('child_process')).default || await import('child_process');

        // Find all #topic/ tags in vault files
        const findTopicsCmd = `grep -r "#topic/" vault --include="*.md" | grep -o "#topic/[a-z0-9._-]*" | sort -u`;
        let topics = [];

        try {
          const output = execSync(findTopicsCmd, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'ignore'] });
          topics = output.trim().split('\n').filter(t => t && t !== '#topic/');
        } catch (e) {
          // No topics found
          return 0;
        }

        let created = 0;
        const topicsDir = path.default.join('vault', 'topics');

        // Ensure topics directory exists
        if (!fs.existsSync(topicsDir)) {
          fs.mkdirSync(topicsDir, { recursive: true });
        }

        // Template from vault/Topics.md
        const template = `\`\`\`tasks
not done
has tags
tags include TOPIC_TAG
path does not include templates/
sort by happens
sort by priority
group by function task.file.path.toUpperCase().replace(query.file.folder, ': ')
\`\`\`
`;

        for (const topicTag of topics) {
          // Extract topic name from tag (e.g., #topic/health -> health)
          const topicName = topicTag.replace('#topic/', '');
          const fileName = `${topicName}.md`;
          const filePath = path.default.join(topicsDir, fileName);

          // Create file if it doesn't exist
          if (!fs.existsSync(filePath)) {
            const content = template.replace('TOPIC_TAG', topicTag);
            fs.writeFileSync(filePath, content, 'utf8');
            created++;
            console.log(chalk.gray(`  ‚Ä¢ Created ${fileName}`));
          }
        }

        return created;
      }

      const topicFilesCreated = await createTopicQueryFiles();
      if (topicFilesCreated > 0) {
        console.log(chalk.green(`‚úì Created ${topicFilesCreated} new topic query files`));
      } else {
        console.log(chalk.gray('  ‚Ä¢ All topic files already exist'));
      }

      // Classify stages for tasks without them in background
      // This prevents the sync from hanging while waiting for AI
      if (process.env.SKIP_CLASSIFICATION) {
        console.log(chalk.yellow('‚ö° Classification skipped (SKIP_CLASSIFICATION set)'));
      } else {
        // Count tasks needing classification
        const unclassifiedCount = tm.db.prepare(`
          SELECT COUNT(*) as count FROM tasks 
          WHERE stage IS NULL 
          AND status != '‚úÖ Done'
        `).get().count;

        if (unclassifiedCount > 0) {
          console.log(chalk.blue(`‚ö° Launching background classification for ${unclassifiedCount} tasks...`));

          // Spawn classification in background
          const { spawn } = await import('child_process');
          const classifyProcess = spawn('node', [
            '-e',
            `
            const { TaskStageClassifier } = require('./src/task-stage-classifier.js');
            const classifier = new TaskStageClassifier();
            classifier.classifyTasks(true).then(result => {
              if (result.classified > 0) {
                console.log('‚úì Background: Classified', result.classified, 'tasks');
              }
              classifier.close();
              process.exit(0);
            }).catch(err => {
              console.error('Background classification error:', err.message);
              classifier.close();
              process.exit(1);
            });
            `
          ], {
            detached: true,
            stdio: 'ignore',
            cwd: process.cwd()
          });

          // Detach the child process so it continues after parent exits
          classifyProcess.unref();
        } else {
          console.log(chalk.gray('  ‚Ä¢ All tasks already have stages assigned'));
        }
      }
    } catch (error) {
      console.error(chalk.red('Error syncing tasks:'), error.message);
      process.exit(1);
    } finally {
      // Close task manager first
      tm.close();

      // Push any pending changes to Turso before exiting
      try {
        const db = getDatabase();
        await Promise.race([
          db.forcePush(),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('forcePush timeout')), 5000)
          )
        ]);
      } catch (err) {
        console.error(chalk.yellow('Warning: Could not push to Turso:', err.message));
      }

      // Exit cleanly
      process.exit(0);
    }
  });

// List command
program
  .command('list')
  .description('List tasks')
  .option('-t, --today', 'Show only today\'s tasks')
  .option('-p, --project <id>', 'Show tasks for a specific project')
  .option('-s, --status <status>', 'Filter by status')
  .option('--stage <stage>', 'Filter by stage (Front Stage, Back Stage, Off Stage)')
  .option('-l, --legend', 'Show legend for symbols')
  .option('-c, --compact', 'Ultra-compact display (no table borders)')
  .option('--with-notion', 'Show only tasks imported from Notion')
  .action((options) => {
    if (options.legend) {
      console.log(chalk.bold('\nTask List Legend:'));
      console.log(chalk.gray('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'));
      console.log('Stage symbols:');
      console.log('  üì• = inbox    ‚è≠Ô∏è = next     üîµ = active');
      console.log('  ‚è∏Ô∏è = waiting  ‚úÖ = done     üì¶ = archived');
      console.log('\nPriority symbols:');
      console.log('  üî¥ = critical (5)  üü† = high (4)     üü° = medium (3)');
      console.log('  üîµ = low (2)       ‚ö™ = very low (1)');
      console.log('');
      return;
    }
    const tm = new TaskManager('.data/today.db', { readOnly: true });

    try {
      let tasks;
      if (options.withNotion) {
        // Get tasks with Notion IDs
        tasks = tm.db.prepare(`
          SELECT * FROM tasks 
          WHERE notion_id IS NOT NULL 
            AND status != '‚úÖ Done'
          ORDER BY do_date, status
        `).all();
      } else if (options.today) {
        tasks = tm.getTodayTasks();
      } else if (options.project) {
        tasks = tm.getProjectTasks(options.project);
      } else {
        tasks = tm.getActiveTasks();
      }

      if (options.status) {
        tasks = tasks.filter(t => t.status === options.status);
      }
      if (options.stage) {
        tasks = tasks.filter(t => t.stage === options.stage);
      }
      if (options.withNotion && !options.today && !options.project) {
        // Already filtered by notion_id in the query above
      }

      if (tasks.length === 0) {
        console.log(chalk.gray('No tasks found'));
        return;
      }

      if (options.compact) {
        // Ultra-compact display without table
        console.log(chalk.gray('ID       S P  Title'));
        console.log(chalk.gray('‚îÄ'.repeat(60)));

        const prioritySymbols = {
          5: 'üî¥', 4: 'üü†', 3: 'üü°', 2: 'üîµ', 1: '‚ö™'
        };
        const statusDisplay = {
          'üóÇÔ∏è To File': 'üóÇÔ∏è',
          '1Ô∏è‚É£  1st Priority': '1Ô∏è‚É£',
          '2Ô∏è‚É£  2nd Priority': '2Ô∏è‚É£',
          '3Ô∏è‚É£  3rd Priority': '3Ô∏è‚É£',
          'ü§î Waiting': 'ü§î',
          '‚è∏Ô∏è  Paused': '‚è∏Ô∏è',
          '‚úÖ Done': '‚úÖ'
        };

        for (const task of tasks) {
          const id = task.id.substring(0, 8);
          const status = statusDisplay[task.status] || task.status.substring(0, 3);
          const priority = prioritySymbols[task.priority] || 'üü°';
          const title = task.title.length > 45 ? task.title.substring(0, 42) + '...' : task.title;
          console.log(`${id} ${status} ${priority} ${title}`);
        }
        console.log(chalk.gray(`\nTotal: ${tasks.length} tasks`));
        tm.close();
        return;
      }

      const table = new Table({
        head: ['ID', 'Title', 'St', 'P', 'Due', 'Project'],
        colWidths: [9, 37, 5, 4, 12, 12],
        wordWrap: true
      });

      const prioritySymbols = {
        5: 'üî¥',
        4: 'üü†',
        3: 'üü°',
        2: 'üîµ',
        1: '‚ö™'
      };

      // Status abbreviations for compact display
      const statusDisplay = {
        'üóÇÔ∏è To File': 'üóÇÔ∏è',
        '1Ô∏è‚É£  1st Priority': '1Ô∏è‚É£',
        '2Ô∏è‚É£  2nd Priority': '2Ô∏è‚É£',
        '3Ô∏è‚É£  3rd Priority': '3Ô∏è‚É£',
        'ü§î Waiting': 'ü§î',
        '‚è∏Ô∏è  Paused': '‚è∏Ô∏è',
        '‚úÖ Done': '‚úÖ'
      };

      for (const task of tasks) {
        // Get project name if task has project_id
        let projectName = '-';
        if (task.project_id) {
          const project = tm.db.prepare('SELECT name FROM projects WHERE id = ?').get(task.project_id);
          projectName = project ? project.name : '-';
        }

        table.push([
          task.id.substring(0, 8),
          task.title,
          statusDisplay[task.status] || (task.status ? task.status.substring(0, 3) : '?'),
          prioritySymbols[task.priority] || 'üü°',
          task.do_date || '-',
          projectName
        ]);
      }

      console.log(table.toString());
      console.log(chalk.gray(`\nTotal: ${tasks.length} tasks`));

      // Show stage distribution if stages are set
      const stageCounts = {};
      for (const task of tasks) {
        if (task.stage) {
          stageCounts[task.stage] = (stageCounts[task.stage] || 0) + 1;
        }
      }
      if (Object.keys(stageCounts).length > 0) {
        console.log(chalk.gray('\nBy Stage:'));
        for (const [stage, count] of Object.entries(stageCounts)) {
          const emoji = stage === 'Front Stage' ? 'üë•' :
            stage === 'Back Stage' ? 'üîß' : 'üå¥';
          console.log(chalk.gray(`  ${emoji} ${stage}: ${count}`));
        }
      }
    } finally {
      tm.close();
    }
  });

// Add command
program
  .command('add <title>')
  .description('Add a new task')
  .option('-d, --date <date>', 'Set due date (YYYY-MM-DD)')
  .option('-p, --priority <1-5>', 'Set priority (1-5)', '3')
  .option('-t, --topics <topics>', 'Add topics (comma-separated)')
  .option('-s, --status <status>', 'Set status', 'üóÇÔ∏è  To File')
  .option('--stage <stage>', 'Set stage (Front Stage, Back Stage, Off Stage)')
  .option('--project <name>', 'Assign to project')
  .action((title, options) => {
    const tm = new TaskManager();

    try {
      const data = {
        title,
        do_date: options.date,
        priority: parseInt(options.priority),
        status: options.status,
        stage: options.stage,
        topics: options.topics ? options.topics.split(',').map(t => t.trim()) : []
      };

      if (options.project) {
        data.project_id = tm.getOrCreateProject(options.project);
      }

      const id = tm.createTask(data);
      console.log(chalk.green(`‚úì Created task: ${id.substring(0, 8)}`));
      console.log(chalk.gray(`  "${title}"`));
    } catch (error) {
      console.error(chalk.red('Error creating task:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

// Update command
program
  .command('update <id>')
  .description('Update a task')
  .option('-t, --title <title>', 'Update title')
  .option('-d, --date <date>', 'Update due date')
  .option('-p, --priority <1-5>', 'Update priority')
  .option('-s, --status <status>', 'Update status')
  .option('--stage <stage>', 'Update stage (Front Stage, Back Stage, Off Stage)')
  .option('--topics <topics>', 'Update topics (comma-separated)')
  .action((id, options) => {
    const tm = new TaskManager();

    try {
      // Find task by partial ID
      const tasks = tm.getActiveTasks();
      const task = tasks.find(t => t.id.startsWith(id));

      if (!task) {
        console.error(chalk.red(`Task not found: ${id}`));
        process.exit(1);
      }

      const updates = {};
      if (options.title) updates.title = options.title;
      if (options.date) updates.do_date = options.date;
      if (options.priority) updates.priority = parseInt(options.priority);
      if (options.status) updates.status = options.status;
      if (options.stage) updates.stage = options.stage;
      if (options.topics) updates.topics = options.topics.split(',').map(t => t.trim());

      tm.updateTask(task.id, updates);
      console.log(chalk.green(`‚úì Updated task: ${task.id.substring(0, 8)}`));
    } catch (error) {
      console.error(chalk.red('Error updating task:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

// Done command
program
  .command('done <id>')
  .description('Mark a task as done')
  .action((id) => {
    const tm = new TaskManager();

    try {
      const tasks = tm.getActiveTasks();
      const task = tasks.find(t => t.id.startsWith(id));

      if (!task) {
        console.error(chalk.red(`Task not found: ${id}`));
        process.exit(1);
      }

      tm.updateTask(task.id, { status: '‚úÖ Done' });
      console.log(chalk.green(`‚úì Marked as done: ${task.title}`));

      // Check for repeating task
      if (task.repeat_frequency) {
        const repeated = tm.processRepeatingTasks();
        if (repeated > 0) {
          console.log(chalk.blue(`‚úì Created next recurrence`));
        }
      }
    } catch (error) {
      console.error(chalk.red('Error marking task as done:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

// Classify stages command - works with markdown files
program
  .command('classify-stages [file]')
  .description('Add stage tags to tasks using AI analysis')
  .option('--all', 'Reclassify all tasks (not just unclassified)')
  .option('-v, --verbose', 'Show detailed output')
  .option('--no-ai', 'Use simple keyword matching instead of AI')
  .action(async (file, options) => {
    console.log(chalk.blue('üé≠ Classifying task stages in markdown files...'));

    // Check if AI is available and desired
    const useAI = !options.noAi && (() => {
      try {
        execSync('which claude', { encoding: 'utf8' });
        return true;
      } catch {
        console.log(chalk.yellow('‚ö†Ô∏è  Claude CLI not available - falling back to keyword matching'));
        return false;
      }
    })();

    // Find files to process
    const files = file ? [file] : findMarkdownFilesWithTasks();

    if (files.length === 0) {
      console.log(chalk.gray('No task files found'));
      process.exit(0);
    }

    let totalClassified = 0;

    if (useAI) {
      // AI-powered stage classification
      const BATCH_SIZE = 20;

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        // Collect tasks needing classification
        const tasksToClassify = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/#stage\//))) {
            const title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();
            tasksToClassify.push({ lineIndex: i, title, line });
          }
        }

        if (tasksToClassify.length === 0) continue;

        // Process in batches
        for (let i = 0; i < tasksToClassify.length; i += BATCH_SIZE) {
          const batch = tasksToClassify.slice(i, Math.min(i + BATCH_SIZE, tasksToClassify.length));

          const prompt = `Analyze these tasks and classify them into one of three stages based on their nature.

The three stages are:
- front-stage: Tasks involving direct interaction with others (meetings, calls, emails, presentations, customer support, networking)
- back-stage: Solo work tasks (planning, coding, organizing, maintenance, documentation, research, analysis)
- off-stage: Personal time tasks (self-care, health, exercise, relaxation, hobbies, personal relationships)

Respond with a JSON array where each has:
{"index": task_index, "stage": "front-stage|back-stage|off-stage"}

Tasks:
${JSON.stringify(batch.map((t, idx) => ({index: idx + i, title: t.title})), null, 2)}`;

          try {
            if (options.verbose) {
              console.log(`  Processing batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(tasksToClassify.length/BATCH_SIZE)}...`);
            }

            const result = execSync(`claude --print '${prompt.replace(/'/g, "'\\''")}'`, {
              encoding: 'utf8',
              maxBuffer: 1024 * 1024 * 10,
              timeout: 60000
            });

            const jsonMatch = result.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
              const classifications = JSON.parse(jsonMatch[0]);

              for (const cls of classifications) {
                const task = tasksToClassify[cls.index];
                const stage = `#stage/${cls.stage}`;

                if (!task.line.includes(stage)) {
                  let newLine = task.line;

                  // Insert stage after priority emoji if present
                  const priorityMatch = newLine.match(/(.*?)(üî∫|‚è´|üîº|üîΩ|‚è¨)(.*)/);
                  if (priorityMatch) {
                    newLine = `${priorityMatch[1]}${priorityMatch[2]} ${stage}${priorityMatch[3]}`;
                  } else {
                    // Insert before dates or at end
                    const dateMatch = newLine.match(/(.*?)([üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}.*)/);
                    if (dateMatch) {
                      newLine = `${dateMatch[1]} ${stage} ${dateMatch[2]}`;
                    } else {
                      newLine = `${newLine} ${stage}`;
                    }
                  }

                  lines[task.lineIndex] = newLine;
                  modified = true;
                  totalClassified++;
                }
              }
            }
          } catch (error) {
            console.error(chalk.yellow(`  Failed to process batch: ${error.message}`));
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    } else {
      // Fallback to keyword-based classification
      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/#stage\//))) {
            let title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();

            let stage = '';
            if (title.match(/\b(meeting|call|email|support|customer|present|interview)\b/i)) {
              stage = '#stage/front-stage';
            } else if (title.match(/\b(fix|bug|maintain|organize|plan|bill|document|setup)\b/i)) {
              stage = '#stage/back-stage';
            } else if (title.match(/\b(personal|health|exercise|read|friend|family|relax|self)\b/i)) {
              stage = '#stage/off-stage';
            } else {
              stage = '#stage/back-stage';
            }

            if (!lines[i].includes(stage)) {
              const priorityMatch = line.match(/(.*?)(üî∫|‚è´|üîº|üîΩ|‚è¨)(.*)/);
              if (priorityMatch) {
                lines[i] = `${priorityMatch[1]}${priorityMatch[2]} ${stage}${priorityMatch[3]}`;
              } else {
                const dateMatch = line.match(/(.*?)([üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}.*)/);
                if (dateMatch) {
                  lines[i] = `${dateMatch[1]} ${stage} ${dateMatch[2]}`;
                } else {
                  lines[i] = `${line} ${stage}`;
                }
              }
              modified = true;
              totalClassified++;
            }
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    }

    console.log(chalk.green(`‚úì Classified ${totalClassified} task(s) with stage tags`));
    process.exit(0);
  });

// Add topics command - works with markdown files
program
  .command('add-topics [file]')
  .description('Add topic tags to tasks using AI analysis')
  .option('--all', 'Reassign topics to all tasks (not just unassigned)')
  .option('-v, --verbose', 'Show detailed output')
  .option('--no-ai', 'Use simple keyword matching instead of AI')
  .action(async (file, options) => {
    console.log(chalk.blue('üè∑Ô∏è  Adding topic tags to tasks in markdown files...'));

    // Check if AI is available and desired
    const useAI = !options.noAi && (() => {
      try {
        execSync('which claude', { encoding: 'utf8' });
        return true;
      } catch {
        console.log(chalk.yellow('‚ö†Ô∏è  Claude CLI not available - falling back to keyword matching'));
        return false;
      }
    })();

    // Find files to process
    const files = file ? [file] : findMarkdownFilesWithTasks();

    if (files.length === 0) {
      console.log(chalk.gray('No task files found'));
      process.exit(0);
    }

    // Available topics (based on existing patterns in the codebase)
    const availableTopics = [
      'ai', 'career', 'finance', 'health', 'home', 'ogm',
      'social', 'technology', 'travel', 'programming', 'learning',
      'shopping', 'security'
    ];

    let totalTopicsAdded = 0;

    if (useAI) {
      // AI-powered topic classification
      const BATCH_SIZE = 15;

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        // Collect tasks needing topics
        const tasksToClassify = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/#topic\//))) {
            const title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();
            tasksToClassify.push({ lineIndex: i, title, line });
          }
        }

        if (tasksToClassify.length === 0) continue;

        // Process in batches
        for (let i = 0; i < tasksToClassify.length; i += BATCH_SIZE) {
          const batch = tasksToClassify.slice(i, Math.min(i + BATCH_SIZE, tasksToClassify.length));

          const prompt = `Analyze these tasks and suggest 1-2 relevant topics for each from the available list.

Available topics: ${availableTopics.join(', ')}

For each task, choose the most relevant topic(s) based on:
- Keywords that match topic areas
- The nature of the work (technical, personal, organizational)
- Related areas involved

Respond with a JSON array where each has:
{"index": task_index, "topics": ["topic1", "topic2"]}

If no topics clearly apply, use an empty array.
Only use topics from the available list.

Tasks:
${JSON.stringify(batch.map((t, idx) => ({index: idx + i, title: t.title})), null, 2)}`;

          try {
            if (options.verbose) {
              console.log(`  Processing batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(tasksToClassify.length/BATCH_SIZE)}...`);
            }

            const result = execSync(`claude --print '${prompt.replace(/'/g, "'\\''")}'`, {
              encoding: 'utf8',
              maxBuffer: 1024 * 1024 * 10,
              timeout: 60000
            });

            const jsonMatch = result.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
              const classifications = JSON.parse(jsonMatch[0]);

              for (const cls of classifications) {
                const task = tasksToClassify[cls.index];
                if (cls.topics && cls.topics.length > 0) {
                  let newLine = task.line;

                  // Add topics
                  for (const topic of cls.topics.slice(0, 2)) { // Max 2 topics
                    if (availableTopics.includes(topic) && !newLine.includes(`#topic/${topic}`)) {
                      const stageMatch = newLine.match(/(.*#stage\/[\w-]+)(.*)/);
                      if (stageMatch) {
                        newLine = `${stageMatch[1]} #topic/${topic}${stageMatch[2]}`;
                      } else {
                        const dateMatch = newLine.match(/(.*?)([üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}.*)/);
                        if (dateMatch) {
                          newLine = `${dateMatch[1]} #topic/${topic} ${dateMatch[2]}`;
                        } else {
                          newLine = `${newLine} #topic/${topic}`;
                        }
                      }
                      totalTopicsAdded++;
                    }
                  }

                  if (newLine !== task.line) {
                    lines[task.lineIndex] = newLine;
                    modified = true;
                  }
                }
              }
            }
          } catch (error) {
            console.error(chalk.yellow(`  Failed to process batch: ${error.message}`));
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    } else {
      // Fallback to keyword-based classification
      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/#topic\//))) {
            let title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();

            const topics = [];
            if (title.match(/\b(health|exercise|doctor|medical|diet|wellness)\b/i)) topics.push('#topic/health');
            if (title.match(/\b(code|program|debug|fix|develop|git|api)\b/i)) topics.push('#topic/programming');
            if (title.match(/\b(oldergay|ogm|website|discourse|forum)\b/i)) topics.push('#topic/ogm');
            if (title.match(/\b(ai|claude|gpt|chatgpt|llm|machine learning)\b/i)) topics.push('#topic/ai');
            if (title.match(/\b(money|bill|tax|payment|finance|invest)\b/i)) topics.push('#topic/finance');
            if (title.match(/\b(house|home|clean|repair|maintenance|chore)\b/i)) topics.push('#topic/home');
            if (title.match(/\b(friend|family|social|meet|relationship)\b/i)) topics.push('#topic/social');
            if (title.match(/\b(learn|read|course|study|research|book)\b/i)) topics.push('#topic/learning');
            if (title.match(/\b(travel|trip|flight|hotel|vacation)\b/i)) topics.push('#topic/travel');
            if (title.match(/\b(buy|shop|order|purchase|amazon)\b/i)) topics.push('#topic/shopping');

            if (topics.length > 0) {
              let newLine = line;
              for (const topic of topics) {
                if (!newLine.includes(topic)) {
                  const stageMatch = newLine.match(/(.*#stage\/[\w-]+)(.*)/);
                  if (stageMatch) {
                    newLine = `${stageMatch[1]} ${topic}${stageMatch[2]}`;
                  } else {
                    const dateMatch = newLine.match(/(.*?)([üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}.*)/);
                    if (dateMatch) {
                      newLine = `${dateMatch[1]} ${topic} ${dateMatch[2]}`;
                    } else {
                      newLine = `${newLine} ${topic}`;
                    }
                  }
                  totalTopicsAdded++;
                }
              }
              if (newLine !== line) {
                lines[i] = newLine;
                modified = true;
              }
            }
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    }

    console.log(chalk.green(`‚úì Added ${totalTopicsAdded} topic tag(s) to tasks`));
    process.exit(0);
  });

// Prioritize status command - works with markdown files
program
  .command('prioritize-status [file]')
  .description('Add priority emojis to tasks using AI analysis')
  .option('--all', 'Reprioritize all tasks (not just unprioritized)')
  .option('-v, --verbose', 'Show detailed output')
  .option('--no-ai', 'Use simple keyword matching instead of AI')
  .action(async (file, options) => {
    console.log(chalk.blue('üéØ Adding priority emojis to tasks in markdown files...'));

    // Check if AI is available and desired
    const useAI = !options.noAi && (() => {
      try {
        execSync('which claude', { encoding: 'utf8' });
        return true;
      } catch {
        console.log(chalk.yellow('‚ö†Ô∏è  Claude CLI not available - falling back to keyword matching'));
        return false;
      }
    })();

    // Find files to process
    const files = file ? [file] : findMarkdownFilesWithTasks();

    if (files.length === 0) {
      console.log(chalk.gray('No task files found'));
      process.exit(0);
    }

    let totalPrioritized = 0;

    if (useAI) {
      // AI-powered prioritization
      const BATCH_SIZE = 20;

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        // Collect tasks needing prioritization
        const tasksToClassify = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/üî∫|‚è´|üîº|üîΩ|‚è¨/))) {
            const title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();
            tasksToClassify.push({ lineIndex: i, title, line });
          }
        }

        if (tasksToClassify.length === 0) continue;

        // Process in batches
        for (let i = 0; i < tasksToClassify.length; i += BATCH_SIZE) {
          const batch = tasksToClassify.slice(i, Math.min(i + BATCH_SIZE, tasksToClassify.length));

          const prompt = `Analyze these tasks and assign priority emojis based on urgency and importance.

Use EXACTLY these priority emojis:
- üî∫ (Highest) - Urgent and critical (health emergencies, critical deadlines, system failures)
- ‚è´ (High) - Important and time-sensitive (upcoming deadlines, scheduled meetings, important fixes)
- üîº (Medium) - Regular priority (most daily tasks, routine work)
- üîΩ (Low) - Nice to have (someday/maybe items, research, exploration)
- ‚è¨ (Lowest) - Reference or optional (archived ideas, distant future)

Respond with a JSON array where each has:
{"index": task_index, "priority": "emoji"}

Tasks:
${JSON.stringify(batch.map((t, idx) => ({index: idx + i, title: t.title})), null, 2)}`;

          try {
            if (options.verbose) {
              console.log(`  Processing batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(tasksToClassify.length/BATCH_SIZE)}...`);
            }

            const result = execSync(`claude --print '${prompt.replace(/'/g, "'\\''")}'`, {
              encoding: 'utf8',
              maxBuffer: 1024 * 1024 * 10,
              timeout: 60000 // 1 minute timeout per batch
            });

            const jsonMatch = result.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
              const classifications = JSON.parse(jsonMatch[0]);

              for (const cls of classifications) {
                const task = tasksToClassify[cls.index];
                const cleanLine = task.line.replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '').trim();
                const taskMatch = cleanLine.match(/^(- \[ \] [^#üìÖ‚è≥‚úÖüîÅ]+)(.*)/);
                if (taskMatch) {
                  lines[task.lineIndex] = `${taskMatch[1].trim()} ${cls.priority}${taskMatch[2] ? ' ' + taskMatch[2].trim() : ''}`;
                  modified = true;
                  totalPrioritized++;
                }
              }
            }
          } catch (error) {
            console.error(chalk.yellow(`  Failed to process batch: ${error.message}`));
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    } else {
      // Fallback to keyword-based prioritization
      for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');
        let modified = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^- \[ \] /) && (options.all || !line.match(/üî∫|‚è´|üîº|üîΩ|‚è¨/))) {
            let title = line.replace(/^- \[ \] /, '')
              .replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '')
              .replace(/#\w+\/[\w-]+/g, '')
              .replace(/[üìÖ‚è≥‚úÖ] \d{4}-\d{2}-\d{2}/g, '')
              .replace(/üîÅ .+$/g, '')
              .trim();

            let priority = '';
            if (title.match(/\b(urgent|critical|emergency|asap|immediately|blocker)\b/i)) {
              priority = 'üî∫';
            } else if (title.match(/\b(important|high|soon|priority|deadline)\b/i)) {
              priority = '‚è´';
            } else if (title.match(/\b(someday|maybe|consider|explore|research)\b/i)) {
              priority = 'üîΩ';
            } else if (title.match(/\b(due|scheduled|meeting|call|appointment)\b/i)) {
              priority = '‚è´';
            } else {
              priority = 'üîº';
            }

            const cleanLine = line.replace(/üî∫|‚è´|üîº|üîΩ|‚è¨/g, '').trim();
            const taskMatch = cleanLine.match(/^(- \[ \] [^#üìÖ‚è≥‚úÖüîÅ]+)(.*)/);
            if (taskMatch) {
              lines[i] = `${taskMatch[1].trim()} ${priority}${taskMatch[2] ? ' ' + taskMatch[2].trim() : ''}`;
              modified = true;
              totalPrioritized++;
            }
          }
        }

        if (modified) {
          fs.writeFileSync(file, lines.join('\n'));
          if (options.verbose) {
            console.log(chalk.gray(`  Updated: ${file}`));
          }
        }
      }
    }

    console.log(chalk.green(`‚úì Prioritized ${totalPrioritized} task(s) with emoji indicators`));
    process.exit(0);
  });

// Search command
program
  .command('search <query>')
  .description('Search for tasks and show detailed information')
  .option('-a, --all', 'Include completed/archived tasks')
  .option('-v, --verbose', 'Show all available fields')
  .action((query, options) => {
    const tm = new TaskManager('.data/today.db', { readOnly: true });

    try {
      // Search in all tasks if --all, otherwise just active
      let sql = options.all ?
        'SELECT * FROM tasks WHERE title LIKE ? OR description LIKE ? OR content LIKE ?' :
        "SELECT * FROM tasks WHERE (title LIKE ? OR description LIKE ? OR content LIKE ?) AND status != '‚úÖ Done'";

      const searchPattern = `%${query}%`;
      const tasks = tm.db.prepare(sql).all(searchPattern, searchPattern, searchPattern);

      if (tasks.length === 0) {
        console.log(chalk.yellow(`No tasks found matching "${query}"`));
        return;
      }

      console.log(chalk.blue(`\nFound ${tasks.length} task(s) matching "${query}":\n`));

      for (const task of tasks) {
        console.log(chalk.bold('‚ïê'.repeat(60)));
        console.log(chalk.bold.cyan(`üìã ${task.title}`));
        console.log(chalk.gray('‚îÄ'.repeat(60)));

        // Basic info
        console.log(`ID:              ${chalk.yellow(task.id)}`);
        console.log(`Status:          ${task.status || chalk.gray('Not set')}`);
        console.log(`Stage:           ${task.stage || chalk.gray('Not set')}`);
        console.log(`Do Date:         ${task.do_date || chalk.gray('Not set')}`);
        console.log(`Created:         ${new Date(task.created_at).toLocaleString()}`);
        console.log(`Updated:         ${new Date(task.updated_at).toLocaleString()}`);

        if (task.completed_at) {
          console.log(`Completed:       ${new Date(task.completed_at).toLocaleString()}`);
        }

        // Project info
        if (task.project_id) {
          const project = tm.db.prepare('SELECT name FROM projects WHERE id = ?').get(task.project_id);
          console.log(`Project:         ${project ? project.name : task.project_id}`);
        }

        // Repeat info
        if (task.repeat_interval) {
          console.log(`Repeat:          Every ${task.repeat_interval} days`);
          if (task.repeat_next_date) {
            console.log(`Next Due:        ${task.repeat_next_date}`);
          }
        }

        // Notion info
        if (task.notion_id) {
          console.log(`Notion ID:       ${task.notion_id}`);
          if (task.notion_url) {
            console.log(`Notion URL:      ${task.notion_url}`);
          }
        }

        // Topics
        try {
          const topics = tm.db.prepare(`
            SELECT t.name FROM topics t
            JOIN task_topics tt ON t.id = tt.topic_id
            WHERE tt.task_id = ?
          `).all(task.id);

          if (topics.length > 0) {
            console.log(`Topics:          ${topics.map(t => t.name).join(', ')}`);
          }
        } catch (e) {
          // Topics table might not exist in some databases
        }

        // Description - Always show if exists
        if (task.description) {
          console.log('');
          console.log(chalk.bold('Description:'));
          console.log(chalk.gray(task.description));
        }

        if (task.content) {
          console.log(`\nContent:`);
          console.log(chalk.gray(task.content));
        }

        // Verbose mode - show ALL fields
        if (options.verbose) {
          console.log(chalk.gray('\n' + '‚îÄ'.repeat(60)));
          console.log(chalk.gray('All fields:'));
          for (const [key, value] of Object.entries(task)) {
            if (value !== null && value !== undefined && value !== '') {
              console.log(chalk.gray(`  ${key}: ${value}`));
            }
          }
        }

        console.log('');
      }
    } catch (error) {
      console.error(chalk.red('Error searching tasks:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

// Projects command
program
  .command('projects')
  .description('List all projects')
  .option('-d, --detailed', 'Show detailed project information')
  .action((options) => {
    const tm = new TaskManager();

    try {
      const projects = tm.db.prepare('SELECT * FROM projects ORDER BY start_date DESC, name').all();

      if (projects.length === 0) {
        console.log(chalk.gray('No projects found'));
        return;
      }

      if (options.detailed) {
        for (const project of projects) {
          const taskCount = tm.db.prepare('SELECT COUNT(*) as count FROM tasks WHERE project_id = ?')
            .get(project.id).count;
          const doneCount = tm.db.prepare("SELECT COUNT(*) as count FROM tasks WHERE project_id = ? AND status = '‚úÖ Done'")
            .get(project.id).count;

          console.log(chalk.bold(`\n${project.name}`));
          console.log(chalk.gray('‚îÄ'.repeat(40)));
          console.log(`ID:       ${project.id.substring(0, 8)}`);
          console.log(`Status:   ${project.status}`);
          if (project.start_date || project.end_date) {
            console.log(`Dates:    ${project.start_date || '?'} to ${project.end_date || '?'}`);
          }
          if (project.budget) {
            console.log(`Budget:   $${project.budget.toLocaleString()}`);
          }
          console.log(`Tasks:    ${doneCount}/${taskCount} completed`);
          if (project.file_path) {
            console.log(`File:     ${project.file_path}`);
          }
          if (project.description) {
            console.log(`\n${project.description.substring(0, 200)}${project.description.length > 200 ? '...' : ''}`);
          }
        }
      } else {
        const table = new Table({
          head: ['ID', 'Name', 'Status', 'Dates', 'Tasks'],
          colWidths: [10, 25, 10, 20, 10]
        });

        for (const project of projects) {
          const taskCount = tm.db.prepare('SELECT COUNT(*) as count FROM tasks WHERE project_id = ?')
            .get(project.id).count;
          const doneCount = tm.db.prepare("SELECT COUNT(*) as count FROM tasks WHERE project_id = ? AND status = '‚úÖ Done'")
            .get(project.id).count;

          let dates = '-';
          if (project.start_date && project.end_date) {
            const start = new Date(project.start_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const end = new Date(project.end_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            dates = `${start} - ${end}`;
          }

          table.push([
            project.id.substring(0, 8),
            project.name,
            project.status,
            dates,
            `${doneCount}/${taskCount}`
          ]);
        }

        console.log(table.toString());
      }
    } finally {
      tm.close();
    }
  });

// Clear Notion IDs command
program
  .command('clear-notion-ids')
  .description('Remove Notion IDs from tasks after successful migration')
  .option('--force', 'Skip confirmation prompt')
  .action(async (options) => {
    const tm = new TaskManager();

    try {
      // Count tasks with Notion IDs
      const tasksWithNotion = tm.db.prepare(`
        SELECT COUNT(*) as count 
        FROM tasks 
        WHERE notion_id IS NOT NULL
      `).get();

      if (tasksWithNotion.count === 0) {
        console.log(chalk.gray('No tasks with Notion IDs found'));
        return;
      }

      console.log(chalk.yellow(`Found ${tasksWithNotion.count} tasks with Notion IDs`));

      if (!options.force) {
        console.log(chalk.bold('\n‚ö†Ô∏è  This will remove all Notion IDs from the database'));
        console.log(chalk.gray('This action cannot be undone'));
        console.log(chalk.gray('Make sure you have marked these tasks as done in Notion first'));
        console.log(chalk.gray('\nTo proceed, run with --force flag'));
        process.exit(0);
      }

      // Clear Notion IDs
      const result = tm.db.prepare(`
        UPDATE tasks 
        SET notion_id = NULL, notion_url = NULL 
        WHERE notion_id IS NOT NULL
      `).run();

      console.log(chalk.green(`‚úì Cleared Notion IDs from ${result.changes} tasks`));

    } catch (error) {
      console.error(chalk.red('Error clearing Notion IDs:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

// Check consistency command
program
  .command('check-consistency')
  .description('Check and fix task completion consistency across all markdown files')
  .option('--fix', 'Automatically fix inconsistencies')
  .option('-v, --verbose', 'Show detailed output')
  .action(async (options) => {
    const { execSync } = await import('child_process');
    const { promises: fs } = await import('fs');
    const tm = new TaskManager();

    try {
      if (options.verbose) {
        console.log(chalk.blue('Checking task consistency across all markdown files...'));
        console.log(chalk.gray('Using latest modification time to determine correct state'));
      }

      // Find all markdown files (including vault/tasks/ for proper consistency)
      const markdownFiles = execSync('find "vault/" -name "*.md" -type f -not -path "*/templates/*" -not -path "*/.stversions/*" -not -name "*sync-conflict*" 2>/dev/null', { encoding: 'utf8' })
        .split('\n')
        .filter(f => f && !f.includes('node_modules') && !f.includes('.git'))
        .map(f => f.replace(/^\.\//, ''));

      if (options.verbose) {
        console.log(chalk.gray(`Scanning ${markdownFiles.length} markdown files...`));
      }

      // Collect all task statuses from all files with modification times
      const taskStatuses = new Map(); // taskId -> { states: Map<filePath, {completed, mtime}> }
      const taskTitles = new Map(); // taskId -> title

      for (const filePath of markdownFiles) {
        // Process ALL files including vault/tasks/ to check consistency
        // The "latest modification wins" logic will determine the correct state

        try {
          const content = await fs.readFile(filePath, 'utf-8');
          const lines = content.split('\n');
          const stats = await fs.stat(filePath);
          const mtime = stats.mtime;

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Match task lines with IDs - handle both normal and corrupted formats
            // Also matches "task-id: none" for proper handling
            const taskMatch = line.match(/^- \[([ x])\] (.+?)(?:<![-‚Äî]+ task-id: ([a-f0-9]{32}|none) [-‚Äî]+>|<!-- task-id: ([a-f0-9]{32}|none) -->)/);

            if (taskMatch) {
              const isCompleted = taskMatch[1] === 'x';
              const title = taskMatch[2].trim();
              const taskId = taskMatch[3] || taskMatch[4];

              // Skip tasks marked with task-id: none (template/routine tasks)
              if (taskId === 'none') {
                continue;
              }

              if (!taskStatuses.has(taskId)) {
                taskStatuses.set(taskId, {
                  states: new Map([[filePath, { completed: isCompleted, mtime }]])
                });
                taskTitles.set(taskId, title);
              } else {
                const status = taskStatuses.get(taskId);
                status.states.set(filePath, { completed: isCompleted, mtime });
              }
            }
          }
        } catch (err) {
          // File doesn't exist or can't be read
        }
      }

      // Find inconsistent tasks and determine correct state based on latest change
      const inconsistentTasks = [];
      for (const [taskId, status] of taskStatuses) {
        const states = Array.from(status.states.entries());
        const completedStates = states.filter(([_, state]) => state.completed);
        const notCompletedStates = states.filter(([_, state]) => !state.completed);

        // Only inconsistent if we have both completed and not completed states
        if (completedStates.length > 0 && notCompletedStates.length > 0) {
          // Find the most recent modification
          let latestFile = null;
          let latestMtime = new Date(0);
          let latestCompleted = false;

          for (const [file, state] of status.states) {
            if (state.mtime > latestMtime) {
              latestMtime = state.mtime;
              latestFile = file;
              latestCompleted = state.completed;
            }
          }

          inconsistentTasks.push({
            id: taskId,
            title: taskTitles.get(taskId),
            completedIn: completedStates.map(([file]) => file),
            notCompletedIn: notCompletedStates.map(([file]) => file),
            shouldBeCompleted: latestCompleted,
            latestFile,
            latestMtime
          });
        }
      }

      if (inconsistentTasks.length === 0) {
        console.log(chalk.green('‚úì All tasks are consistent across files!'));
        return;
      }

      console.log(chalk.yellow(`Found ${inconsistentTasks.length} inconsistent task(s):\n`));

      // Display inconsistencies
      const table = new Table({
        head: ['Task', 'Status', 'Files'],
        colWidths: [40, 15, 40],
        wordWrap: true
      });

      for (const task of inconsistentTasks) {
        const taskTitle = task.title.length > 37 ? task.title.substring(0, 34) + '...' : task.title;
        const status = task.shouldBeCompleted ? '‚Üí Done' : '‚Üí Not Done';
        const latestInfo = `Latest: ${path.basename(task.latestFile)}\n${task.latestMtime.toLocaleString()}`;
        table.push([taskTitle, status, latestInfo]);
      }

      console.log(table.toString());

      if (!options.fix) {
        console.log(chalk.yellow('\nRun with --fix to automatically resolve inconsistencies'));
        console.log(chalk.gray('(Latest change wins strategy)'));
        return;
      }

      // Fix inconsistencies
      console.log(chalk.blue('\nFixing inconsistencies...'));

      // Update database
      for (const task of inconsistentTasks) {
        const newStatus = task.shouldBeCompleted ? '‚úÖ Done' : 'üóÇÔ∏è To File';
        tm.updateTask(task.id, { status: newStatus });
        if (options.verbose) {
          console.log(chalk.green(`  ‚úì Updated ${task.title.substring(0, 50)}... to ${newStatus}`));
        }
      }

      // Update markdown files
      for (const task of inconsistentTasks) {
        const filesToUpdate = task.shouldBeCompleted ? task.notCompletedIn : task.completedIn;

        for (const filePath of filesToUpdate) {
          // Update ALL files to maintain consistency
          // Even auto-generated files should reflect the latest state
          const content = await fs.readFile(filePath, 'utf-8');
          const lines = content.split('\n');
          let updated = false;

          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes(`task-id: ${task.id}`)) {
              // Update the checkbox
              if (task.shouldBeCompleted) {
                lines[i] = lines[i].replace(/^- \[ \]/, '- [x]');
              } else {
                lines[i] = lines[i].replace(/^- \[x\]/, '- [ ]');
              }
              updated = true;
            }
          }

          if (updated) {
            await fs.writeFile(filePath, lines.join('\n'));
            if (options.verbose) {
              console.log(chalk.green(`  ‚úì Updated ${filePath}`));
            }
          }
        }
      }

      console.log(chalk.green(`\n‚úì Fixed ${inconsistentTasks.length} inconsistent task(s)`));
      console.log(chalk.gray('Run "bin/sync" to regenerate task files with consistent data'));

    } catch (error) {
      console.error(chalk.red('Error checking consistency:'), error.message);
      process.exit(1);
    } finally {
      tm.close();
    }
  });

program.parse();