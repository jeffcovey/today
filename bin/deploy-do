#!/usr/bin/env python3
"""Deploy to DigitalOcean Droplet

This script helps manage deployment to a DigitalOcean droplet.
"""

import os
import sys
import subprocess
import shutil
from pathlib import Path
from datetime import datetime

# Get the project root directory
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent

# ANSI colors
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
BLUE = '\033[0;34m'
RED = '\033[0;31m'
NC = '\033[0m'  # No Color


def print_status(msg):
    print(f"{GREEN}âœ“{NC} {msg}")


def print_info(msg):
    print(f"{BLUE}â„¹{NC} {msg}")


def print_warning(msg):
    print(f"{YELLOW}âš {NC} {msg}")


def print_error(msg):
    print(f"{RED}âœ—{NC} {msg}")


def get_env(key, default=None):
    """Get environment variable, with optional default."""
    return os.environ.get(key, default)


def require_env(key):
    """Get required environment variable or exit."""
    value = os.environ.get(key)
    if not value:
        print_error(f"{key} not set!")
        print(f"Please set your {key}:")
        print(f"  export {key}=your_value")
        print("Or add to .env:")
        print(f"  {key}=your_value")
        sys.exit(1)
    return value


def run(cmd, check=True, capture=False, shell=False, **kwargs):
    """Run a command with subprocess."""
    if isinstance(cmd, str) and not shell:
        cmd = cmd.split()

    if capture:
        result = subprocess.run(cmd, capture_output=True, text=True, shell=shell, **kwargs)
        if check and result.returncode != 0:
            print_error(f"Command failed: {cmd}")
            if result.stderr:
                print(result.stderr)
            sys.exit(1)
        return result
    else:
        result = subprocess.run(cmd, shell=shell, **kwargs)
        if check and result.returncode != 0:
            sys.exit(result.returncode)
        return result


class DigitalOceanDeploy:
    """Manages deployment to a DigitalOcean droplet."""

    def __init__(self):
        self.droplet_ip = get_env('DO_DROPLET_IP')
        self.droplet_user = get_env('DO_DROPLET_USER', 'root')
        self.deploy_path = '/opt/today'
        self.ssh_key = Path.home() / '.ssh' / 'do_deploy_key'
        self.deploy_domain = get_env('DO_DEPLOY_DOMAIN', 'today.example.com')
        self.admin_email = get_env('DO_ADMIN_EMAIL', 'admin@example.com')

        # Ensure SSH key exists
        if not self.ssh_key.exists():
            print_warning("Deployment key not found. Setting up...")
            run([str(PROJECT_ROOT / '.devcontainer' / 'setup-ssh-keys.sh')])

    def check_config(self):
        """Verify required configuration is set."""
        if not self.droplet_ip:
            print_error("DO_DROPLET_IP not set!")
            print("Please set your droplet IP:")
            print("  export DO_DROPLET_IP=your.droplet.ip.address")
            print("Or add to .env:")
            print("  DO_DROPLET_IP=your.droplet.ip.address")
            sys.exit(1)

    def ssh_cmd(self, command, check=True, capture=False):
        """Run a command on the remote server via SSH."""
        ssh_args = ['ssh', '-i', str(self.ssh_key),
                    f'{self.droplet_user}@{self.droplet_ip}', command]
        return run(ssh_args, check=check, capture=capture)

    def ssh_script(self, script, check=True):
        """Run a multi-line script on the remote server."""
        # Use bash -c to run the script
        return self.ssh_cmd(f'bash -c {repr(script)}', check=check)

    def scp_to_remote(self, local_path, remote_path):
        """Copy a file to the remote server."""
        run(['scp', '-i', str(self.ssh_key), str(local_path),
             f'{self.droplet_user}@{self.droplet_ip}:{remote_path}'])

    def rsync_to_remote(self, local_path, remote_path, *extra_args):
        """Rsync files to the remote server."""
        cmd = ['rsync', '-avz', '-e', f'ssh -i {self.ssh_key}']
        cmd.extend(extra_args)
        cmd.extend([str(local_path), f'{self.droplet_user}@{self.droplet_ip}:{remote_path}'])
        run(cmd)

    # =========================================================================
    # Commands
    # =========================================================================

    def cmd_setup(self, args):
        """Initial setup of DigitalOcean droplet."""
        print("ðŸš€ Initial setup of DigitalOcean droplet...")
        self.check_config()

        print_info("This will install Node.js, Git, and dependencies on your droplet")

        # Check for --yes flag or non-interactive
        if not sys.stdin.isatty() or (args and args[0] in ['--yes', '-y']):
            confirm = 'y'
        else:
            confirm = input("Continue? (y/n) ").strip().lower()

        if confirm != 'y':
            sys.exit(1)

        print_info("Copying setup script to droplet...")
        self.scp_to_remote(PROJECT_ROOT / 'bin' / 'setup-droplet.sh', '/tmp/')

        print_info("Running setup on droplet...")
        self.ssh_cmd('bash /tmp/setup-droplet.sh')

        print_status("Setup complete!")
        print("Run 'bin/deploy-do deploy' to deploy your code")

    def cmd_deploy(self, args):
        """Deploy code to droplet."""
        print("ðŸš¢ Deploying to DigitalOcean...")
        self.check_config()

        print_info(f"Syncing code to {self.droplet_user}@{self.droplet_ip}:{self.deploy_path}")

        # Create directories
        self.ssh_cmd(f'mkdir -p {self.deploy_path} {self.deploy_path}/.data')

        # Git pull
        print_info("Pulling latest code from git...")
        self.ssh_cmd(f'cd {self.deploy_path} && git pull')

        # Sync config files
        print_info("Syncing configuration files...")
        self.rsync_to_remote('./', f'{self.deploy_path}/',
                            '--include=.env', '--include=.env.keys', '--exclude=*')

        # Configure git
        self.ssh_cmd(f'git config --global --add safe.directory {self.deploy_path}', check=False)
        self.ssh_cmd("git config --global user.email 'today-bot@system.local' && "
                    "git config --global user.name 'Today Bot'", check=False)

        # Setup tmux config
        self.ssh_cmd(f'[ ! -f ~/.tmux.conf ] && echo \'set -g default-command "cd {self.deploy_path} && exec bash"\' > ~/.tmux.conf || true', check=False)

        # Configure GitHub auth
        print_info("Configuring GitHub authentication...")
        self.ssh_cmd(f'cd {self.deploy_path} && npx dotenvx run -- bash -c \''
                    'if [ -n "$GITHUB_TOKEN" ]; then '
                    'echo "https://$GITHUB_TOKEN:x-oauth-basic@github.com" > ~/.git-credentials && '
                    'git config --global credential.helper store && '
                    'echo "âœ“ GitHub token configured"; fi\'', check=False)

        # Install dependencies
        print_info("Installing dependencies...")
        self.ssh_cmd(f'cd {self.deploy_path} && npm install --production')

        # Run migrations
        print_info("Running database migrations...")
        result = self.ssh_cmd(f'cd {self.deploy_path} && timeout 30 npx dotenvx run -- node src/migrations.js', check=False)
        if result.returncode != 0:
            print_warning("Migrations may have already run")

        # Check Resilio Sync
        print_info("Checking Resilio Sync...")
        result = self.ssh_cmd('command -v rslsync', check=False, capture=True)
        if result.returncode != 0:
            print_warning("Resilio Sync not installed, installing now...")
            self.ssh_script('''
                wget -qO - https://linux-packages.resilio.com/resilio-sync/key.asc | gpg --dearmor | sudo tee /usr/share/keyrings/resilio-sync-archive-keyring.gpg >/dev/null
                echo "deb [signed-by=/usr/share/keyrings/resilio-sync-archive-keyring.gpg] https://linux-packages.resilio.com/resilio-sync/deb resilio-sync non-free" | sudo tee /etc/apt/sources.list.d/resilio-sync.list
                sudo apt-get update
                sudo apt-get install -y resilio-sync
                sudo useradd -r -s /bin/false rslsync 2>/dev/null || true
            ''')
            self.cmd_resilio_sync(['setup'])
        else:
            self.ssh_cmd('sudo systemctl start resilio-sync', check=False)

        # Install logrotate config
        print_info("Installing logrotate configuration...")
        self.ssh_cmd(f'sudo cp {self.deploy_path}/config/logrotate-today /etc/logrotate.d/today && '
                    'sudo chmod 644 /etc/logrotate.d/today && echo "âœ“ Logrotate configured"')

        # Setup WAL checkpoint cron
        print_info("Setting up SQLite WAL checkpoint cron job...")
        self.ssh_script('''
            cat > /opt/today/bin/checkpoint-wal.sh << 'SCRIPT'
#!/bin/bash
cd /opt/today
npx dotenvx run -- sqlite3 .data/today.db "PRAGMA wal_checkpoint(PASSIVE);" >/dev/null 2>&1
SCRIPT
            chmod +x /opt/today/bin/checkpoint-wal.sh
            if ! crontab -l 2>/dev/null | grep -q checkpoint-wal; then
                (crontab -l 2>/dev/null; echo "*/30 * * * * /opt/today/bin/checkpoint-wal.sh") | crontab -
                echo "âœ“ WAL checkpoint cron job added (runs every 30 minutes)"
            else
                echo "âœ“ WAL checkpoint cron job already configured"
            fi
        ''')

        # Restart services
        print_info("Restarting services...")
        self.ssh_cmd('systemctl restart today-scheduler || true', check=False)
        self.ssh_cmd('systemctl restart vault-web || true', check=False)
        self.ssh_cmd('systemctl restart vault-watcher || true', check=False)

        print_status("Deployment complete!")

    def cmd_secrets(self, args):
        """Update secrets on droplet."""
        print("ðŸ” Updating secrets on droplet...")
        self.check_config()

        print_info("Copying .env file...")
        self.scp_to_remote('.env', f'{self.deploy_path}/.env')

        env_keys = Path('.env.keys')
        if env_keys.exists():
            print_info("Extracting and copying decryption key...")
            with open(env_keys) as f:
                for line in f:
                    if line.startswith('DOTENV_PRIVATE_KEY='):
                        private_key = line.strip().split('=', 1)[1]
                        self.ssh_cmd(f"echo 'DOTENV_PRIVATE_KEY={private_key}' > {self.deploy_path}/.env.keys")
                        break

        print_info("Setting proper permissions...")
        self.ssh_cmd(f'chmod 600 {self.deploy_path}/.env*')

        print_info("Restarting services...")
        self.ssh_cmd('systemctl restart today-scheduler || true', check=False)
        self.ssh_cmd('systemctl restart vault-watcher || true', check=False)

        print_status("Secrets updated!")

    def cmd_ssh(self, args):
        """SSH into droplet."""
        print("ðŸ”Œ Connecting to droplet...")
        self.check_config()
        os.execvp('ssh', ['ssh', '-i', str(self.ssh_key),
                         f'{self.droplet_user}@{self.droplet_ip}'])

    def cmd_logs(self, args):
        """Show scheduler logs."""
        print("ðŸ“Š Showing scheduler logs...")
        self.check_config()
        self.ssh_cmd('journalctl -u today-scheduler -f')

    def cmd_status(self, args):
        """Show scheduler status."""
        print("ðŸ“ˆ Checking status...")
        self.check_config()
        self.ssh_cmd('systemctl status today-scheduler')

    def cmd_nginx_config(self, args):
        """Update nginx configuration."""
        print("ðŸ”§ Updating nginx configuration...")
        self.check_config()

        print_info("Copying nginx config to droplet...")
        self.scp_to_remote('config/nginx-vault-web.conf', '/tmp/')

        print_info("Installing nginx config...")
        self.ssh_cmd(f'sudo cp /tmp/nginx-vault-web.conf /etc/nginx/sites-available/{self.deploy_domain}')

        print_info("Testing nginx configuration...")
        self.ssh_cmd('sudo nginx -t')

        print_info("Reloading nginx...")
        self.ssh_cmd('sudo systemctl reload nginx')

        print_status("Nginx configuration updated!")

    def cmd_restart(self, args):
        """Restart scheduler."""
        print("ðŸ”„ Restarting scheduler...")
        self.check_config()
        self.ssh_cmd('systemctl restart today-scheduler')
        print_status("Scheduler restarted")

    def cmd_web_restart(self, args):
        """Restart web server."""
        print("ðŸŒ Restarting web server...")
        self.check_config()
        self.ssh_cmd('systemctl restart vault-web')
        print_status("Web server restarted")

    def cmd_stop(self, args):
        """Stop scheduler."""
        print("â¹ Stopping scheduler...")
        self.check_config()
        self.ssh_cmd('systemctl stop today-scheduler')
        print_status("Scheduler stopped")

    def cmd_start(self, args):
        """Start scheduler."""
        print("â–¶ï¸ Starting scheduler...")
        self.check_config()
        self.ssh_cmd('systemctl start today-scheduler')
        print_status("Scheduler started")

    def cmd_db_init(self, args):
        """Initialize database."""
        print("ðŸ—„ï¸ Initializing database...")
        self.check_config()

        print_info("Creating .data directory...")
        self.ssh_cmd(f'mkdir -p {self.deploy_path}/.data')

        print_info("Running database migrations...")
        self.ssh_cmd(f'cd {self.deploy_path} && npx dotenvx run -- node src/migrations.js')

        print_status("Database initialized!")

    def cmd_git_setup(self, args):
        """Setup git repository on droplet."""
        print("ðŸ”§ Setting up git repository on droplet...")
        self.check_config()

        print_info("Copying .git directory to droplet...")
        self.rsync_to_remote('.git/', f'{self.deploy_path}/.git/', '--progress')

        print_info("Configuring git safe directory...")
        self.ssh_cmd(f'git config --global --add safe.directory {self.deploy_path}')

        print_info("Configuring git user identity...")
        self.ssh_cmd("git config --global user.email 'today-bot@system.local' && "
                    "git config --global user.name 'Today Bot'")

        print_info("Configuring GitHub authentication...")
        self.ssh_cmd(f'cd {self.deploy_path} && npx dotenvx run -- bash -c \''
                    'if [ -n "$GITHUB_TOKEN" ]; then '
                    'echo "https://$GITHUB_TOKEN:x-oauth-basic@github.com" > ~/.git-credentials && '
                    'git config --global credential.helper store && '
                    'echo "âœ“ GitHub token configured"; else echo "âš  No GITHUB_TOKEN found"; fi\'')

        print_info("Testing git access...")
        result = self.ssh_cmd(f'cd {self.deploy_path} && npx dotenvx run -- git fetch --dry-run',
                             check=False, capture=True)
        if result.returncode == 0:
            print_status("Git fetch successful!")
        else:
            print_warning("Git fetch failed - check GITHUB_TOKEN")

        print_info("Checking git status...")
        self.ssh_cmd(f'cd {self.deploy_path} && git status --short')

        print_status("Git repository configured!")

    def cmd_db_upload(self, args):
        """Upload local database to droplet."""
        print("ðŸ“¤ Uploading local database to droplet...")
        self.check_config()

        local_db = Path('.data/today.db')
        if not local_db.exists():
            print_error("Local database .data/today.db not found!")
            sys.exit(1)

        target_name = args[0] if args else 'today.db'
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')

        print_info("Backing up existing database on droplet...")
        self.ssh_cmd(f'cd {self.deploy_path} && [ -f .data/today.db ] && '
                    f'cp .data/today.db .data/today.db.backup-{timestamp} || true')

        # Get local size
        local_size = local_db.stat().st_size
        human_size = subprocess.run(['du', '-h', str(local_db)], capture_output=True, text=True).stdout.split()[0]

        print_info(f"Uploading database ({human_size}) using rsync...")
        self.rsync_to_remote(str(local_db), f'{self.deploy_path}/.data/{target_name}', '--progress')

        if target_name != 'today.db':
            print_info(f"Moving {target_name} to today.db...")
            self.ssh_cmd(f'cd {self.deploy_path}/.data && mv {target_name} today.db')

        print_info("Setting permissions...")
        self.ssh_cmd(f'chmod 644 {self.deploy_path}/.data/today.db')

        print_info("Verifying upload...")
        result = self.ssh_cmd(f'du -b {self.deploy_path}/.data/today.db', capture=True)
        remote_size = int(result.stdout.split()[0])

        if local_size != remote_size:
            print_warning(f"Size mismatch: local={local_size} remote={remote_size}")
        else:
            print_status(f"Database size verified: {human_size}")

        # Quick data check
        result = self.ssh_cmd(f"sqlite3 {self.deploy_path}/.data/today.db 'SELECT COUNT(*) FROM tasks'",
                             check=False, capture=True)
        task_count = result.stdout.strip() if result.returncode == 0 else '0'
        print_info(f"Database contains {task_count} tasks")

        print_status("Database uploaded successfully!")

    def cmd_vault_watcher_setup(self, args):
        """Setup vault watcher service."""
        print("ðŸ‘ï¸ Setting up vault watcher service...")
        self.check_config()

        print_info("Installing vault watcher service...")
        self.scp_to_remote('config/vault-watcher.service', '/tmp/vault-watcher.service')

        self.ssh_script('''
            sudo mv /tmp/vault-watcher.service /etc/systemd/system/
            sudo systemctl daemon-reload
            sudo systemctl enable vault-watcher
            sudo systemctl restart vault-watcher
            sleep 2
            sudo systemctl status vault-watcher
        ''')

        print_status("Vault watcher service installed and started")

    def cmd_vault_watcher(self, args):
        """Control vault watcher on droplet."""
        self.check_config()
        action = args[0] if args else 'status'
        print_info(f"Vault watcher: {action}")
        self.ssh_cmd(f'sudo systemctl {action} vault-watcher && sudo systemctl status vault-watcher --no-pager')

    def cmd_resilio_sync(self, args):
        """Manage Resilio Sync for vault synchronization."""
        self.check_config()
        action = args[0] if args else 'status'

        if action == 'setup':
            print_info("Setting up Resilio Sync...")

            # Build the setup script with proper variable substitution
            setup_script = f'''
                sudo useradd -r -s /bin/false rslsync 2>/dev/null || true
                sudo mkdir -p /etc/resilio-sync /var/lib/resilio-sync /var/run/resilio-sync /opt/today/vault
                sudo chown -R rslsync:rslsync /opt/today/vault
                sudo chmod -R 775 /opt/today/vault
                sudo chown rslsync:rslsync /var/lib/resilio-sync /var/run/resilio-sync

                if [ ! -f /etc/resilio-sync/config.json ]; then
                    RESILIO_PASSWORD=$(openssl rand -base64 12)
                    echo "RESILIO_PASSWORD=$RESILIO_PASSWORD" > /opt/today/.resilio-password
                    chmod 600 /opt/today/.resilio-password

                    sudo tee /etc/resilio-sync/config.json > /dev/null << 'CONFIG'
{{
    "device_name": "Today Droplet",
    "listening_port": 8888,
    "storage_path": "/var/lib/resilio-sync/",
    "pid_file": "/var/run/resilio-sync/sync.pid",
    "use_upnp": true,
    "download_limit": 0,
    "upload_limit": 0,
    "webui": {{
        "listen": "0.0.0.0:8889",
        "login": "admin",
        "password": "PLACEHOLDER"
    }}
}}
CONFIG
                    sudo sed -i "s/PLACEHOLDER/$RESILIO_PASSWORD/" /etc/resilio-sync/config.json
                    echo "Generated new password: $RESILIO_PASSWORD"
                    echo "(Saved to /opt/today/.resilio-password)"
                else
                    echo "Using existing Resilio Sync configuration"
                    if [ -f /opt/today/.resilio-password ]; then
                        source /opt/today/.resilio-password
                        echo "Current password: $RESILIO_PASSWORD"
                    fi
                fi

                sudo chown rslsync:rslsync /etc/resilio-sync/config.json
                sudo chmod 600 /etc/resilio-sync/config.json

                sudo tee /etc/systemd/system/resilio-sync.service > /dev/null << 'SERVICE'
[Unit]
Description=Resilio Sync
Documentation=https://help.resilio.com
After=network.target

[Service]
Type=simple
User=rslsync
Group=rslsync
RuntimeDirectory=resilio-sync
RuntimeDirectoryMode=0755
ExecStartPre=/bin/mkdir -p /var/run/resilio-sync
ExecStartPre=/bin/chown rslsync:rslsync /var/run/resilio-sync
ExecStart=/usr/bin/rslsync --config /etc/resilio-sync/config.json --nodaemon
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
SERVICE

                sudo systemctl daemon-reload
                sudo systemctl enable resilio-sync
                sudo systemctl restart resilio-sync
            '''
            self.ssh_script(setup_script)

            # Setup nginx for resilio sync
            nginx_config = f'''server {{
    server_name sync.{self.deploy_domain};

    location / {{
        proxy_pass http://127.0.0.1:8889;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 7d;
        proxy_send_timeout 7d;
        proxy_read_timeout 7d;
    }}

    listen 80;
}}'''

            nginx_setup = f'''
                if [ ! -f /etc/nginx/sites-available/sync.{self.deploy_domain} ]; then
                    cat > /tmp/sync-nginx.conf << 'NGINX'
{nginx_config}
NGINX
                    sudo mv /tmp/sync-nginx.conf /etc/nginx/sites-available/sync.{self.deploy_domain}
                    sudo ln -sf /etc/nginx/sites-available/sync.{self.deploy_domain} /etc/nginx/sites-enabled/
                    sudo nginx -t && sudo systemctl reload nginx
                    sudo certbot --nginx -d sync.{self.deploy_domain} --non-interactive --agree-tos --email {self.admin_email} --redirect || true
                    echo "âœ… Nginx subdomain configured with HTTPS"
                fi

                echo "âœ… Resilio Sync configured and started"
                echo "ðŸ“Œ Web UI available at:"
                echo "   ðŸ”’ HTTPS: https://sync.{self.deploy_domain}"
                echo "   Direct: http://$(hostname -I | awk '{{print $1}}'):8889"
                if [ -f /opt/today/.resilio-password ]; then
                    source /opt/today/.resilio-password
                    echo "   Username: admin"
                    echo "   Password: $RESILIO_PASSWORD"
                else
                    echo "   Username: admin"
                    echo "   Password: admin (default)"
                fi
                echo ""
                echo "Note: You may need to add sync.{self.deploy_domain} to your DNS records"
            '''
            self.ssh_script(nginx_setup)

        elif action in ['start', 'stop', 'restart', 'status']:
            print_info(f"Resilio Sync: {action}")
            self.ssh_cmd(f'sudo systemctl {action} resilio-sync && sudo systemctl status resilio-sync --no-pager')

        elif action == 'set-password':
            print_info("Setting new Resilio Sync password...")
            if len(args) > 1:
                new_password = args[1]
            else:
                print_info("Generating random password...")
                result = subprocess.run(['openssl', 'rand', '-base64', '16'], capture_output=True, text=True)
                new_password = result.stdout.strip()

            self.ssh_script(f'''
                sudo jq '.webui.password = "{new_password}"' /etc/resilio-sync/config.json > /tmp/config.json
                sudo mv /tmp/config.json /etc/resilio-sync/config.json
                sudo chown rslsync:rslsync /etc/resilio-sync/config.json
                sudo chmod 600 /etc/resilio-sync/config.json
                echo "RESILIO_PASSWORD={new_password}" > /opt/today/.resilio-password
                chmod 600 /opt/today/.resilio-password
                sudo systemctl restart resilio-sync
                echo "âœ… Password updated successfully!"
                echo ""
                echo "========================================="
                echo "New password: {new_password}"
                echo "========================================="
                echo ""
                echo "URL: https://sync.{self.deploy_domain}"
                echo "Username: admin"
                echo "Password: {new_password}"
            ''')

        elif action == 'fix-permissions':
            print_info("Fixing vault folder permissions...")
            self.ssh_script('''
                sudo chown -R rslsync:rslsync /opt/today/vault
                sudo chmod -R 775 /opt/today/vault
                echo "âœ… Permissions fixed for /opt/today/vault"
                ls -la /opt/today/vault | head -5
            ''')

        elif action in ['key', 'info']:
            print_info("Resilio Sync information...")
            self.ssh_script(f'''
                echo "ðŸ“Œ Web UI Access:"
                if [ -f /etc/nginx/sites-enabled/sync.{self.deploy_domain} ]; then
                    echo "   ðŸ”’ HTTPS: https://sync.{self.deploy_domain}"
                fi
                echo "   Direct: http://$(hostname -I | awk '{{print $1}}'):8889"

                if [ -f /opt/today/.resilio-password ]; then
                    source /opt/today/.resilio-password
                    echo ""
                    echo "Credentials:"
                    echo "   Username: admin"
                    echo "   Password: $RESILIO_PASSWORD"
                else
                    echo ""
                    echo "Credentials:"
                    echo "   Username: admin"
                    echo "   Password: admin (default)"
                fi
                echo ""
                echo "To get sync keys, visit the Web UI and check your folders"
            ''')

        else:
            print("Usage: bin/deploy-do resilio-sync [setup|start|stop|restart|status|set-password|fix-permissions|info]")
            print("")
            print("  set-password [password]  - Set new password (generates random if not provided)")
            print("  fix-permissions          - Fix vault folder permissions")
            print("  info                     - Show access info and current password")

    def cmd_inbox_api_setup(self, args):
        """Setup inbox upload API."""
        print("ðŸ“® Setting up inbox upload API...")
        self.check_config()

        print_info("Generating API key...")
        self.ssh_script('''
            if [ ! -f /opt/today/.inbox-api-key ]; then
                API_KEY=$(openssl rand -hex 32)
                echo "INBOX_API_KEY=$API_KEY" > /opt/today/.inbox-api-key
                chmod 600 /opt/today/.inbox-api-key
                echo "Generated new API key: $API_KEY"
            else
                source /opt/today/.inbox-api-key
                echo "Using existing API key: $INBOX_API_KEY"
            fi
        ''')

        self.scp_to_remote('config/inbox-api.service', '/tmp/inbox-api.service')

        self.ssh_script(f'''
            sudo mv /tmp/inbox-api.service /etc/systemd/system/
            sudo systemctl daemon-reload
            sudo systemctl enable inbox-api
            sudo systemctl restart inbox-api

            if ! grep -q "/api/inbox/" /etc/nginx/sites-available/default 2>/dev/null; then
                echo "Note: You may need to manually configure nginx for the inbox API"
            fi

            sleep 2
            sudo systemctl status inbox-api --no-pager || true

            echo ""
            echo "================================"
            source /opt/today/.inbox-api-key
            echo "Inbox API Key: $INBOX_API_KEY"
            echo "================================"
            echo ""
            echo "Save this API key in your Drafts app!"
            echo "Endpoint: https://{self.deploy_domain}/api/inbox/upload"
        ''')

        print_status("Inbox API installed and configured")

    def cmd_inbox_api(self, args):
        """Control inbox API on droplet."""
        self.check_config()
        action = args[0] if args else 'status'
        print_info(f"Inbox API: {action}")
        self.ssh_cmd(f'sudo systemctl {action} inbox-api && sudo systemctl status inbox-api --no-pager')

        if action in ['status', 'restart']:
            self.ssh_script(f'''
                if [ -f /opt/today/.inbox-api-key ]; then
                    echo ""
                    source /opt/today/.inbox-api-key
                    echo "API Key: $INBOX_API_KEY"
                    echo "Upload endpoint: https://{self.deploy_domain}/api/inbox/upload"
                    echo "Vault endpoint: https://{self.deploy_domain}/api/vault/"
                fi
            ''')

    def cmd_vault_api_setup(self, args):
        """Setup vault read API."""
        print("ðŸ“š Setting up vault read API...")
        self.check_config()

        print_info("Installing vault API service...")
        self.scp_to_remote('config/vault-api.service', '/tmp/vault-api.service')

        self.ssh_script(f'''
            sudo mv /tmp/vault-api.service /etc/systemd/system/
            sudo systemctl daemon-reload
            sudo systemctl enable vault-api
            sudo systemctl restart vault-api
            sleep 2
            sudo systemctl status vault-api --no-pager || true
        ''')

        print_status("Vault API installed and configured")
        print_info(f"Vault API endpoint: https://{self.deploy_domain}/api/vault/")

    def cmd_vault_api(self, args):
        """Control vault API on droplet."""
        self.check_config()
        action = args[0] if args else 'status'
        print_info(f"Vault API: {action}")
        self.ssh_cmd(f'sudo systemctl {action} vault-api && sudo systemctl status vault-api --no-pager')

    def cmd_ollama_setup(self, args):
        """Setup Ollama on droplet."""
        print("ðŸ¤– Setting up Ollama on droplet...")
        self.check_config()

        print_info("Installing Ollama...")
        self.ssh_cmd('curl -fsSL https://ollama.com/install.sh | sh')

        print_info("Starting Ollama service...")
        self.ssh_cmd('systemctl enable ollama && systemctl start ollama')

        print_info("Waiting for Ollama to start...")
        import time
        time.sleep(5)

        print_info("Testing Ollama installation...")
        self.ssh_cmd('ollama --version')

        print_info("Checking available memory...")
        result = self.ssh_cmd("free -m | awk '/^Mem:/ {print $7}'", capture=True)
        available_mb = int(result.stdout.strip())

        if available_mb < 800:
            print_warning(f"Only {available_mb}MB RAM available. LLMs need at least 800MB.")
            print_warning("Consider upgrading to a 2GB droplet ($12/month) for local LLM support.")
            print_info("Skipping model download due to insufficient memory.")
        else:
            print_info("Pulling tinyllama model (637MB) - fastest small model...")
            self.ssh_cmd('ollama pull tinyllama')

            print_info("Testing model...")
            self.ssh_cmd("echo 'What is 2+2?' | ollama run tinyllama")

        print_status("Ollama setup complete!")
        print_info("Available at http://localhost:11434 on the droplet")
        print_info("Add OLLAMA_HOST=http://localhost:11434 to your .env")

    def cmd_ollama(self, args):
        """Manage Ollama models."""
        print("ðŸ¤– Managing Ollama models...")
        self.check_config()

        action = args[0] if args else 'list'

        if action == 'list':
            print_info("Installed models:")
            self.ssh_cmd('ollama list')

        elif action == 'pull':
            if len(args) < 2:
                print_error("Usage: bin/deploy-do ollama pull <model>")
                print("Recommended models (memory requirements):")
                print("  â€¢ tinyllama (800MB RAM) - Very fast, basic quality")
                print("  â€¢ phi3 (4GB RAM) - Good balance of speed and quality")
                print("  â€¢ mistral (6GB RAM) - Better quality")
                print("  â€¢ codellama (5GB RAM) - For coding tasks")
                sys.exit(1)
            print_info(f"Pulling model: {args[1]}")
            self.ssh_cmd(f'ollama pull {args[1]}')

        elif action == 'rm':
            if len(args) < 2:
                print_error("Usage: bin/deploy-do ollama rm <model>")
                sys.exit(1)
            print_info(f"Removing model: {args[1]}")
            self.ssh_cmd(f'ollama rm {args[1]}')

        elif action == 'test':
            model = args[1] if len(args) > 1 else 'phi3-mini'
            print_info(f"Testing model: {model}")
            self.ssh_cmd(f"echo 'Hello, how are you?' | ollama run {model}")

        else:
            print("Usage: bin/deploy-do ollama [list|pull <model>|rm <model>|test [model]]")

    def cmd_exec(self, args):
        """Execute command in deploy directory."""
        if not args:
            print_error("Usage: bin/deploy-do exec 'command'")
            sys.exit(1)
        self.check_config()
        command = ' '.join(args)
        print(f"âš¡ Executing: {command}")
        self.ssh_cmd(f'cd {self.deploy_path} && {command}')

    def cmd_fetch(self, args):
        """Fetch authenticated web pages from the site."""
        if not args:
            print_error("Usage: bin/deploy-do fetch <path> [options]")
            print("")
            print("Examples:")
            print("  bin/deploy-do fetch /                    # Fetch homepage")
            print("  bin/deploy-do fetch /tasks-today.md      # Fetch today's tasks")
            print("  bin/deploy-do fetch /plans/              # List plans directory")
            print("  bin/deploy-do fetch /api/health          # Check API health")
            print("")
            print("Options:")
            print("  --raw           Output raw HTML/content without processing")
            print("  --headers       Include response headers")
            print("  --no-auth       Skip authentication (for public endpoints)")
            print("  --output FILE   Save response to file")
            sys.exit(1)

        self.check_config()

        url_path = args[0]
        raw_output = '--raw' in args
        show_headers = '--headers' in args
        skip_auth = '--no-auth' in args
        output_file = None

        if '--output' in args:
            idx = args.index('--output')
            if idx + 1 < len(args):
                output_file = args[idx + 1]

        curl_opts = '-i' if show_headers else ''

        print_info(f"Fetching: {url_path}")
        full_url = f"https://{self.deploy_domain}{url_path}"

        if not skip_auth:
            print_info("Authenticating...")

            # Get password from dotenvx
            result = subprocess.run(['npx', 'dotenvx', 'get', 'WEB_PASSWORD', '--format', 'shell'],
                                   capture_output=True, text=True)
            web_password = result.stdout.strip()
            if not web_password:
                print_error("Failed to decrypt WEB_PASSWORD. Ensure .env.keys exists.")
                sys.exit(1)

            # Create temp cookie file
            import tempfile
            cookie_file = f'/tmp/deploy-do-cookies-{os.getpid()}'

            # Authenticate
            auth_result = self.ssh_cmd(
                f"curl -s -c {cookie_file} -X POST -d 'username=admin' "
                f"--data-urlencode 'password={web_password}' "
                f"https://{self.deploy_domain}/auth/login -o /dev/null -w '%{{http_code}}'",
                capture=True
            )
            auth_status = auth_result.stdout.strip()

            if auth_status not in ['200', '302']:
                print_error(f"Authentication failed (HTTP {auth_status})")
                self.ssh_cmd(f'rm -f {cookie_file}', check=False)
                sys.exit(1)

            print_status("Authenticated successfully")

            # Fetch with auth
            if output_file:
                result = self.ssh_cmd(f"curl -s -b {cookie_file} {curl_opts} '{full_url}'", capture=True)
                with open(output_file, 'w') as f:
                    f.write(result.stdout)
                print_status(f"Saved to: {output_file}")
            elif raw_output:
                self.ssh_cmd(f"curl -s -b {cookie_file} {curl_opts} '{full_url}'")
            else:
                self.ssh_cmd(f"curl -s -b {cookie_file} {curl_opts} '{full_url}' | "
                           "sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g' | sed 's/&lt;/</g' | "
                           "sed 's/&gt;/>/g' | sed 's/&amp;/\\&/g'")

            # Cleanup
            self.ssh_cmd(f'rm -f {cookie_file}', check=False)
        else:
            # No auth needed
            if output_file:
                result = self.ssh_cmd(f"curl -s {curl_opts} '{full_url}'", capture=True)
                with open(output_file, 'w') as f:
                    f.write(result.stdout)
                print_status(f"Saved to: {output_file}")
            elif raw_output:
                self.ssh_cmd(f"curl -s {curl_opts} '{full_url}'")
            else:
                self.ssh_cmd(f"curl -s {curl_opts} '{full_url}' | "
                           "sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g'")

    def show_help(self):
        """Show usage help."""
        print("Usage: bin/deploy-do [command]")
        print("")
        print("Commands:")
        print("  setup       - Initial droplet setup (run once)")
        print("  deploy      - Deploy code to droplet (default, includes .git)")
        print("  secrets     - Update .env files")
        print("  db-init     - Initialize database")
        print("  db-upload   - Upload local database to droplet")
        print("  git-setup   - Manually setup git repository")
        print("  vault-watcher-setup - Setup vault file watcher service")
        print("  vault-watcher - Control vault watcher (start|stop|restart|status)")
        print("  resilio-sync - Manage Resilio Sync (setup|start|stop|restart|status|key)")
        print("  inbox-api-setup - Setup inbox upload API for Drafts")
        print("  inbox-api   - Control inbox API (start|stop|restart|status)")
        print("  vault-api-setup - Setup vault read API for Drafts sync")
        print("  vault-api   - Control vault API (start|stop|restart|status)")
        print("  ollama-setup - Install and setup Ollama with phi3-mini model")
        print("  ollama      - Manage Ollama models (list|pull|rm|test)")
        print("  nginx-config - Update nginx configuration")
        print("  ssh         - SSH into droplet")
        print("  logs        - Show scheduler logs")
        print("  status      - Show scheduler status")
        print("  restart     - Restart scheduler")
        print("  web-restart - Restart web server")
        print("  stop        - Stop scheduler")
        print("  start       - Start scheduler")
        print("  exec CMD    - Execute command in deploy directory")
        print("  fetch PATH  - Fetch authenticated web pages from the site")
        print("")
        print("First time setup:")
        print("  1. Create a DigitalOcean droplet (Ubuntu 24.04)")
        print("  2. Add DO_DROPLET_IP to .env and encrypt with dotenvx")
        print("  3. bin/deploy-do setup       # Install dependencies on droplet")
        print("  4. bin/deploy-do secrets     # Copy encrypted secrets")
        print("  5. bin/deploy-do deploy      # Deploy code (includes .git)")
        print("  6. bin/deploy-do db-upload   # Upload your local database")
        print("  7. bin/deploy-do ollama-setup # Install Ollama with phi3-mini model")
        print("")
        print("Note: deploy now includes .git for sync operations")


def main():
    # Load environment from dotenvx if not already loaded
    if not os.environ.get('DOTENVX_INJECTED'):
        os.environ['DOTENVX_INJECTED'] = '1'
        os.chdir(PROJECT_ROOT)
        os.execvp('npx', ['npx', 'dotenvx', 'run', '--', sys.executable] + sys.argv)

    deployer = DigitalOceanDeploy()

    # Parse command
    args = sys.argv[1:]
    command = args[0] if args else 'deploy'
    command_args = args[1:] if len(args) > 1 else []

    # Map commands to methods
    commands = {
        'setup': deployer.cmd_setup,
        'deploy': deployer.cmd_deploy,
        'secrets': deployer.cmd_secrets,
        'ssh': deployer.cmd_ssh,
        'logs': deployer.cmd_logs,
        'status': deployer.cmd_status,
        'nginx-config': deployer.cmd_nginx_config,
        'restart': deployer.cmd_restart,
        'web-restart': deployer.cmd_web_restart,
        'stop': deployer.cmd_stop,
        'start': deployer.cmd_start,
        'db-init': deployer.cmd_db_init,
        'git-setup': deployer.cmd_git_setup,
        'db-upload': deployer.cmd_db_upload,
        'vault-watcher-setup': deployer.cmd_vault_watcher_setup,
        'vault-watcher': deployer.cmd_vault_watcher,
        'resilio-sync': deployer.cmd_resilio_sync,
        'inbox-api-setup': deployer.cmd_inbox_api_setup,
        'inbox-api': deployer.cmd_inbox_api,
        'vault-api-setup': deployer.cmd_vault_api_setup,
        'vault-api': deployer.cmd_vault_api,
        'ollama-setup': deployer.cmd_ollama_setup,
        'ollama': deployer.cmd_ollama,
        'exec': deployer.cmd_exec,
        'fetch': deployer.cmd_fetch,
        'help': lambda _: deployer.show_help(),
        '--help': lambda _: deployer.show_help(),
        '-h': lambda _: deployer.show_help(),
    }

    if command in commands:
        commands[command](command_args)
    else:
        print_error(f"Unknown command: {command}")
        deployer.show_help()
        sys.exit(1)


if __name__ == '__main__':
    main()
