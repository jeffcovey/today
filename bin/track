#!/usr/bin/env node

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.dirname(__dirname);
const TIME_DIR = path.join(PROJECT_ROOT, 'vault/logs/time-tracking');
const STATE_FILE = path.join(TIME_DIR, '.current-timer');

// Ensure time tracking directory exists
if (!fs.existsSync(TIME_DIR)) {
  fs.mkdirSync(TIME_DIR, { recursive: true });
}

// Get timezone from config
function getTimezone() {
  try {
    const result = execSync('bin/get-config timezone', { encoding: 'utf8' }).trim();
    return result || 'America/New_York';
  } catch {
    return 'America/New_York';
  }
}

const TIMEZONE = getTimezone();

// Get current time in configured timezone
function getCurrentTime() {
  const cmd = `TZ="${TIMEZONE}" date '+%Y-%m-%dT%H:%M:%S%z'`;
  const timestamp = execSync(cmd, { encoding: 'utf8' }).trim();
  // Add colon in timezone offset (e.g., -0400 -> -04:00)
  return timestamp.replace(/([+-]\d{2})(\d{2})$/, '$1:$2');
}

// Get current month file path
function getMonthFile() {
  const yearMonth = execSync(`TZ="${TIMEZONE}" date '+%Y-%m'`, { encoding: 'utf8' }).trim();
  return path.join(TIME_DIR, `${yearMonth}.md`);
}

// Format duration in seconds to human readable
function formatDuration(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);

  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}

// Calculate duration in minutes between two timestamps
function calculateDuration(start, end) {
  try {
    const startEpoch = new Date(start).getTime() / 1000;
    const endEpoch = new Date(end).getTime() / 1000;
    return Math.floor((endEpoch - startEpoch) / 60);
  } catch {
    return 0;
  }
}

// Parse natural language duration to minutes
function parseDuration(input) {
  input = input.toLowerCase().replace(/\s+/g, '');

  // Decimal hours (e.g., "1.5h", "0.5hours")
  const decimalHours = input.match(/^(\d+\.?\d*)h(ours?)?$/);
  if (decimalHours) {
    return Math.floor(parseFloat(decimalHours[1]) * 60);
  }

  // Hours + minutes (e.g., "2h30m", "1h15m")
  const hoursMinutes = input.match(/(\d+)h(ours?)?(\d+)m(inutes?|ins?)?/);
  if (hoursMinutes) {
    return parseInt(hoursMinutes[1]) * 60 + parseInt(hoursMinutes[3]);
  }

  // Just hours (e.g., "2h", "2hours")
  const justHours = input.match(/^(\d+)h(ours?)?$/);
  if (justHours) {
    return parseInt(justHours[1]) * 60;
  }

  // Just minutes (e.g., "20m", "35minutes")
  const justMinutes = input.match(/^(\d+)m(inutes?|ins?)?$/);
  if (justMinutes) {
    return parseInt(justMinutes[1]);
  }

  return 0;
}

// Start tracking
async function cmdStart(description) {
  if (!description) {
    console.error(chalk.red('âœ—') + ' Usage: track start "Description with #topic/tags"');
    console.log('');
    console.log('Examples:');
    console.log('  track start "Fixing image distortion #topic/ogm"');
    console.log('  track start "Duolingo practice #topic/languages"');
    console.log('  track start "Hip mobility workout #topic/fitness"');
    process.exit(1);
  }

  // Check for running timer
  if (fs.existsSync(STATE_FILE)) {
    const line = fs.readFileSync(STATE_FILE, 'utf8').trim();
    const [oldStart, oldDescription] = line.split('|');

    const currentTime = getCurrentTime();
    const duration = calculateDuration(oldStart, currentTime);
    const durationFormatted = formatDuration(duration * 60);

    console.log(chalk.yellow('âš ') + ` Stopping previous timer: ${oldDescription} (${durationFormatted})`);
    await stopTimer(oldStart, oldDescription, currentTime);
  }

  // Start new timer
  const startTime = getCurrentTime();
  fs.writeFileSync(STATE_FILE, `${startTime}|${description}`);

  console.log(chalk.green('âœ“') + ` Started: ${description}`);
  console.log(chalk.blue('â„¹') + ` Timezone: ${TIMEZONE}`);
}

// Stop timer and write to file
async function stopTimer(start, description, end = null) {
  if (!end) {
    end = getCurrentTime();
  }

  const duration = calculateDuration(start, end);
  const monthFile = getMonthFile();

  // Write completed entry
  const entry = `${start}|${end}|${description}\n`;
  fs.appendFileSync(monthFile, entry);

  // Remove state file
  if (fs.existsSync(STATE_FILE)) {
    fs.unlinkSync(STATE_FILE);
  }

  const durationFormatted = formatDuration(duration * 60);
  console.log(chalk.green('âœ“') + ` Stopped: ${description} (${durationFormatted})`);
}

// Stop command
async function cmdStop() {
  if (!fs.existsSync(STATE_FILE)) {
    console.error(chalk.red('âœ—') + ' No timer running');
    process.exit(1);
  }

  const line = fs.readFileSync(STATE_FILE, 'utf8').trim();
  const [start, description] = line.split('|');

  await stopTimer(start, description);
}

// Add command - add a completed entry
async function cmdAdd(durationStr, ...descriptionParts) {
  const description = descriptionParts.join(' ');

  if (!durationStr || !description) {
    console.error(chalk.red('âœ—') + ' Usage: track add DURATION "Description with #topic/tags"');
    console.log('');
    console.log('Examples:');
    console.log('  track add 20m "Reviewing pull requests #topic/ogm_site_development"');
    console.log('  track add 2h "Deep work session #topic/programming"');
    console.log('  track add 1.5h "Language practice #topic/languages"');
    console.log('  track add 2h30m "Project planning #topic/personal_admin"');
    console.log('');
    console.log('Supported duration formats:');
    console.log('  20m, 35 minutes, 2h, 2 hours, 1.5h, 2h30m');
    process.exit(1);
  }

  const durationMinutes = parseDuration(durationStr);

  if (durationMinutes === 0) {
    console.error(chalk.red('âœ—') + ` Could not parse duration: ${durationStr}`);
    console.log('');
    console.log('Supported formats: 20m, 35 minutes, 2h, 2 hours, 1.5h, 2h30m');
    process.exit(1);
  }

  const endTime = getCurrentTime();
  const durationSeconds = durationMinutes * 60;

  // Calculate start time
  let startTime;
  try {
    startTime = execSync(`TZ="${TIMEZONE}" date -d "${durationSeconds} seconds ago" '+%Y-%m-%dT%H:%M:%S%z'`,
      { encoding: 'utf8' }).trim();
    startTime = startTime.replace(/([+-]\d{2})(\d{2})$/, '$1:$2');
  } catch {
    // Try macOS format
    try {
      startTime = execSync(`TZ="${TIMEZONE}" date -v-${durationSeconds}S '+%Y-%m-%dT%H:%M:%S%z'`,
        { encoding: 'utf8' }).trim();
      startTime = startTime.replace(/([+-]\d{2})(\d{2})$/, '$1:$2');
    } catch {
      console.error(chalk.red('âœ—') + ' Could not calculate start time');
      process.exit(1);
    }
  }

  const monthFile = getMonthFile();
  const entry = `${startTime}|${endTime}|${description}\n`;
  fs.appendFileSync(monthFile, entry);

  const durationFormatted = formatDuration(durationMinutes * 60);
  console.log(chalk.green('âœ“') + ` Added: ${description} (${durationFormatted})`);

  try {
    const startDisplay = new Date(startTime).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZone: TIMEZONE
    });
    const endDisplay = new Date(endTime).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZone: TIMEZONE
    });
    console.log(chalk.blue('â„¹') + ` Time range: ${startDisplay} - ${endDisplay}`);
  } catch {
    // Ignore time display errors
  }
}

// Add topics command
async function cmdAddTopics() {
  console.log(chalk.blue('ðŸ·ï¸  Adding topic tags to time tracking entries...'));

  // Check if AI is available
  const useAI = (() => {
    try {
      execSync('which claude', { encoding: 'utf8' });
      return true;
    } catch {
      console.log(chalk.yellow('âš ï¸  Claude CLI not available - skipping auto-tagging'));
      return false;
    }
  })();

  if (!useAI) {
    process.exit(0);
  }

  // Extract available topics from existing time tracking entries
  console.log(chalk.gray('  Extracting available topics from time tracking files...'));
  const topicSet = new Set();

  const files = fs.readdirSync(TIME_DIR)
    .filter(f => f.match(/^\d{4}-\d{2}\.md$/))
    .map(f => path.join(TIME_DIR, f));

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      const topicMatches = line.match(/#topic\/[a-z_]+/g);
      if (topicMatches) {
        for (const match of topicMatches) {
          topicSet.add(match.replace('#topic/', ''));
        }
      }
    }
  }

  const availableTopics = Array.from(topicSet).sort();
  console.log(chalk.gray(`  Found ${availableTopics.length} unique topics`));

  // Find entries without topics
  const entriesToTag = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line && !line.startsWith('#') && line.includes('|')) {
        const [start, end, description] = line.split('|');
        if (start && description && !description.match(/#topic\//)) {
          entriesToTag.push({
            file,
            lineIndex: i,
            line,
            description: description.trim()
          });
        }
      }
    }
  }

  if (entriesToTag.length === 0) {
    console.log(chalk.gray('No entries needing topic tags found'));
    process.exit(0);
  }

  console.log(chalk.gray(`  Found ${entriesToTag.length} entries needing topics`));

  // Process in batches
  const BATCH_SIZE = 30;
  let totalTagged = 0;

  for (let i = 0; i < entriesToTag.length; i += BATCH_SIZE) {
    const batch = entriesToTag.slice(i, Math.min(i + BATCH_SIZE, entriesToTag.length));

    const prompt = `Analyze these time tracking entries and suggest 1 relevant topic for each from the available list.

Available topics: ${availableTopics.join(', ')}

For each entry, choose the most relevant topic based on the activity description.

Respond with a JSON array where each has:
{"index": entry_index, "topic": "topic_name"}

If no topics clearly apply, use an empty string for topic.
Only use topics from the available list.

Entries:
${JSON.stringify(batch.map((e, idx) => ({index: idx + i, description: e.description})), null, 2)}`;

    try {
      const result = execSync(`claude --print '${prompt.replace(/'/g, "'\\''")}'`, {
        encoding: 'utf8',
        maxBuffer: 1024 * 1024 * 10,
        timeout: 60000
      });

      const jsonMatch = result.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const classifications = JSON.parse(jsonMatch[0]);

        // Group updates by file
        const fileUpdates = new Map();

        for (const cls of classifications) {
          const entry = batch[cls.index - i];
          if (cls.topic && availableTopics.includes(cls.topic)) {
            const [start, end, description] = entry.line.split('|');
            const newLine = `${start}|${end}|${description.trim()} #topic/${cls.topic}`;

            if (!fileUpdates.has(entry.file)) {
              const content = fs.readFileSync(entry.file, 'utf8');
              fileUpdates.set(entry.file, {
                lines: content.split('\n'),
                modified: false
              });
            }

            const fileData = fileUpdates.get(entry.file);
            fileData.lines[entry.lineIndex] = newLine;
            fileData.modified = true;
            totalTagged++;
          }
        }

        // Write updated files
        for (const [file, data] of fileUpdates) {
          if (data.modified) {
            fs.writeFileSync(file, data.lines.join('\n'));
          }
        }
      }
    } catch (error) {
      console.error(chalk.yellow(`  Failed to process batch: ${error.message}`));
    }
  }

  console.log(chalk.green(`âœ“ Added topic tags to ${totalTagged} entry(ies)`));
}

// Status command
async function cmdStatus() {
  if (!fs.existsSync(STATE_FILE)) {
    console.log(chalk.blue('â„¹') + ' No timer running');
    return;
  }

  const line = fs.readFileSync(STATE_FILE, 'utf8').trim();
  const [start, description] = line.split('|');

  const currentTime = getCurrentTime();
  const duration = calculateDuration(start, currentTime);
  const durationFormatted = formatDuration(duration * 60);

  console.log(chalk.cyan('â±') + '  Currently tracking:');
  console.log('');
  console.log('  ' + chalk.green(description));

  try {
    const startDisplay = new Date(start).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZone: TIMEZONE
    });
    console.log(`  Started: ${startDisplay}`);
  } catch {
    console.log(`  Started: ${start}`);
  }

  console.log(`  Duration: ${durationFormatted}`);
}

// Today command
async function cmdToday() {
  const monthFile = getMonthFile();
  const today = execSync(`TZ="${TIMEZONE}" date '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();

  if (!fs.existsSync(monthFile)) {
    console.log(chalk.blue('â„¹') + ' No time entries for today');
    return;
  }

  console.log(chalk.cyan("Today's Time Tracking") + ` (${today})`);
  console.log('');

  const content = fs.readFileSync(monthFile, 'utf8');
  const lines = content.split('\n').filter(line => line.startsWith(today));

  if (lines.length === 0) {
    console.log(chalk.blue('â„¹') + ' No time entries for today');
    return;
  }

  let totalMinutes = 0;
  const topicMinutes = {};

  for (const line of lines) {
    const [start, end, description] = line.split('|');
    if (!description) continue;

    const topics = (description.match(/#topic\/[a-z_]+/g) || ['(untagged)']).join(' ');

    let duration;
    if (end === 'RUNNING') {
      const currentTime = getCurrentTime();
      duration = calculateDuration(start, currentTime);
    } else {
      duration = calculateDuration(start, end);
    }

    totalMinutes += duration;
    topicMinutes[topics] = (topicMinutes[topics] || 0) + duration;

    // Display entry
    try {
      const startTime = new Date(start).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: TIMEZONE
      });
      const endTime = end === 'RUNNING' ? 'now' : new Date(end).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: TIMEZONE
      });

      const symbol = end === 'RUNNING' ? chalk.yellow('â—') : chalk.green('âœ“');
      console.log(`  ${symbol} ${startTime} - ${endTime} (${formatDuration(duration * 60)})`);
      console.log(`    ${description}`);
    } catch {
      console.log(`  ${start} - ${end} (${formatDuration(duration * 60)})`);
      console.log(`    ${description}`);
    }
  }

  // Summary by topic
  if (Object.keys(topicMinutes).length > 0) {
    console.log('');
    console.log(chalk.cyan('By Topic:'));
    const sorted = Object.entries(topicMinutes).sort((a, b) => b[1] - a[1]);
    for (const [topic, mins] of sorted) {
      console.log(`  ${topic}: ${formatDuration(mins * 60)}`);
    }
  }

  console.log('');
  console.log(chalk.cyan('Total:') + ` ${formatDuration(totalMinutes * 60)}`);
}

// Week command
async function cmdWeek() {
  // Calculate week start (7 days ago)
  let weekStart;
  try {
    weekStart = execSync(`TZ="${TIMEZONE}" date -d '7 days ago' '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();
  } catch {
    try {
      weekStart = execSync(`TZ="${TIMEZONE}" date -v-7d '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();
    } catch {
      console.error(chalk.red('âœ—') + ' Could not calculate week start');
      process.exit(1);
    }
  }

  const today = execSync(`TZ="${TIMEZONE}" date '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();

  console.log(chalk.cyan("This Week's Time Tracking") + ` (${weekStart} to ${today})`);
  console.log('');

  // Get current and previous month files
  const currentMonth = execSync(`TZ="${TIMEZONE}" date '+%Y-%m'`, { encoding: 'utf8' }).trim();
  let prevMonth;
  try {
    prevMonth = execSync(`TZ="${TIMEZONE}" date -d '1 month ago' '+%Y-%m'`, { encoding: 'utf8' }).trim();
  } catch {
    try {
      prevMonth = execSync(`TZ="${TIMEZONE}" date -v-1m '+%Y-%m'`, { encoding: 'utf8' }).trim();
    } catch {
      prevMonth = currentMonth;
    }
  }

  const monthFiles = [
    path.join(TIME_DIR, `${prevMonth}.md`),
    path.join(TIME_DIR, `${currentMonth}.md`)
  ];

  let totalMinutes = 0;
  const topicMinutes = {};
  const dayMinutes = {};

  for (const monthFile of monthFiles) {
    if (!fs.existsSync(monthFile)) continue;

    const content = fs.readFileSync(monthFile, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      if (!line || line.startsWith('#')) continue;

      const [start, end, description] = line.split('|');
      if (!start || !description) continue;

      const entryDate = start.substring(0, 10);

      // Check if entry is within the week
      if (entryDate < weekStart || entryDate > today) continue;

      const topics = (description.match(/#topic\/[a-z_]+/g) || ['(untagged)']).join(' ');

      let duration;
      if (end === 'RUNNING') {
        const currentTime = getCurrentTime();
        duration = calculateDuration(start, currentTime);
      } else {
        duration = calculateDuration(start, end);
      }

      totalMinutes += duration;
      topicMinutes[topics] = (topicMinutes[topics] || 0) + duration;
      dayMinutes[entryDate] = (dayMinutes[entryDate] || 0) + duration;
    }
  }

  if (totalMinutes === 0) {
    console.log(chalk.blue('â„¹') + ' No time entries for this week');
    return;
  }

  // Summary by day
  console.log(chalk.cyan('By Day:'));
  const sortedDays = Object.entries(dayMinutes).sort((a, b) => a[0].localeCompare(b[0]));
  for (const [day, mins] of sortedDays) {
    console.log(`  ${day}: ${formatDuration(mins * 60)}`);
  }

  // Summary by topic
  console.log('');
  console.log(chalk.cyan('By Topic:'));
  const sortedTopics = Object.entries(topicMinutes).sort((a, b) => b[1] - a[1]);
  for (const [topic, mins] of sortedTopics) {
    console.log(`  ${topic}: ${formatDuration(mins * 60)}`);
  }

  console.log('');
  console.log(chalk.cyan('Total:') + ` ${formatDuration(totalMinutes * 60)}`);
}

// Sync-db command
async function cmdSyncDb() {
  const DB_PATH = path.join(PROJECT_ROOT, '.data/today.db');
  const SYNC_STATE_FILE = path.join(TIME_DIR, '.last-sync');

  console.log(chalk.blue('â„¹') + ' Syncing time tracking files to database (last 365 days)...');

  // Calculate date 365 days ago
  let cutoffDate;
  try {
    cutoffDate = execSync(`TZ="${TIMEZONE}" date -d '365 days ago' '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();
  } catch {
    try {
      cutoffDate = execSync(`TZ="${TIMEZONE}" date -v-365d '+%Y-%m-%d'`, { encoding: 'utf8' }).trim();
    } catch {
      console.error(chalk.red('âœ—') + ' Could not calculate cutoff date');
      process.exit(1);
    }
  }

  const cutoffYearMonth = cutoffDate.substring(0, 7); // YYYY-MM format

  // Get last sync timestamp
  let lastSync = 0;
  if (fs.existsSync(SYNC_STATE_FILE)) {
    lastSync = parseInt(fs.readFileSync(SYNC_STATE_FILE, 'utf8').trim());
    const lastSyncDate = new Date(lastSync * 1000).toLocaleString();
    console.log(chalk.blue('â„¹') + ` Last sync: ${lastSyncDate}`);
  }

  // Process all markdown files
  let entryCount = 0;
  let filesProcessed = 0;
  let filesSkipped = 0;

  const files = fs.readdirSync(TIME_DIR)
    .filter(f => f.match(/^\d{4}-\d{2}\.md$/))
    .map(f => path.join(TIME_DIR, f));

  for (const file of files) {
    const fileYearMonth = path.basename(file, '.md');

    // Skip files older than 365 days
    if (fileYearMonth < cutoffYearMonth) continue;

    // Check if file modified since last sync
    const stats = fs.statSync(file);
    const fileMtime = Math.floor(stats.mtimeMs / 1000);

    if (lastSync > 0 && fileMtime <= lastSync) {
      filesSkipped++;
      continue;
    }

    filesProcessed++;

    const content = fs.readFileSync(file, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      if (!line || line.startsWith('#')) continue;

      const [start, end, description] = line.split('|');
      if (!start || !description) continue;

      const topics = (description.match(/#topic\/[a-z_]+/g) || ['(untagged)']).join(' ');

      let duration = 0;
      let endValue = 'NULL';

      if (end && end !== 'RUNNING') {
        duration = calculateDuration(start, end);
        endValue = `'${end}'`;
      }

      // Escape single quotes for SQL
      const escapedTopics = topics.replace(/'/g, "''");
      const escapedDescription = description.replace(/'/g, "''");
      const escapedProject = escapedTopics;

      // Insert or replace entry
      const sql = `INSERT OR REPLACE INTO time_entries (start_time, end_time, duration_minutes, project, topics, description, source) VALUES ('${start}', ${endValue}, ${duration}, '${escapedProject}', '${escapedTopics}', '${escapedDescription}', 'markdown');`;

      try {
        execSync(`sqlite3 "${DB_PATH}" "${sql}"`, { encoding: 'utf8' });
        entryCount++;
      } catch (error) {
        console.error(chalk.red('âœ—') + ` Error syncing entry: ${error.message}`);
      }
    }
  }

  // Save current sync timestamp
  fs.writeFileSync(SYNC_STATE_FILE, Math.floor(Date.now() / 1000).toString());

  if (filesSkipped > 0) {
    console.log(chalk.green('âœ“') + ` Synced ${entryCount} entries from ${filesProcessed} file(s) (skipped ${filesSkipped} unchanged file(s))`);
  } else {
    console.log(chalk.green('âœ“') + ` Synced ${entryCount} entries from ${filesProcessed} file(s)`);
  }

  // Show summary
  console.log(chalk.blue('â„¹') + ' Recent entries:');
  const summaryQuery = `SELECT DATE(start_time) as Date, topics as Topics, printf('%.1f', SUM(duration_minutes) / 60.0) as Hours, COUNT(*) as Entries FROM time_entries WHERE DATE(start_time) >= DATE('now', '-7 days', 'localtime') GROUP BY DATE(start_time), topics ORDER BY DATE(start_time) DESC, Hours DESC LIMIT 20;`;

  try {
    const output = execSync(`sqlite3 -column -header "${DB_PATH}" "${summaryQuery}"`, { encoding: 'utf8' });
    console.log(output);
  } catch (error) {
    console.error(chalk.yellow('âš ') + ' Could not display summary');
  }
}

// Main command handler
const command = process.argv[2];
const args = process.argv.slice(3);

switch (command) {
  case 'start':
    await cmdStart(args.join(' '));
    break;
  case 'stop':
    await cmdStop();
    break;
  case 'add':
    await cmdAdd(args[0], ...args.slice(1));
    break;
  case 'add-topics':
    await cmdAddTopics();
    break;
  case 'status':
    await cmdStatus();
    break;
  case 'today':
    await cmdToday();
    break;
  case 'week':
    await cmdWeek();
    break;
  case 'sync-db':
    await cmdSyncDb();
    break;
  default:
    console.log('Time Tracking CLI');
    console.log('');
    console.log('Usage: track [command] [options]');
    console.log('');
    console.log('Commands:');
    console.log('  start DESCRIPTION           Start tracking time (include #topic/tags in description)');
    console.log('  stop                        Stop current timer');
    console.log('  add DURATION DESCRIPTION    Add entry for work you forgot to track');
    console.log('  add-topics                  Auto-add topic tags to entries using AI');
    console.log('  status                      Show current timer status');
    console.log('  today                       Show today\'s entries');
    console.log('  week                        Show this week\'s entries');
    console.log('  sync-db                     Sync markdown files to database');
    console.log('');
    console.log('Examples:');
    console.log('  track start "Fixing image distortion #topic/ogm"');
    console.log('  track stop');
    console.log('  track add 20m "Code review #topic/ogm_site_development"');
    console.log('  track add 1.5h "Language practice #topic/languages"');
    console.log('  track status');
    console.log('  track today');
    console.log('');
    console.log('Duration formats for \'add\' command:');
    console.log('  20m, 35 minutes, 2h, 2 hours, 1.5h, 2h30m');
    console.log('');
    console.log('Common Topics:');
    console.log('  #topic/ogm #topic/ogm_sysadmin #topic/ogm_site_development');
    console.log('  #topic/fitness #topic/meditation_mindfulness #topic/languages');
    console.log('  #topic/home_household #topic/hosting #topic/personal_admin');
    console.log('');
}
