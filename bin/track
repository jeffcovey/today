#!/usr/bin/env node

import { execSync } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import { createInterface } from 'readline';
import { getDatabase } from '../src/database-service.js';
import { getSourcesForType, getWritableSource, writeEntryAndSync, ensureSyncForType, getSyncStatusMessage } from '../src/plugin-loader.js';
import {
  getConfiguredTimezone,
  getCurrentTimeISO,
  createTimeTodayISO,
  getTodayDate,
  getWeekAgoDate,
  addDaysToDate,
  formatDate,
  subtractSecondsISO,
  formatTime,
  formatISO8601,
  sqlLocalDate
} from '../src/date-utils.js';
import {
  parseDuration,
  formatDurationMinutes,
  calculateDurationMinutes
} from '../src/duration-utils.js';
import {
  colors,
  showSourceError,
  showSourceFilterError
} from '../src/cli-utils.js';
import { program } from 'commander';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.dirname(__dirname);

const TIMEZONE = getConfiguredTimezone();

/**
 * Parse a time string into an ISO 8601 string for today in the configured timezone
 * Supports formats: 9:00, 14:30, 9am, 2pm, 9:30am, 2:30pm
 * @returns {{ iso: string, date: Date } | null}
 */
function parseTimeString(timeStr) {
  if (!timeStr) return null;

  const str = timeStr.trim().toLowerCase();
  let hours = 0;
  let minutes = 0;

  // Try 24-hour format first: 14:30, 9:00
  const match24 = str.match(/^(\d{1,2}):(\d{2})$/);
  if (match24) {
    hours = parseInt(match24[1], 10);
    minutes = parseInt(match24[2], 10);
  } else {
    // Try 12-hour format: 9am, 2pm, 9:30am, 2:30pm
    const match12 = str.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)$/);
    if (match12) {
      hours = parseInt(match12[1], 10);
      minutes = match12[2] ? parseInt(match12[2], 10) : 0;
      const isPM = match12[3] === 'pm';

      if (hours === 12) {
        hours = isPM ? 12 : 0;
      } else if (isPM) {
        hours += 12;
      }
    } else {
      return null;
    }
  }

  // Validate
  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
    return null;
  }

  // Use the timezone-aware utility function
  return createTimeTodayISO(hours, minutes, TIMEZONE);
}

// Start tracking
async function cmdStart(description, options = {}) {
  if (!description) {
    console.error(colors.red('âœ—') + ' Usage: track start "Description with #topic/tags" [--source SOURCE]');
    console.log('');
    console.log('Examples:');
    console.log('  track start "Deep work session #topic/programming"');
    console.log('  track start "Duolingo practice #topic/languages"');
    console.log('  track start "Hip mobility workout #topic/fitness"');
    process.exit(1);
  }

  const db = getDatabase();
  const vaultPath = path.join(PROJECT_ROOT, 'vault');

  // Get target source
  const sourceResult = await getWritableSource('time-logs', options.source);
  if (!sourceResult.success) {
    showSourceError(sourceResult.error, sourceResult.availableSources);
    process.exit(1);
  }
  const { source } = sourceResult;

  // Check for running timer on this source
  const runningTimer = db.prepare(`
    SELECT start_time, description, source
    FROM time_logs
    WHERE end_time IS NULL AND source = ?
    ORDER BY start_time DESC
    LIMIT 1
  `).get(source.sourceId);

  if (runningTimer) {
    const currentTime = getCurrentTimeISO();
    const duration = calculateDurationMinutes(runningTimer.start_time, currentTime);
    const durationFormatted = formatDurationMinutes(duration);

    console.log(colors.yellow('âš ') + ` Stopping previous timer: ${runningTimer.description} (${durationFormatted})`);

    // Stop the previous timer
    const stopEntry = {
      start_time: runningTimer.start_time,
      end_time: currentTime,
      description: runningTimer.description
    };

    const stopResult = await writeEntryAndSync('time-logs', stopEntry, {
      sourceFilter: options.source,
      db,
      vaultPath
    });

    if (!stopResult.success) {
      console.error(colors.red('âœ—') + ` Failed to stop previous timer: ${stopResult.error}`);
      process.exit(1);
    }
  }

  // Start new timer (entry with NULL end_time)
  const startTime = getCurrentTimeISO();
  const entry = {
    start_time: startTime,
    end_time: null,
    description: description
  };

  const result = await writeEntryAndSync('time-logs', entry, {
    sourceFilter: options.source,
    db,
    vaultPath
  });

  if (!result.success) {
    console.error(colors.red('âœ—') + ` Failed to start timer: ${result.error}`);
    process.exit(1);
  }

  console.log(colors.green('âœ“') + ` Started: ${description}`);
  console.log(colors.blue('â„¹') + ` Timezone: ${TIMEZONE}`);
}

// Stop command
async function cmdStop(options = {}) {
  process.stdout.write(colors.gray('Syncing... '));
  await ensureSync();
  const db = getDatabase();
  const vaultPath = path.join(PROJECT_ROOT, 'vault');

  // Find running timer(s)
  let query = `
    SELECT start_time, description, source
    FROM time_logs
    WHERE end_time IS NULL
    ORDER BY start_time DESC
  `;

  const runningTimers = db.prepare(query).all();

  if (runningTimers.length === 0) {
    console.error(colors.red('âœ—') + ' No timer running');
    process.exit(1);
  }

  // If --source specified, filter to that source
  let timerToStop = runningTimers[0];
  if (options.source) {
    const matching = runningTimers.filter(t => t.source.includes(options.source));
    if (matching.length === 0) {
      console.error(colors.red('âœ—') + ` No running timer matching source "${options.source}"`);
      console.log('');
      console.log('Running timers:');
      for (const t of runningTimers) {
        console.log(`  ${t.source}: ${t.description}`);
      }
      process.exit(1);
    }
    timerToStop = matching[0];
  } else if (runningTimers.length > 1) {
    // Multiple timers, require --source
    console.error(colors.red('âœ—') + ' Multiple timers running. Use --source to specify which one to stop.');
    console.log('');
    console.log('Running timers:');
    for (const t of runningTimers) {
      console.log(`  ${t.source}: ${t.description}`);
    }
    process.exit(1);
  }

  const endTime = getCurrentTimeISO();
  const duration = calculateDurationMinutes(timerToStop.start_time, endTime);
  const durationFormatted = formatDurationMinutes(duration);

  // Warn if timer ran unusually long (likely forgotten)
  const LONG_TIMER_THRESHOLD_MINUTES = 240; // 4 hours
  if (duration > LONG_TIMER_THRESHOLD_MINUTES) {
    console.log(colors.yellow('âš ') + ` This timer ran for ${durationFormatted} - was it left running by mistake?`);
  }

  // Complete the entry
  const entry = {
    start_time: timerToStop.start_time,
    end_time: endTime,
    description: timerToStop.description
  };

  // Extract plugin name from the source ID for filtering
  const [pluginName] = timerToStop.source.split('/');

  process.stdout.write(colors.gray('Saving... '));
  const result = await writeEntryAndSync('time-logs', entry, {
    sourceFilter: pluginName,
    db,
    vaultPath
  });
  console.log(colors.gray('Done'));

  if (!result.success) {
    console.error(colors.red('âœ—') + ` Failed to stop timer: ${result.error}`);
    process.exit(1);
  }

  console.log(colors.green('âœ“') + ` Stopped: ${timerToStop.description} (${durationFormatted})`);
}

// Add command - add a completed entry
async function cmdAdd(durationStr, options = {}) {
  // Handle case where description parts come after options parsing
  const descriptionParts = options._positional || [];
  const description = descriptionParts.join(' ');

  if (!durationStr || !description) {
    console.error(colors.red('âœ—') + ' Usage: track add DURATION "Description with #topic/tags" [--source SOURCE] [--start TIME]');
    console.log('');
    console.log('Examples:');
    console.log('  track add 20m "Reviewing pull requests #topic/programming"');
    console.log('  track add 2h "Deep work session #topic/programming"');
    console.log('  track add 1.5h "Language practice #topic/languages" --start 9:00');
    console.log('  track add 2h30m "Project planning" --start 14:30');
    console.log('');
    console.log('Supported duration formats:');
    console.log('  20m, 35 minutes, 2h, 2 hours, 1.5h, 2h30m');
    console.log('');
    console.log('Supported start time formats:');
    console.log('  9:00, 14:30, 9am, 2pm, 9:30am, 2:30pm');
    process.exit(1);
  }

  const durationMinutes = parseDuration(durationStr);

  if (durationMinutes === 0) {
    console.error(colors.red('âœ—') + ` Could not parse duration: ${durationStr}`);
    console.log('');
    console.log('Supported formats: 20m, 35 minutes, 2h, 2 hours, 1.5h, 2h30m');
    process.exit(1);
  }

  const durationSeconds = durationMinutes * 60;
  let startTime, endTime;

  if (options.start) {
    // Parse the start time
    const parsed = parseTimeString(options.start);
    if (!parsed) {
      console.error(colors.red('âœ—') + ` Could not parse start time: ${options.start}`);
      console.log('');
      console.log('Supported formats: 9:00, 14:30, 9am, 2pm, 9:30am, 2:30pm');
      process.exit(1);
    }
    startTime = parsed.iso;
    // Calculate end time from start + duration
    const endDate = new Date(parsed.date.getTime() + durationSeconds * 1000);
    endTime = formatISO8601(endDate, TIMEZONE);
  } else {
    // Default: entry ends now
    endTime = getCurrentTimeISO();
    startTime = subtractSecondsISO(new Date(), durationSeconds);
  }

  // Write entry via plugin and sync
  const entry = {
    start_time: startTime,
    end_time: endTime,
    description: description
  };

  const db = getDatabase();
  const vaultPath = path.join(PROJECT_ROOT, 'vault');

  const result = await writeEntryAndSync('time-logs', entry, {
    sourceFilter: options.source,
    db,
    vaultPath,
    onSync: () => console.log(colors.gray('Syncing...'))
  });

  if (!result.success) {
    showSourceError(result.error, result.availableSources);
    process.exit(1);
  }

  const durationFormatted = formatDurationMinutes(durationMinutes);
  console.log(colors.green('âœ“') + ` Added: ${description} (${durationFormatted})`);

  console.log(colors.blue('â„¹') + ` Time range: ${formatTime(startTime)} - ${formatTime(endTime)}`);
}

// Status command - queries DB for running timers (end_time IS NULL)
async function cmdStatus() {
  // Perform daily sanity check (silent if no problems)
  await ensureSync();
  const db = getDatabase();
  await performDailyCheck(db, { verbose: false });

  // Query for all running timers across all sources
  const runningTimers = db.prepare(`
    SELECT start_time, description, source
    FROM time_logs
    WHERE end_time IS NULL
    ORDER BY start_time DESC
  `).all();

  if (runningTimers.length === 0) {
    console.log(colors.blue('â„¹') + ' No timer running');
    return;
  }

  console.log(colors.cyan('â±') + '  Currently tracking:');
  console.log('');

  const currentTime = getCurrentTimeISO();

  for (const timer of runningTimers) {
    const { start_time, description, source } = timer;
    const duration = calculateDurationMinutes(start_time, currentTime);
    const durationFormatted = formatDurationMinutes(duration);

    console.log('  ' + colors.green(description));
    console.log(`  Started: ${formatTime(start_time)}`);
    console.log(`  Duration: ${durationFormatted}`);
    console.log(`  Source: ${colors.gray(source)}`);

    if (runningTimers.length > 1) {
      console.log('');
    }
  }
}

// Date command - queries time_logs table for a specific date
async function cmdDate(targetDate, options = {}) {
  await ensureSync();
  const db = getDatabase();
  const currentTime = getCurrentTimeISO();

  // Validate source filter if provided
  if (options.source) {
    const { sources, allSources } = await getSourcesForType('time-logs', options.source);
    if (sources.length === 0) {
      showSourceFilterError(options.source, 'time-logs', allSources);
      return;
    }
    // Show which sources we're querying
    console.log(colors.gray(`Sources: ${sources.map(s => s.sourceId).join(', ')}`));
    console.log('');
  }

  // Check for running timers first (only for today)
  const today = getTodayDate();
  if (targetDate === today) {
    let runningQuery = `
      SELECT start_time, description, source
      FROM time_logs
      WHERE end_time IS NULL
      ORDER BY start_time DESC
    `;
    if (options.source) {
      runningQuery = `
        SELECT start_time, description, source
        FROM time_logs
        WHERE end_time IS NULL AND source LIKE ?
        ORDER BY start_time DESC
      `;
    }
    const runningTimers = options.source
      ? db.prepare(runningQuery).all(`%${options.source}%`)
      : db.prepare(runningQuery).all();

    if (runningTimers.length > 0) {
      console.log(colors.cyan('â±  Currently Tracking'));
      console.log('');
      for (const timer of runningTimers) {
        const duration = calculateDurationMinutes(timer.start_time, currentTime);
        console.log(`  ${colors.yellow('â±')} ${formatTime(timer.start_time)} - now (${formatDurationMinutes(duration)})`);
        console.log(`    ${timer.description}`);
      }
      console.log('');
    }
  }

  // Build query with optional source filter
  // Use sqlLocalDate() to extract date from timezone-aware timestamps correctly
  let query = `
    SELECT start_time, end_time, duration_minutes, description, source
    FROM time_logs
    WHERE ${sqlLocalDate('start_time')} = ?
    ORDER BY start_time
  `;
  const params = [targetDate];

  if (options.source) {
    query = `
      SELECT start_time, end_time, duration_minutes, description, source
      FROM time_logs
      WHERE ${sqlLocalDate('start_time')} = ? AND source LIKE ?
      ORDER BY start_time
    `;
    params.push(`%${options.source}%`);
  }

  const entries = db.prepare(query).all(...params);

  // Filter out running timers from completed entries display
  const completedEntries = entries.filter(e => e.end_time !== null);

  // Check if we have any running timers (only relevant for today)
  const hasRunningTimers = targetDate === today && entries.some(e => e.end_time === null);

  if (completedEntries.length === 0 && !hasRunningTimers) {
    console.log(colors.blue('â„¹') + ` No time entries for ${targetDate}`);
    return;
  }

  // Use special header for today
  const isToday = targetDate === today;
  const header = isToday
    ? colors.cyan("Today's Time Tracking") + ` (${targetDate})`
    : colors.cyan("Time Tracking") + ` (${targetDate})`;

  console.log(header);
  console.log('');

  if (completedEntries.length === 0) {
    if (isToday && hasRunningTimers) {
      console.log(colors.blue('â„¹') + ' No completed entries yet');
    } else {
      console.log(colors.blue('â„¹') + ` No time entries for ${targetDate}`);
    }
    return;
  }

  let totalMinutes = 0;
  const topicMinutes = {};

  for (const entry of completedEntries) {
    const { start_time, end_time, duration_minutes, description } = entry;
    const duration = duration_minutes || calculateDurationMinutes(start_time, end_time);

    if (!description) continue;

    const topics = (description.match(/#topic\/[a-z_]+/g) || ['(untagged)']).join(' ');

    totalMinutes += duration;
    topicMinutes[topics] = (topicMinutes[topics] || 0) + duration;

    // Display entry
    const startDisplay = formatTime(start_time);
    const endDisplay = formatTime(end_time);
    console.log(`  ${colors.green('âœ“')} ${startDisplay} - ${endDisplay} (${formatDurationMinutes(duration)})`);
    console.log(`    ${description}`);
  }

  // Summary by topic
  if (Object.keys(topicMinutes).length > 0) {
    console.log('');
    console.log(colors.cyan('By Topic:'));
    const sorted = Object.entries(topicMinutes).sort((a, b) => b[1] - a[1]);
    for (const [topic, mins] of sorted) {
      console.log(`  ${topic}: ${formatDurationMinutes(mins)}`);
    }
  }

  console.log('');
  console.log(colors.cyan('Total:') + ` ${formatDurationMinutes(totalMinutes)}`);
  console.log('');
  console.log(getSyncStatusMessage(db, 'time-logs'));
}

// Today command - wrapper around cmdDate for today's date
async function cmdToday(options = {}) {
  // Perform daily sanity check (silent if no problems)
  const db = getDatabase();
  await performDailyCheck(db, { verbose: false });

  const today = getTodayDate();
  await cmdDate(today, options);
}

// Get yesterday's date in YYYY-MM-DD format
function getYesterdayDate(timezone) {
  const tz = timezone || getConfiguredTimezone();
  const today = new Date();
  const yesterday = addDaysToDate(today, -1);
  return formatDate(yesterday);
}

// Yesterday command - wrapper around cmdDate for yesterday's date
async function cmdYesterday(options = {}) {
  const yesterday = getYesterdayDate();
  await cmdDate(yesterday, options);
}

// Week command - queries time_logs table
async function cmdWeek(options = {}) {
  await ensureSync();
  const db = getDatabase();

  // Validate source filter if provided
  if (options.source) {
    const { sources, allSources } = await getSourcesForType('time-logs', options.source);
    if (sources.length === 0) {
      showSourceFilterError(options.source, 'time-logs', allSources);
      return;
    }
    // Show which sources we're querying
    console.log(colors.gray(`Sources: ${sources.map(s => s.sourceId).join(', ')}`));
    console.log('');
  }

  // Calculate week start (7 days ago)
  const weekStart = getWeekAgoDate();
  const today = getTodayDate();

  // Build query with optional source filter
  // Use sqlLocalDate() to extract date from timezone-aware timestamps correctly
  let query = `
    SELECT start_time, end_time, duration_minutes, description, source
    FROM time_logs
    WHERE ${sqlLocalDate('start_time')} >= ? AND ${sqlLocalDate('start_time')} <= ?
    ORDER BY start_time
  `;
  const params = [weekStart, today];

  if (options.source) {
    query = `
      SELECT start_time, end_time, duration_minutes, description, source
      FROM time_logs
      WHERE ${sqlLocalDate('start_time')} >= ? AND ${sqlLocalDate('start_time')} <= ? AND source LIKE ?
      ORDER BY start_time
    `;
    params.push(`%${options.source}%`);
  }

  const entries = db.prepare(query).all(...params);

  if (entries.length === 0) {
    console.log(colors.blue('â„¹') + ' No time entries for this week');
    return;
  }

  console.log(colors.cyan("This Week's Time Tracking") + ` (${weekStart} to ${today})`);
  console.log('');

  let totalMinutes = 0;
  const topicMinutes = {};
  const dayMinutes = {};

  for (const entry of entries) {
    const { start_time, duration_minutes, description } = entry;
    const duration = duration_minutes || calculateDurationMinutes(start_time, entry.end_time);

    if (!description) continue;

    const entryDate = start_time.substring(0, 10);
    const topics = (description.match(/#topic\/[a-z_]+/g) || ['(untagged)']).join(' ');

    totalMinutes += duration;
    topicMinutes[topics] = (topicMinutes[topics] || 0) + duration;
    dayMinutes[entryDate] = (dayMinutes[entryDate] || 0) + duration;
  }

  // Summary by day
  console.log(colors.cyan('By Day:'));
  const sortedDays = Object.entries(dayMinutes).sort((a, b) => a[0].localeCompare(b[0]));
  for (const [day, mins] of sortedDays) {
    console.log(`  ${day}: ${formatDurationMinutes(mins)}`);
  }

  // Summary by topic
  console.log('');
  console.log(colors.cyan('By Topic:'));
  const sortedTopics = Object.entries(topicMinutes).sort((a, b) => b[1] - a[1]);
  for (const [topic, mins] of sortedTopics) {
    console.log(`  ${topic}: ${formatDurationMinutes(mins)}`);
  }

  console.log('');
  console.log(colors.cyan('Total:') + ` ${formatDurationMinutes(totalMinutes)}`);
  console.log('');
  console.log(getSyncStatusMessage(db, 'time-logs'));
}

// Quiet sync - ensures database is current before read operations
async function ensureSync() {
  const db = getDatabase();
  await ensureSyncForType(db, 'time-logs');
}

// Restart command - start a new timer with the same description as the most recent entry
async function cmdRestart(options = {}) {
  await ensureSync();
  const db = getDatabase();

  // Find the most recent completed entry
  const lastEntry = db.prepare(`
    SELECT description, source
    FROM time_logs
    WHERE end_time IS NOT NULL
    ORDER BY end_time DESC
    LIMIT 1
  `).get();

  if (!lastEntry) {
    console.error(colors.red('âœ—') + ' No previous entries to restart');
    process.exit(1);
  }

  console.log(colors.blue('â„¹') + ` Restarting: ${lastEntry.description}`);

  // Extract plugin name from source for filtering
  const [pluginName] = lastEntry.source.split('/');

  // Use cmdStart with the same description
  await cmdStart(lastEntry.description, { source: options.source || pluginName });
}

// Sync command - delegates to plugin system for all time-logs plugins
async function cmdSync() {
  console.log(colors.blue('â„¹') + ' Syncing time-logs plugins to database...');

  try {
    const result = execSync('bin/plugins sync --type time-logs', { encoding: 'utf8' });
    // Strip dotenvx output and show result
    const lines = result.split('\n').filter(l => !l.includes('[dotenvx'));
    console.log(lines.join('\n'));
  } catch (error) {
    // Check if it's just "no plugins" vs actual error
    if (error.stdout?.includes('No plugins of type')) {
      console.log(colors.yellow('âš ') + ' No time-logs plugins are enabled.');
      console.log('');
      console.log('To sync time tracking data, configure a plugin:');
      console.log('');
      console.log('  ' + colors.cyan('bin/plugins configure'));
    } else {
      console.error(colors.red('âœ—') + ' Sync failed:', error.message);
      process.exit(1);
    }
  }
}

// Audit command - check for problematic time entries
async function cmdAudit(options = {}) {
  await ensureSync();
  const db = getDatabase();

  // Handle daily check mode
  if (options.daily) {
    return await performDailyCheck(db, options);
  }

  // Determine date range to check
  const endDate = getTodayDate();
  let startDate;

  if (options.all) {
    // Check all entries
    const oldestEntry = db.prepare(`
      SELECT MIN(DATE(start_time, 'localtime')) as oldest_date
      FROM time_logs
    `).get();
    startDate = oldestEntry?.oldest_date || endDate;
  } else {
    // Check last N days (default 30)
    const daysToCheck = options.days || 30;
    const startDateObj = new Date();
    startDateObj.setDate(startDateObj.getDate() - daysToCheck);
    startDate = formatDate(startDateObj);
  }

  console.log(colors.cyan('ðŸ” Time Tracking Audit') + ` (${startDate} to ${endDate})`);
  console.log('');

  // Find problematic entries
  const problems = findProblems(db, startDate, endDate);

  if (problems.length === 0) {
    console.log(colors.green('âœ“') + ' No problems found!');
    return;
  }

  console.log(colors.yellow(`âš  Found ${problems.length} potential problem${problems.length > 1 ? 's' : ''}:`));
  console.log('');

  for (const problem of problems) {
    displayProblem(problem);
  }

  console.log('');
  console.log(colors.blue('â„¹') + ' Run ' + colors.cyan('bin/track fix') + ' to see suggested corrections');
}

// Perform daily sanity check (used internally and via --daily flag)
async function performDailyCheck(db, options = {}) {
  // Check if we've already done today's check
  if (!options.force && hasCheckedToday(db)) {
    if (options.verbose) {
      console.log(colors.blue('â„¹') + ' Daily sanity check already completed today');
    }
    return;
  }

  // Check last 7 days for any day with >24 hours
  const endDate = getTodayDate();
  const startDateObj = new Date();
  startDateObj.setDate(startDateObj.getDate() - 7);
  const startDate = formatDate(startDateObj);

  const problems = findProblems(db, startDate, endDate, { onlyMajor: true });

  if (problems.length > 0) {
    console.log(colors.yellow('âš ') + ` Found ${problems.length} time tracking issue${problems.length > 1 ? 's' : ''} in the last 7 days:`);
    console.log('');

    for (const problem of problems) {
      displayProblem(problem);
    }

    console.log('');
    console.log(colors.blue('â„¹') + ' Run ' + colors.cyan('bin/track fix') + ' to see suggested corrections');
  } else if (options.verbose) {
    console.log(colors.green('âœ“') + ' No time tracking problems found in last 7 days');
  }

  // Mark that we've checked today
  markCheckedToday(db);
}


// Find problems in time entries
function findProblems(db, startDate, endDate, options = {}) {
  const problems = [];

  // Get all entries in date range grouped by date
  const dailyTotals = db.prepare(`
    SELECT
      DATE(start_time, 'localtime') as date,
      SUM(CASE WHEN duration_minutes IS NULL THEN 0 ELSE duration_minutes END) as total_minutes,
      COUNT(*) as entry_count
    FROM time_logs
    WHERE DATE(start_time, 'localtime') >= ? AND DATE(start_time, 'localtime') <= ?
    GROUP BY DATE(start_time, 'localtime')
    ORDER BY date
  `).all(startDate, endDate);

  // Check for impossible daily totals (>24 hours)
  for (const day of dailyTotals) {
    const totalHours = day.total_minutes / 60;
    if (totalHours > 24) {
      problems.push({
        type: 'impossible_day_total',
        severity: 'major',
        date: day.date,
        totalHours: Math.round(totalHours * 10) / 10,
        totalMinutes: day.total_minutes,
        entryCount: day.entry_count,
        message: `${day.date} has ${Math.round(totalHours * 10) / 10}h of tracked time (${day.entry_count} entries)`
      });
    }
  }

  // Check for extremely long individual entries (>12 hours)
  const longEntries = db.prepare(`
    SELECT
      DATE(start_time, 'localtime') as date,
      start_time,
      end_time,
      duration_minutes,
      description,
      id
    FROM time_logs
    WHERE DATE(start_time, 'localtime') >= ? AND DATE(start_time, 'localtime') <= ?
      AND duration_minutes > 720
    ORDER BY duration_minutes DESC
  `).all(startDate, endDate);

  for (const entry of longEntries) {
    const hours = Math.round((entry.duration_minutes / 60) * 10) / 10;
    problems.push({
      type: 'long_entry',
      severity: entry.duration_minutes > 1440 ? 'major' : 'minor', // >24h = major
      date: entry.date,
      hours: hours,
      entry: entry,
      message: `${entry.date}: ${hours}h entry - "${entry.description.substring(0, 50)}${entry.description.length > 50 ? '...' : ''}"`
    });
  }

  // Check for running timers older than 1 day
  const now = getCurrentTimeISO();
  const oldRunningTimers = db.prepare(`
    SELECT
      start_time,
      description,
      source,
      id
    FROM time_logs
    WHERE end_time IS NULL
      AND datetime(start_time) < datetime(?, '-1 day')
    ORDER BY start_time
  `).all(now);

  for (const timer of oldRunningTimers) {
    const duration = calculateDurationMinutes(timer.start_time, now);
    const hours = Math.round((duration / 60) * 10) / 10;
    problems.push({
      type: 'old_running_timer',
      severity: 'major',
      hours: hours,
      entry: timer,
      message: `Running timer for ${hours}h: "${timer.description.substring(0, 50)}${timer.description.length > 50 ? '...' : ''}"`
    });
  }

  // If onlyMajor flag is set, filter to major problems only
  if (options.onlyMajor) {
    return problems.filter(p => p.severity === 'major');
  }

  return problems;
}

// Display a problem
function displayProblem(problem) {
  const icon = problem.severity === 'major' ? 'ðŸš¨' : 'âš ï¸';
  console.log(`  ${icon} ${problem.message}`);
}

// Check if we've already run daily check today
function hasCheckedToday(db) {
  const today = getTodayDate();

  try {
    const lastCheck = db.prepare(`
      SELECT value FROM metadata WHERE key = 'last_sanity_check'
    `).get();

    return lastCheck?.value === today;
  } catch (error) {
    // metadata table might not exist yet
    return false;
  }
}

// Mark that we've checked today
function markCheckedToday(db) {
  const today = getTodayDate();

  // Create metadata table if it doesn't exist
  try {
    db.prepare(`
      CREATE TABLE IF NOT EXISTS metadata (
        key TEXT PRIMARY KEY,
        value TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `).run();

    db.prepare(`
      INSERT OR REPLACE INTO metadata (key, value) VALUES ('last_sanity_check', ?)
    `).run(today);
  } catch (error) {
    // If we can't create metadata table, just continue silently
    // The check will run again next time
  }
}

// Fix command - suggest and apply corrections to problematic entries
async function cmdFix(options = {}) {
  await ensureSync();
  const db = getDatabase();

  // Find problems in last 30 days by default
  const endDate = getTodayDate();
  const daysToCheck = options.days || 30;
  const startDateObj = new Date();
  startDateObj.setDate(startDateObj.getDate() - daysToCheck);
  const startDate = formatDate(startDateObj);

  const problems = findProblems(db, startDate, endDate);

  if (problems.length === 0) {
    console.log(colors.green('âœ“') + ' No problems found to fix!');
    return;
  }

  console.log(colors.cyan('ðŸ”§ Time Tracking Fixes') + ` (${startDate} to ${endDate})`);
  console.log('');
  console.log(`Found ${problems.length} problem${problems.length > 1 ? 's' : ''} - analyzing for fixes...`);
  console.log('');

  // Group problems by type and suggest fixes
  const suggestions = await generateSuggestions(db, problems);

  if (suggestions.length === 0) {
    console.log(colors.yellow('âš ') + ' No automatic fixes available for these problems:');
    console.log('');

    // Show the problems so user knows what to fix manually
    for (const problem of problems) {
      displayProblem(problem);

      // Show additional details to help locate the entry
      if (problem.entry) {
        console.log(colors.gray(`     File: ${problem.entry.id || 'unknown'}`));
        console.log(colors.gray(`     Time: ${formatTime(problem.entry.start_time)} - ${formatTime(problem.entry.end_time)}`));
      }
    }

    console.log('');
    console.log('Consider manually editing the source files or using bin/track add/start/stop to correct entries.');
    return;
  }

  console.log(`Generated ${suggestions.length} suggested fix${suggestions.length > 1 ? 'es' : ''}:`);
  console.log('');

  // Show suggestions and ask for approval
  if (options.dryRun) {
    // Just show what would be done
    for (const suggestion of suggestions) {
      displaySuggestion(suggestion, true);
    }
    console.log('');
    console.log(colors.blue('â„¹') + ' Dry run completed. Use --apply to actually make changes.');
    return;
  }

  // Interactive mode - ask for each suggestion
  const appliedFixes = [];

  for (let i = 0; i < suggestions.length; i++) {
    const suggestion = suggestions[i];
    console.log(`${colors.cyan(`Fix ${i + 1}/${suggestions.length}:`)} ${suggestion.description}`);
    console.log('');
    displaySuggestion(suggestion);

    const answer = await askUserApproval(
      'Apply this fix?',
      ['yes', 'no', 'quit'],
      'yes'
    );

    console.log('');

    if (answer === 'quit') {
      console.log(colors.yellow('âš ') + ' Stopped by user request');

      // Sync any fixes that were already applied before quitting
      if (appliedFixes.length > 0) {
        console.log('');
        console.log(colors.blue('â„¹') + ' Re-syncing applied fixes...');
        await cmdSync();
        console.log(colors.green(`âœ“ ${appliedFixes.length} fix${appliedFixes.length > 1 ? 'es' : ''} applied and synced`));
      }

      return; // Exit the function immediately
    }

    if (answer === 'yes' || answer === 'y') {
      try {
        const result = await applyFix(db, suggestion);
        if (result.success) {
          appliedFixes.push(suggestion);
          console.log(colors.green('âœ“') + ` Fix applied successfully`);

          // Immediate sync after each fix for better safety
          console.log(colors.gray('    Syncing...'));
          await cmdSync();
          console.log(colors.gray('    âœ“ Synced'));
        } else {
          console.log(colors.red('âœ—') + ` Failed to apply fix: ${result.error}`);
        }
      } catch (error) {
        console.log(colors.red('âœ—') + ` Error applying fix: ${error.message}`);
      }
    } else if (answer === 'no' || answer === 'n') {
      console.log(colors.gray('  Skipped'));
    } else {
      // Handle any unexpected input
      console.log(colors.gray('  Skipped'));
    }

    if (i < suggestions.length - 1) {
      console.log('');
    }
  }

  // Final summary (sync already happened after each fix)
  if (appliedFixes.length > 0) {
    console.log('');
    console.log(colors.green(`âœ“ All ${appliedFixes.length} fix${appliedFixes.length > 1 ? 'es' : ''} applied and synced successfully`));
  } else {
    console.log('');
    console.log(colors.blue('â„¹') + ' No fixes were applied');
  }
}

// Generate intelligent suggestions for fixing problems
async function generateSuggestions(db, problems) {
  const suggestions = [];

  for (const problem of problems) {
    switch (problem.type) {
      case 'old_running_timer':
        // Suggest stopping old running timers
        suggestions.push({
          type: 'stop_timer',
          problem: problem,
          description: `Stop running timer: "${problem.entry.description.substring(0, 50)}..."`,
          action: {
            type: 'stop_timer',
            entryId: problem.entry.id,
            suggestedEndTime: problem.entry.start_time // Stop at same time as start
          }
        });
        break;

      case 'long_entry':
        // For long entries (>12 hours), suggest capping to reasonable duration
        const reasonableEndTimeLong = await suggestReasonableEndTime(db, problem.entry);
        if (reasonableEndTimeLong) {
          suggestions.push({
            type: 'cap_entry',
            problem: problem,
            description: `Cap ${problem.hours}h entry to reasonable duration`,
            action: {
              type: 'update_end_time',
              entryId: problem.entry.id,
              entryStartTime: problem.entry.start_time,
              currentEndTime: problem.entry.end_time,
              suggestedEndTime: reasonableEndTimeLong,
              reason: 'Likely forgotten timer - capped to reasonable work session length'
            }
          });
        }
        break;

      case 'impossible_day_total':
        // Get all entries for this day
        const allDayEntries = db.prepare(`
          SELECT * FROM time_logs
          WHERE DATE(start_time, 'localtime') = ?
          ORDER BY start_time
        `).all(problem.date);

        const handledIds = new Set();

        // 1. Find near-duplicate entries (same description, start within 5 min)
        for (let i = 0; i < allDayEntries.length; i++) {
          for (let j = i + 1; j < allDayEntries.length; j++) {
            const a = allDayEntries[i];
            const b = allDayEntries[j];

            if (handledIds.has(a.id) || handledIds.has(b.id)) continue;

            if (a.description === b.description) {
              const startDiffMin = Math.abs(new Date(a.start_time) - new Date(b.start_time)) / 60000;

              if (startDiffMin < 5) {
                const shorter = (a.duration_minutes || 0) <= (b.duration_minutes || 0) ? a : b;
                handledIds.add(shorter.id);
                suggestions.push({
                  type: 'remove_duplicate',
                  problem,
                  description: `Remove duplicate: "${shorter.description.substring(0, 50)}${shorter.description.length > 50 ? '...' : ''}"`,
                  action: {
                    type: 'remove_entry',
                    entryId: shorter.id,
                    entry: shorter,
                    reason: `Near-duplicate entry (same description, starts ${Math.round(startDiffMin)}min after another)`
                  }
                });
              }
            }
          }
        }

        // 2. Find entries entirely contained within another with same description
        for (let i = 0; i < allDayEntries.length; i++) {
          for (let j = i + 1; j < allDayEntries.length; j++) {
            const a = allDayEntries[i];
            const b = allDayEntries[j];

            if (handledIds.has(a.id) || handledIds.has(b.id)) continue;
            if (a.description !== b.description) continue;

            const aStart = new Date(a.start_time).getTime();
            const aEnd = a.end_time ? new Date(a.end_time).getTime() : Date.now();
            const bStart = new Date(b.start_time).getTime();
            const bEnd = b.end_time ? new Date(b.end_time).getTime() : Date.now();

            if (bStart >= aStart && bEnd <= aEnd) {
              handledIds.add(b.id);
              suggestions.push({
                type: 'remove_contained',
                problem,
                description: `Remove redundant entry: "${b.description.substring(0, 50)}${b.description.length > 50 ? '...' : ''}"`,
                action: {
                  type: 'remove_entry',
                  entryId: b.id,
                  entry: b,
                  reason: `Entirely contained within a longer "${a.description.substring(0, 30)}" entry (${formatTime(a.start_time)} - ${formatTime(a.end_time)})`
                }
              });
            } else if (aStart >= bStart && aEnd <= bEnd) {
              handledIds.add(a.id);
              suggestions.push({
                type: 'remove_contained',
                problem,
                description: `Remove redundant entry: "${a.description.substring(0, 50)}${a.description.length > 50 ? '...' : ''}"`,
                action: {
                  type: 'remove_entry',
                  entryId: a.id,
                  entry: a,
                  reason: `Entirely contained within a longer "${b.description.substring(0, 30)}" entry (${formatTime(b.start_time)} - ${formatTime(b.end_time)})`
                }
              });
            }
          }
        }

        // 3. Fall back: cap longest entries on this day (lower threshold for impossible days)
        const cappableEntries = db.prepare(`
          SELECT * FROM time_logs
          WHERE DATE(start_time, 'localtime') = ?
            AND duration_minutes > 180
          ORDER BY duration_minutes DESC
          LIMIT 3
        `).all(problem.date);

        for (const entry of cappableEntries) {
          if (handledIds.has(entry.id)) continue;
          const reasonableEndTime = await suggestReasonableEndTime(db, entry);
          if (reasonableEndTime) {
            suggestions.push({
              type: 'cap_day_entry',
              problem: { ...problem, entry },
              description: `Cap long entry on ${problem.date}: "${entry.description.substring(0, 40)}${entry.description.length > 40 ? '...' : ''}"`,
              action: {
                type: 'update_end_time',
                entryId: entry.id,
                entryStartTime: entry.start_time,
                currentEndTime: entry.end_time,
                suggestedEndTime: reasonableEndTime,
                reason: `Part of ${problem.totalHours}h day - likely overlapping with concurrent entries`
              }
            });
          }
        }
        break;
    }
  }

  return suggestions;
}

// Suggest a reasonable end time based on typical work patterns
async function suggestReasonableEndTime(db, entry) {
  try {
    const startTime = new Date(entry.start_time);

    // Look at user's typical session lengths for similar activities
    const description = entry.description;
    const topic = description.match(/#topic\/[a-z_]+/)?.[0] || null;

    let typicalDuration = 120; // Default 2 hours

    if (topic) {
      // Find average duration for this topic type
      const avgDuration = db.prepare(`
        SELECT AVG(duration_minutes) as avg_minutes
        FROM time_logs
        WHERE description LIKE ?
          AND duration_minutes BETWEEN 15 AND 480
          AND DATE(start_time, 'localtime') >= DATE('now', 'localtime', '-90 days')
      `).get(`%${topic}%`);

      if (avgDuration?.avg_minutes && avgDuration.avg_minutes > 0) {
        typicalDuration = Math.min(Math.max(avgDuration.avg_minutes, 30), 240); // 30min to 4h
      }
    }

    // Suggest end time based on typical duration
    const suggestedEndTime = new Date(startTime.getTime() + (typicalDuration * 60 * 1000));
    return suggestedEndTime.toISOString();

  } catch (error) {
    return null;
  }
}

// Display a suggestion for user review
function displaySuggestion(suggestion, dryRun = false) {
  const { problem, action } = suggestion;

  if (action.type === 'stop_timer') {
    console.log(colors.yellow('  Current:') + ` Timer running since ${formatTime(problem.entry.start_time)} (${problem.hours}h)`);
    console.log(colors.green('  Fix:') + ' Stop the timer now');
  }
  else if (action.type === 'remove_entry') {
    const entry = action.entry;
    const duration = entry.duration_minutes || 0;
    console.log(colors.cyan('  Entry:') + ` "${entry.description}"`);
    console.log(colors.yellow('  Time:') + ` ${formatTime(entry.start_time)} - ${formatTime(entry.end_time)} (${formatDurationMinutes(duration)})`);
    if (entry.id) {
      console.log(colors.gray('  File:') + ` ${entry.id}`);
    }
    console.log(colors.green('  Fix:') + ' Remove this entry');
    console.log(colors.gray('  Reason:') + ` ${action.reason}`);
  }
  else if (action.type === 'update_end_time') {
    const entryStartTime = action.entryStartTime;

    if (!entryStartTime) {
      console.log(colors.red('Error: Could not determine entry start time for suggestion'));
      return;
    }

    const currentDuration = calculateDurationMinutes(entryStartTime, action.currentEndTime);
    const suggestedDuration = calculateDurationMinutes(entryStartTime, action.suggestedEndTime);

    // Show entry description and location
    if (problem.entry?.description) {
      console.log(colors.cyan('  Entry:') + ` "${problem.entry.description.substring(0, 60)}${problem.entry.description.length > 60 ? '...' : ''}"`);
    }
    if (problem.entry?.id) {
      console.log(colors.gray('  File:') + ` ${problem.entry.id}`);
    }

    console.log(colors.yellow('  Current:') + ` ${formatTime(entryStartTime)} - ${formatTime(action.currentEndTime)} (${formatDurationMinutes(currentDuration)})`);
    console.log(colors.green('  Suggested:') + ` ${formatTime(entryStartTime)} - ${formatTime(action.suggestedEndTime)} (${formatDurationMinutes(suggestedDuration)})`);
    console.log(colors.gray('  Reason:') + ` ${action.reason}`);
  }

  if (!dryRun) {
    console.log('');
  }
}

// Ask user for approval with interactive prompt
async function askUserApproval(question, options = ['yes', 'no'], defaultOption = 'yes') {
  return new Promise((resolve) => {
    const rl = createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    const optionsStr = options.map(opt =>
      opt === defaultOption ? opt.toUpperCase() : opt
    ).join('/');

    rl.question(`${question} [${optionsStr}]: `, (answer) => {
      rl.close();

      const input = answer.trim().toLowerCase();

      if (input === '' && defaultOption) {
        resolve(defaultOption);
        return;
      }

      // Allow single character responses
      const singleCharMatch = options.find(opt => opt.startsWith(input));
      if (singleCharMatch) {
        resolve(singleCharMatch);
        return;
      }

      if (options.includes(input)) {
        resolve(input);
      } else {
        console.log(colors.red('Invalid option. Please try again.'));
        resolve(askUserApproval(question, options, defaultOption));
      }
    });
  });
}

// Apply a fix to the database and source files
async function applyFix(db, suggestion) {
  const { action } = suggestion;

  try {
    if (action.type === 'stop_timer') {
      // Stop a running timer
      return await stopOldTimer(db, suggestion);
    } else if (action.type === 'update_end_time') {
      // Update an entry's end time
      return await updateEntryEndTime(db, suggestion);
    } else if (action.type === 'remove_entry') {
      // Remove a duplicate/redundant entry
      return await removeEntry(db, suggestion);
    } else {
      return { success: false, error: `Unknown action type: ${action.type}` };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Stop an old running timer
async function stopOldTimer(db, suggestion) {
  const { problem, action } = suggestion;
  const entry = problem.entry;

  // Update the database entry
  const endTime = getCurrentTimeISO();
  const duration = calculateDurationMinutes(entry.start_time, endTime);

  db.prepare(`
    UPDATE time_logs
    SET end_time = ?, duration_minutes = ?
    WHERE id = ?
  `).run(endTime, duration, entry.id);

  // Try to update source file if it's the markdown plugin
  if (entry.source?.includes('markdown-time-tracking')) {
    try {
      const result = await updateMarkdownSourceFile(entry, endTime);
      if (result.success) {
        console.log(colors.gray('    Source file updated'));
      }
    } catch (error) {
      console.log(colors.yellow('âš ') + ` Database updated but couldn't update source file: ${error.message}`);
    }
  }

  return { success: true };
}

// Update an entry's end time
async function updateEntryEndTime(db, suggestion) {
  const { action } = suggestion;

  // Update the database entry
  const duration = calculateDurationMinutes(action.entryStartTime, action.suggestedEndTime);

  db.prepare(`
    UPDATE time_logs
    SET end_time = ?, duration_minutes = ?
    WHERE id = ?
  `).run(action.suggestedEndTime, duration, action.entryId);

  // Try to update source file if it's the markdown plugin
  if (action.entryId?.includes('markdown-time-tracking')) {
    try {
      // Find the entry in database to get current details
      const entry = db.prepare(`
        SELECT * FROM time_logs WHERE id = ?
      `).get(action.entryId);

      if (entry) {
        const result = await updateMarkdownSourceFile(entry, action.suggestedEndTime);
        if (result.success) {
          console.log(colors.gray('    Source file updated'));
        }
      }
    } catch (error) {
      console.log(colors.yellow('âš ') + ` Database updated but couldn't update source file: ${error.message}`);
    }
  }

  return { success: true };
}

// Update markdown source file for an entry
async function updateMarkdownSourceFile(entry, newEndTime) {
  try {
    // Parse entry ID to get file path and line number
    // Format: "markdown-time-tracking/local:vault/logs/time-tracking/2026-01.md:150"
    const entryId = entry.id;
    if (!entryId || !entryId.includes(':')) {
      throw new Error('Invalid entry ID format');
    }

    // Split to separate the source prefix from the file path and line number
    const parts = entryId.split(':');
    if (parts.length < 3) {
      throw new Error('Invalid entry ID format - expected source:path:line');
    }

    // Reconstruct the file path and get line number
    const filePath = parts.slice(1, -1).join(':'); // Handle paths that might have colons
    const lineNumStr = parts[parts.length - 1];
    const lineNum = parseInt(lineNumStr);

    if (isNaN(lineNum)) {
      throw new Error('Invalid line number in entry ID');
    }

    // Get full file path
    const fullFilePath = path.join(PROJECT_ROOT, filePath);

    // Check if file exists
    const fs = await import('fs');
    if (!fs.existsSync(fullFilePath)) {
      throw new Error(`Source file not found: ${filePath}`);
    }

    // Read current file content
    const content = fs.readFileSync(fullFilePath, 'utf8');
    const lines = content.split('\n');

    // Check if line number is valid
    if (lineNum >= lines.length) {
      throw new Error(`Line ${lineNum} does not exist in file`);
    }

    // Parse and update the line
    const currentLine = lines[lineNum];
    const lineParts = currentLine.split('|');

    if (lineParts.length < 3) {
      throw new Error('Invalid time entry format in source file');
    }

    // Update the end time while preserving start time and description
    const [startTime, oldEndTime, description] = lineParts;
    const newLine = `${startTime.trim()}|${newEndTime}|${description.trim()}`;

    // Update the line in memory
    lines[lineNum] = newLine;

    // Write the updated content back to file
    const updatedContent = lines.join('\n');
    fs.writeFileSync(fullFilePath, updatedContent, 'utf8');

    return { success: true, filePath, lineNum, oldEndTime: oldEndTime?.trim(), newEndTime };

  } catch (error) {
    throw new Error(`Failed to update source file: ${error.message}`);
  }
}

// Remove a duplicate/redundant entry
async function removeEntry(db, suggestion) {
  const { action } = suggestion;

  // Re-lookup entry by start_time and description to handle shifted line numbers after previous removals
  const currentEntry = db.prepare(`
    SELECT * FROM time_logs
    WHERE start_time = ? AND description = ?
    LIMIT 1
  `).get(action.entry.start_time, action.entry.description);

  if (!currentEntry) {
    return { success: false, error: 'Entry not found (may have already been removed)' };
  }

  // Remove from source file first (before DB delete, so we can use the ID for line lookup)
  if (currentEntry.id?.includes('markdown-time-tracking')) {
    try {
      const result = await removeMarkdownSourceLine(currentEntry);
      if (result.success) {
        console.log(colors.gray('    Source file updated'));
      }
    } catch (error) {
      console.log(colors.yellow('âš ') + ` Couldn't update source file: ${error.message}`);
      return { success: false, error: `Failed to update source file: ${error.message}` };
    }
  }

  // Delete from database
  db.prepare('DELETE FROM time_logs WHERE id = ?').run(currentEntry.id);

  return { success: true };
}

// Remove a line from a markdown time-tracking source file
async function removeMarkdownSourceLine(entry) {
  try {
    const entryId = entry.id;
    if (!entryId || !entryId.includes(':')) {
      throw new Error('Invalid entry ID format');
    }

    const parts = entryId.split(':');
    if (parts.length < 3) {
      throw new Error('Invalid entry ID format - expected source:path:line');
    }

    const filePath = parts.slice(1, -1).join(':');
    const lineNum = parseInt(parts[parts.length - 1]);

    if (isNaN(lineNum)) {
      throw new Error('Invalid line number in entry ID');
    }

    const fullFilePath = path.join(PROJECT_ROOT, filePath);

    const fs = await import('fs');
    if (!fs.existsSync(fullFilePath)) {
      throw new Error(`Source file not found: ${filePath}`);
    }

    const content = fs.readFileSync(fullFilePath, 'utf8');
    const lines = content.split('\n');

    if (lineNum >= lines.length) {
      throw new Error(`Line ${lineNum} does not exist in file`);
    }

    // Verify the line matches the entry (check start_time and a portion of description)
    const currentLine = lines[lineNum];
    const descPrefix = entry.description ? entry.description.split(' #')[0].substring(0, 15) : '';
    if (descPrefix && !currentLine.includes(descPrefix)) {
      throw new Error('Source line does not match entry - file may have changed');
    }

    // Remove the line
    lines.splice(lineNum, 1);

    const updatedContent = lines.join('\n');
    fs.writeFileSync(fullFilePath, updatedContent, 'utf8');

    return { success: true, filePath, lineNum };

  } catch (error) {
    throw new Error(`Failed to remove source line: ${error.message}`);
  }
}

// Commander setup
program
  .name('track')
  .description('Time tracking for Today system');

program
  .command('start')
  .description('Start tracking time (include #topic/tags in description)')
  .argument('<description...>', 'Description with #topic/tags')
  .option('--source <source>', 'Plugin source to use')
  .action(async (descriptionParts, options) => {
    await cmdStart(descriptionParts.join(' '), options);
  });

program
  .command('stop')
  .description('Stop current timer')
  .option('--source <source>', 'Plugin source filter')
  .action(async (options) => {
    await cmdStop(options);
  });

program
  .command('restart')
  .description('Start a new timer with the same description as the last entry')
  .option('--source <source>', 'Plugin source to use')
  .action(async (options) => {
    await cmdRestart(options);
  });

program
  .command('add')
  .description('Add entry for work you forgot to track')
  .argument('<duration>', 'Duration (e.g., 20m, 1.5h, 2h30m)')
  .argument('<description...>', 'Description with #topic/tags')
  .option('--source <source>', 'Plugin source to use')
  .option('--start <time>', 'Start time (e.g., 9:00, 14:30, 9am, 2pm)')
  .action(async (duration, descriptionParts, options) => {
    await cmdAdd(duration, { ...options, _positional: descriptionParts });
  });

program
  .command('status', { isDefault: true })
  .description('Show current timer status')
  .action(async () => {
    await cmdStatus();
  });

program
  .command('today')
  .description('Show today\'s time entries')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    await cmdToday(options);
  });

program
  .command('yesterday')
  .description('Show yesterday\'s time entries')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    await cmdYesterday(options);
  });

program
  .command('week')
  .description('Show this week\'s time entries')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    await cmdWeek(options);
  });

program
  .command('day')
  .description('Show time entries for a specific date')
  .argument('<date>', 'Date in YYYY-MM-DD format')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (date, options) => {
    await cmdDate(date, options);
  });

program
  .command('sync')
  .description('Sync all time-logs plugins to database')
  .action(async () => {
    await cmdSync();
  });

program
  .command('audit')
  .description('Check for problematic time entries')
  .option('--all', 'Check all entries (not just recent)')
  .option('--days <days>', 'Check last N days (default: 30)', parseInt)
  .option('--daily', 'Perform daily sanity check (last 7 days, major issues only)')
  .option('--force', 'Force daily check even if already done today (requires --daily)')
  .option('--verbose', 'Show output even when no problems found (with --daily)')
  .action(async (options) => {
    await cmdAudit(options);
  });

program
  .command('fix')
  .description('Suggest and apply fixes for problematic time entries')
  .option('--days <days>', 'Check last N days (default: 30)', parseInt)
  .option('--dry-run', 'Show what would be fixed without making changes')
  .action(async (options) => {
    await cmdFix(options);
  });

// Handle --date option at top level (used by bin/today for historical queries)
const dateArgIdx = process.argv.findIndex(a => a === '--date');
if (dateArgIdx > 0 && process.argv[dateArgIdx + 1]) {
  const targetDate = process.argv[dateArgIdx + 1];
  const sourceArgIdx = process.argv.findIndex(a => a === '--source');
  const source = sourceArgIdx > 0 ? process.argv[sourceArgIdx + 1] : undefined;
  await cmdDate(targetDate, { source });
  process.exit(0);
}

program.parse();
