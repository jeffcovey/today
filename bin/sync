#!/usr/bin/env node

/**
 * Today - Full Data Sync (Node.js version)
 *
 * This is the new Node.js implementation of the sync system, ported from the
 * original bash version (bin/sync). This version is preferred for new development.
 *
 * Synchronizes all data sources for the Today system:
 * - Vault files (via Resilio Sync)
 * - Database (Turso)
 * - Task management
 * - Plan files cleanup
 * - Inbox processing (Progress notes, Concern notes, Tasks)
 * - Email, Calendar, Contacts, Time tracking
 * - OGM monitoring
 */

import fs from 'fs';
import { execSync, spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

// Change to project root
process.chdir(projectRoot);

// ============================================================================
// Utility Functions
// ============================================================================

function printStatus(message) {
  console.log(chalk.green(`âœ“ ${message}`));
}

function printError(message) {
  console.error(chalk.red(`âœ— ${message}`));
}

function printInfo(message) {
  console.log(chalk.blue(`â„¹ ${message}`));
}

function printWarning(message) {
  console.log(chalk.yellow(`âš  ${message}`));
}

function printHeader(message) {
  console.log('');
  console.log(chalk.blue('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(chalk.blue.bold(message));
  console.log(chalk.blue('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
}

// ============================================================================
// Plan File Cleanup Functions
// ============================================================================

/**
 * Clean up routine sections in old plan files
 * 1. Makes callouts open instead of collapsed
 * 2. Adds completion percentage to headers
 * 3. Replaces content with "Undone:" list of incomplete tasks
 * 4. Fixes "Completed Today" section to use specific date
 */
async function cancelOldPlanTasks(specificFile = null) {
  printInfo(specificFile ? `Processing specific file: ${specificFile}` : 'Checking for old plan files to clean up...');

  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

  // Calculate one week ago (we only clean files from the last week)
  const oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  const weekAgoDate = oneWeekAgo.toISOString().split('T')[0]; // YYYY-MM-DD

  // Find all plan files or use specific file
  let planFiles = [];
  if (specificFile) {
    planFiles = [specificFile];
  } else {
    try {
      const result = execSync(
        'find vault/plans -type f -name "2*_Q*_*_W*_*.md" 2>/dev/null | sort',
        { encoding: 'utf8' }
      );
      planFiles = result.trim().split('\n').filter(Boolean);
    } catch {
      printInfo('No plan files found');
      return true;
    }
  }

  if (planFiles.length === 0) {
    printInfo('No plan files found');
    return true;
  }

  let modifiedFiles = 0;

  for (const file of planFiles) {
    // Extract date from filename (format: YYYY_Q#_MM_W##_DD.md)
    const basename = path.basename(file, '.md');
    const match = basename.match(/^(\d{4})_Q\d_(\d{2})_W\d+_(\d{2})$/);

    if (!match) continue;

    const [, year, month, day] = match;
    const fileDate = `${year}-${month}-${day}`;

    // Skip if this is today's file or in the future (unless processing specific file)
    if (!specificFile && fileDate >= today) {
      continue;
    }

    // Skip if file is older than one week (unless processing specific file)
    if (!specificFile && fileDate < weekAgoDate) {
      continue;
    }

    // Process the file
    if (await processRoutineSections(file, fileDate)) {
      modifiedFiles++;
    }
  }

  if (modifiedFiles > 0) {
    printInfo(`Cleaned up ${modifiedFiles} old plan file(s)`);
  } else {
    printInfo('No plan files needed cleanup');
  }

  return true;
}

/**
 * Process routine sections in a single plan file
 */
async function processRoutineSections(filePath, fileDate) {
  let content = fs.readFileSync(filePath, 'utf-8');
  let modified = false;

  // Process each routine section
  const sections = [
    { regex: /> \[!info\]-?\s*ðŸŒ… Morning Routine([\s\S]*?)(?=\n(?:>\s*\[!|###|##)|$)/i, name: 'ðŸŒ… Morning Routine', type: 'info' },
    { regex: /> \[!tip\]-?\s*ðŸƒ Hip Mobility Workout \(45 minutes\)([\s\S]*?)(?=\n(?:>\s*\[!|###|##)|$)/i, name: 'ðŸƒ Hip Mobility Workout (45 minutes)', type: 'tip' },
    { regex: /> \[!warning\]-?\s*ðŸŒ„ Evening Routine([\s\S]*?)(?=\n(?:>\s*\[!|###|##)|$)/i, name: 'ðŸŒ„ Evening Routine', type: 'warning' }
  ];

  for (const section of sections) {
    const result = processSection(content, section.regex, section.name, section.type);
    if (result.modified) {
      content = result.content;
      modified = true;
    }
  }

  // Fix the "Completed Today" section - use HTML markers if available, fallback to regex
  const completedTodayMarker = /<!-- COMPLETED_TODAY:.*?-->\n## âœ… Completed Today[\s\S]*?```tasks\n\s*done today\n/;
  if (content.match(completedTodayMarker)) {
    content = content.replace(
      completedTodayMarker,
      `<!-- COMPLETED_TODAY: Auto-updated with specific date after day completes -->\n## âœ… Completed Today\n\n- âœ… Completed Tasks\n\n  \`\`\`tasks\n  done on ${fileDate}\n`
    );
    modified = true;
  } else {
    // Fallback for old files without markers
    const dateRegex = /## âœ… Completed Today\n\n- âœ… Completed Tasks\n\n\s*```tasks\n\s*done today\n/;
    if (content.match(dateRegex)) {
      content = content.replace(
        dateRegex,
        `## âœ… Completed Today\n\n- âœ… Completed Tasks\n\n  \`\`\`tasks\n  done on ${fileDate}\n`
      );
      modified = true;
    }
  }

  // Remove "Due or Scheduled Today" section using HTML markers (cleaner)
  const dueScheduledMarker = /<!-- DUE_TODAY:.*?-->[\s\S]*?<!-- \/DUE_TODAY -->\n*/g;
  if (content.match(dueScheduledMarker)) {
    content = content.replace(dueScheduledMarker, '');
    modified = true;
  } else {
    // Fallback for old files without markers
    const dueScheduledRegex = /> \[!note\]-?\s*ðŸ“… Due or Scheduled Today\n>\n> ```tasks\n> not done\n> \(scheduled before tomorrow\) OR \(due before tomorrow\)\n> sort by priority\n> group by happens\n> ```\n*/;
    if (content.match(dueScheduledRegex)) {
      content = content.replace(dueScheduledRegex, '');
      modified = true;
    }
  }

  // Remove "Draft Plan" section (legacy - for very old files)
  const draftPlanRegex = /> \[!info\] Draft Plan\n> This is a preliminary plan.*\n\n/;
  if (content.match(draftPlanRegex)) {
    content = content.replace(draftPlanRegex, '');
    modified = true;
  }

  // Remove day-specific time block sections (Morning, Afternoon, Evening)
  // These are planning details that aren't needed once the day is complete

  // First, try to remove using HTML comment markers (new template format)
  const dailyScheduleMarker = /<!-- DAILY_SCHEDULE:.*?-->[\s\S]*?<!-- \/DAILY_SCHEDULE -->\n*/g;
  if (content.match(dailyScheduleMarker)) {
    content = content.replace(dailyScheduleMarker, '');
    modified = true;
  }

  // Also remove individual time block sections (for older files without markers)
  // This provides backward compatibility with files created before the template update
  const lines = content.split('\n');
  const filteredLines = [];
  let inTimeBlock = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check if we're starting a time block section
    if (line.match(/^### (?:Morning|Afternoon|Evening)(?:\s|$)/)) {
      inTimeBlock = true;
      modified = true;
      continue; // Skip this line
    }

    // Check if we're ending the time block (new heading or callout)
    if (inTimeBlock && (line.match(/^##[^#]/) || line.match(/^> \[!/))) {
      inTimeBlock = false;
      filteredLines.push(line);
      continue;
    }

    // Skip lines while in time block
    if (inTimeBlock) {
      continue;
    }

    // Keep all other lines
    filteredLines.push(line);
  }

  if (modified) {
    content = filteredLines.join('\n');
  }

  if (modified) {
    fs.writeFileSync(filePath, content, 'utf-8');
    return true;
  }

  return false;
}

/**
 * Process a single routine section
 */
function processSection(content, sectionRegex, sectionName, calloutType) {
  const match = content.match(sectionRegex);
  if (!match) {
    return { content, modified: false };
  }

  const sectionContent = match[1];

  // Skip if this section has already been processed (has "Undone:" marker)
  if (sectionContent.includes('**Undone:**')) {
    return { content, modified: false };
  }

  const lines = sectionContent.split('\n');

  // Count tasks
  let totalTasks = 0;
  let completedTasks = 0;
  const undoneTasks = [];

  for (const line of lines) {
    if (line.match(/^>\s*-\s*\[./)) {
      totalTasks++;
      if (line.match(/^>\s*-\s*\[x\]/i)) {
        completedTasks++;
      } else {
        // Extract task text (remove checkbox and > prefix)
        const taskText = line.replace(/^>\s*-\s*\[.\]\s*/, '').trim();
        if (taskText) {
          undoneTasks.push(taskText);
        }
      }
    }
  }

  if (totalTasks === 0) {
    return { content, modified: false };
  }

  const percentage = Math.round((completedTasks / totalTasks) * 100);

  // Build new section
  let newSection = `> [!${calloutType}] ${sectionName} (${percentage}% done)\n`;

  if (undoneTasks.length > 0) {
    newSection += `>\n> **Undone:**\n>\n`;
    for (const task of undoneTasks) {
      newSection += `> - ${task}\n`;
    }
  } else {
    newSection += `>\n> All tasks completed! âœ…\n`;
  }

  content = content.replace(sectionRegex, newSection);
  return { content, modified: true };
}

// ============================================================================
// Database Sync
// ============================================================================

async function syncTursoBidirectional() {
  printInfo('Performing bidirectional sync with Turso...');

  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    printInfo('Turso not configured (need TURSO_DATABASE_URL and TURSO_AUTH_TOKEN)');
    return false;
  }

  try {
    execSync('bin/turso-sync sync', {
      stdio: 'pipe',
      timeout: 45000,
      encoding: 'utf8'
    });
    printInfo('Turso synced successfully');
    return true;
  } catch (error) {
    if (error.signal === 'SIGTERM') {
      printInfo('Turso sync timed out - continuing with local data');
      return true; // Don't fail
    }
    printError(`Turso sync failed: ${error.message}`);
    return false;
  }
}

async function cleanDatabaseTaskTitles() {
  printInfo('Database cleanup skipped (using Obsidian Tasks)');
  return true;
}

async function cleanPlanFileTasks() {
  printInfo('Cleaning tasks in plan files (removing date/recurrence properties)...');

  try {
    const result = execSync(
      'find vault/plans -type f -name "*.md" 2>/dev/null',
      { encoding: 'utf8' }
    );

    const planFiles = result.trim().split('\n').filter(Boolean);
    if (planFiles.length === 0) {
      printInfo('No plan files found');
      return true;
    }

    let cleanedCount = 0;
    let taskCount = 0;

    for (const file of planFiles) {
      const content = fs.readFileSync(file, 'utf-8');

      // Check if file has tasks with date/recurrence properties
      if (/^\s*-\s*\[[x ]\].*[ðŸ“…â³ðŸ”]/m.test(content)) {
        const lines = content.split('\n');
        let modified = false;

        const cleanedLines = lines.map(line => {
          if (/^\s*-\s*\[[x ]\].*[ðŸ“…â³ðŸ”]/.test(line)) {
            taskCount++;
            modified = true;
            // Remove date and recurrence properties (but keep âž• created date)
            return line
              .replace(/ðŸ“…\s*\d{4}-\d{2}-\d{2}/g, '')
              .replace(/â³\s*\d{4}-\d{2}-\d{2}/g, '')
              .replace(/ðŸ”\s*every\s+[a-zA-Z0-9 ,]+/g, '')
              .replace(/\s+/g, ' ')
              .replace(/\s+$/, '');
          }
          return line;
        });

        if (modified) {
          fs.writeFileSync(file, cleanedLines.join('\n'), 'utf-8');
          cleanedCount++;
        }
      }
    }

    if (cleanedCount > 0) {
      printInfo(`Cleaned ${taskCount} task(s) in ${cleanedCount} plan file(s)`);
    } else {
      printInfo('No tasks with date/recurrence properties found in plan files');
    }

    return true;
  } catch (error) {
    printError(`Failed to clean plan files: ${error.message}`);
    return false;
  }
}

// ============================================================================
// Process Inbox
// ============================================================================

async function processInbox() {
  printInfo('Processing inbox files...');

  const inboxDir = path.join(projectRoot, 'vault/notes/inbox');

  // Create inbox directory if it doesn't exist
  if (!fs.existsSync(inboxDir)) {
    fs.mkdirSync(inboxDir, { recursive: true });
  }

  try {
    const files = fs.readdirSync(inboxDir).filter(f => f.endsWith('.md'));

    if (files.length === 0) {
      printInfo('No files in inbox to process');
      return true;
    }

    printInfo(`Processing ${files.length} file(s) from inbox...`);

    for (const filename of files) {
      const filePath = path.join(inboxDir, filename);
      await processInboxFile(filePath);
    }

    return true;
  } catch (error) {
    printError(`Inbox processing failed: ${error.message}`);
    return false;
  }
}

async function processInboxFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');
  const firstLine = lines[0] || '';
  const title = firstLine.replace(/^#\s*/, '').replace(/^-\s*\[\s*\]\s*/, '');
  const basename = path.basename(filePath);

  // Progress notes
  if (title === 'Progress') {
    return processProgressNote(filePath, content, basename);
  }

  // Concern notes
  if (title === 'Concerns' || basename.includes('concerns')) {
    return processConcernNote(filePath, content, basename);
  }

  // Task files (only checkboxes)
  if (/^-\s*\[[x ]\]/m.test(content)) {
    const taskOnly = lines.every(line =>
      !line.trim() || /^-\s*\[[x ]\]/.test(line)
    );

    if (taskOnly) {
      return processTaskOnlyFile(filePath, content);
    }
  }

  // Default: move to general notes
  const destDir = path.join(projectRoot, 'vault/notes/general');
  fs.mkdirSync(destDir, { recursive: true });
  const destPath = path.join(destDir, basename);

  if (fs.existsSync(destPath)) {
    moveToTrash(filePath, 'duplicate');
    printInfo(`  â€¢ Duplicate file moved to trash: ${basename}`);
  } else {
    fs.renameSync(filePath, destPath);
    printInfo(`  â€¢ Note â†’ notes/general/${basename}`);
  }
}

function processProgressNote(filePath, content, basename) {
  // Parse date from content
  const dateMatch = content.match(/^[A-Za-z]+ \d+, \d+ \d+:\d+/m);

  if (!dateMatch) {
    printWarning(`  â€¢ Progress note missing date, leaving in inbox: ${basename}`);
    return;
  }

  const dateStr = dateMatch[0];
  const date = new Date(dateStr);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const week = getWeekNumber(date);
  const quarter = Math.ceil((date.getMonth() + 1) / 3);

  const planFile = `vault/plans/${year}_Q${quarter}_${month}_W${week}_${day}.md`;

  // Check if plan file exists
  if (!fs.existsSync(planFile)) {
    printWarning(`  â€¢ No plan file for ${year}-${month}-${day}`);
    printWarning(`  â€¢ Leaving in inbox - will be filed when plan file is created`);
    return;
  }

  // Clean content (remove title and blank lines)
  const cleanedLines = content.split('\n').slice(1).filter((line, i, arr) => {
    return i > 0 || line.trim(); // Skip leading blank lines
  });
  const cleanedContent = cleanedLines.join('\n');

  // Add to plan file with callout format
  const timestamp = dateStr.match(/\d+:\d+/)?.[0] || 'Unknown';

  // Format content with > prefix for callout
  const calloutContent = cleanedContent
    .split('\n')
    .map(line => line ? '> ' + line : '>')
    .join('\n');

  fs.appendFileSync(planFile, `\n<!-- PROGRESS_UPDATE -->\n> [!success] ðŸ“Š Progress Update (${timestamp})\n>\n${calloutContent}\n<!-- /PROGRESS_UPDATE -->\n`);

  printInfo(`  â€¢ Progress note â†’ Added to ${path.basename(planFile)}`);

  // Move to progress directory
  const destDir = path.join(projectRoot, 'vault/notes/progress');
  fs.mkdirSync(destDir, { recursive: true });

  const time = dateStr.match(/\d+:\d+/)?.[0].replace(':', '') || '0000';
  const destFile = `${year}-${month}-${day}-${time}00-UTC-progress.md`;
  const destPath = path.join(destDir, destFile);

  fs.writeFileSync(destPath, cleanedContent, 'utf-8');
  fs.unlinkSync(filePath);

  printInfo(`  â€¢ Filed to progress/${destFile}`);
}

function processConcernNote(filePath, content, basename) {
  // Similar to processProgressNote but for concerns
  const dateMatch = content.match(/^[A-Za-z]+ \d+, \d+ \d+:\d+/m);

  if (!dateMatch) {
    printWarning(`  â€¢ Concern note missing date, leaving in inbox: ${basename}`);
    return;
  }

  const dateStr = dateMatch[0];
  const date = new Date(dateStr);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const week = getWeekNumber(date);
  const quarter = Math.ceil((date.getMonth() + 1) / 3);

  const planFile = `vault/plans/${year}_Q${quarter}_${month}_W${week}_${day}.md`;

  if (!fs.existsSync(planFile)) {
    printWarning(`  â€¢ No plan file for ${year}-${month}-${day}`);
    printWarning(`  â€¢ Leaving in inbox - will be filed when plan file is created`);
    return;
  }

  const cleanedLines = content.split('\n').slice(1).filter((line, i) => {
    return i > 0 || line.trim();
  });
  const cleanedContent = cleanedLines.join('\n');

  // Add to plan file with callout format
  const timestamp = dateStr.match(/\d+:\d+/)?.[0] || 'Unknown';

  // Format content with > prefix for callout
  const calloutContent = cleanedContent
    .split('\n')
    .map(line => line ? '> ' + line : '>')
    .join('\n');

  fs.appendFileSync(planFile, `\n<!-- CONCERN -->\n> [!warning] âš ï¸ Concerns (${timestamp})\n>\n${calloutContent}\n<!-- /CONCERN -->\n`);

  printInfo(`  â€¢ Concern note â†’ Added to ${path.basename(planFile)}`);

  const destDir = path.join(projectRoot, 'vault/notes/concerns');
  fs.mkdirSync(destDir, { recursive: true });

  const time = dateStr.match(/\d+:\d+/)?.[0].replace(':', '') || '0000';
  const destFile = `${year}-${month}-${day}-${time}00-UTC-concerns.md`;
  const destPath = path.join(destDir, destFile);

  fs.writeFileSync(destPath, cleanedContent, 'utf-8');
  fs.unlinkSync(filePath);

  printInfo(`  â€¢ Filed to concerns/${destFile}`);
}

function processTaskOnlyFile(filePath, content) {
  const tasksFile = path.join(projectRoot, 'vault/tasks/tasks.md');

  // Append to tasks.md
  if (fs.existsSync(tasksFile)) {
    const existing = fs.readFileSync(tasksFile, 'utf-8');
    if (existing.includes('# Archive')) {
      // Insert before Archive section
      const parts = existing.split('# Archive');
      fs.writeFileSync(tasksFile, `${parts[0].trimEnd()}\n\n${content}\n\n# Archive${parts[1] || ''}`, 'utf-8');
    } else {
      fs.appendFileSync(tasksFile, `\n${content}\n`);
    }
  } else {
    fs.writeFileSync(tasksFile, content, 'utf-8');
  }

  const taskCount = (content.match(/^-\s*\[[x ]\]/gm) || []).length;
  printInfo(`  â€¢ Task-only file â†’ Added ${taskCount} task(s) to tasks.md`);

  moveToTrash(filePath, 'tasks-processed');
}

function moveToTrash(filePath, reason = 'processed') {
  const trashDir = path.join(projectRoot, 'vault/notes/.trash', new Date().toISOString().split('T')[0]);
  fs.mkdirSync(trashDir, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
  const basename = path.basename(filePath);
  const trashPath = path.join(trashDir, `${timestamp}-${basename}`);

  fs.renameSync(filePath, trashPath);
}

function getWeekNumber(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

// ============================================================================
// Task and Topic Management
// ============================================================================

async function updateMarkdownCache() {
  printInfo('Updating markdown tasks cache...');

  try {
    execSync('node bin/tasks update-cache', {
      stdio: 'pipe',
      encoding: 'utf8'
    });
    printInfo('Task cache updated');
    return true;
  } catch (error) {
    printError(`Cache update failed: ${error.message}`);
    return false;
  }
}

async function generateTopicFiles() {
  printInfo('Generating topic files...');

  try {
    execSync('node bin/tasks generate-topics', {
      stdio: 'pipe',
      encoding: 'utf8'
    });
    printInfo('Topic files generated');
    return true;
  } catch (error) {
    printError(`Topic generation failed: ${error.message}`);
    return false;
  }
}

// ============================================================================
// External Sync Functions
// ============================================================================

function checkVaultExists() {
  printInfo('Vault directory exists - Resilio Sync handles synchronization');

  // Show content counts
  const noteCount = execSync('find vault/notes -type f -name "*.md" 2>/dev/null | wc -l', {
    encoding: 'utf8'
  }).trim();
  const planCount = execSync('find vault/plans -type f -name "*.md" 2>/dev/null | wc -l', {
    encoding: 'utf8'
  }).trim();
  const projectCount = execSync('find vault/projects -type f -name "*.md" 2>/dev/null | wc -l', {
    encoding: 'utf8'
  }).trim();
  const topicCount = execSync('find vault/topics -type f -name "*.md" 2>/dev/null | wc -l', {
    encoding: 'utf8'
  }).trim();

  printInfo(`Total notes: ${noteCount}, plans: ${planCount}, projects: ${projectCount}, topics: ${topicCount}`);

  return true;
}

function cleanupSyncConflicts() {
  printInfo('Checking for sync-conflict files...');

  try {
    const conflictFiles = execSync('find vault -name "*sync-conflict-*" -type f 2>/dev/null', {
      encoding: 'utf8'
    })
      .trim()
      .split('\n')
      .filter(f => f);

    if (conflictFiles.length === 0) {
      printInfo('No sync-conflict files found');
      return true;
    }

    printInfo(`Found ${conflictFiles.length} sync-conflict file(s)`);
    let removedCount = 0;

    for (const conflictFile of conflictFiles) {
      // Extract original filename
      const originalFile = conflictFile.replace(/\.sync-conflict-\d{8}-\d{6}-[A-Z0-9]{7}/, '');

      if (fs.existsSync(originalFile)) {
        // Compare files
        try {
          execSync(`diff -q "${originalFile}" "${conflictFile}"`, { stdio: 'ignore' });
          // Files are identical
          fs.unlinkSync(conflictFile);
          removedCount++;
          printInfo(`  âœ“ Removed duplicate: ${path.basename(conflictFile)}`);
        } catch {
          // Files differ, check timestamps
          const originalStat = fs.statSync(originalFile);
          const conflictStat = fs.statSync(conflictFile);

          if (conflictStat.mtimeMs < originalStat.mtimeMs) {
            fs.unlinkSync(conflictFile);
            removedCount++;
            printInfo(`  âœ“ Removed older conflict: ${path.basename(conflictFile)}`);
          }
        }
      } else {
        // Original doesn't exist, restore conflict file
        fs.renameSync(conflictFile, originalFile);
        removedCount++;
        printInfo(`  âœ“ Restored missing file: ${path.basename(originalFile)}`);
      }
    }

    if (removedCount > 0) {
      printInfo(`Cleaned up ${removedCount} sync-conflict file(s)`);
    }

    return true;
  } catch (error) {
    printError(`Conflict cleanup failed: ${error.message}`);
    return false;
  }
}

function cleanMarkdownFiles() {
  printInfo('Cleaning markdown files with markdownlint...');

  try {
    // Run markdownlint on all markdown files
    // MD009 (no-trailing-spaces) is disabled to preserve double-space line breaks
    execSync('npx markdownlint-cli2 --fix "vault/**/*.md"', {
      stdio: 'pipe'
    });
    printInfo('All markdown files are clean');
    return true;
  } catch (error) {
    // markdownlint returns non-zero if it fixed files
    printInfo('Fixed formatting in markdown files');
    return true;
  }
}

function syncEmail() {
  printInfo('Syncing email...');

  // Check for email binary
  const emailBin = fs.existsSync('bin/email') ? 'bin/email' : fs.existsSync('bin/email-cli') ? 'bin/email-cli' : null;

  if (!emailBin) {
    printError('Email CLI not available');
    return false;
  }

  try {
    execSync(`${emailBin} download --days 7`, { stdio: 'pipe', timeout: 60000 });
    printInfo('Email synced');
    return true;
  } catch (error) {
    printError(`Email sync failed: ${error.message}`);
    return false;
  }
}

function syncPobox() {
  printInfo('Syncing Pobox sent mail...');

  try {
    execSync('bin/pobox-sync', { stdio: 'pipe', timeout: 60000 });
    printInfo('Pobox synced');
    return true;
  } catch (error) {
    printError(`Pobox sync failed: ${error.message}`);
    return false;
  }
}

function syncCalendar() {
  printInfo('Syncing calendar events...');

  try {
    const output = execSync('bin/calendar sync', { encoding: 'utf8' });
    if (output.includes('âœ…')) {
      printInfo('Calendar synced');

      // Export calendar events to JSON for Obsidian dashboard
      try {
        execSync('mkdir -p vault/logs/sync && sqlite3 .data/today.db "SELECT json_object(\'title\', title, \'start\', start_date, \'end\', end_date, \'location\', location) FROM calendar_events WHERE date(start_date) >= date(\'now\') AND date(start_date) <= date(\'now\', \'+2 days\') ORDER BY start_date ASC LIMIT 10" | jq -s \'.\' > vault/logs/sync/calendar-events.json', { encoding: 'utf8' });
        printInfo('Calendar events exported to vault');
      } catch (exportError) {
        printWarning('Calendar export to vault failed (this is non-critical)');
      }

      return true;
    }
    return false;
  } catch (error) {
    printError(`Calendar sync failed: ${error.message}`);
    return false;
  }
}

function cleanupTimeBlocking() {
  printInfo('Cleaning up Time Blocking calendar...');

  // Get Time Blocking calendar ID from environment
  const timeBlockingCalendar = process.env.TIME_BLOCKING_CALENDAR_ID || 'e1jdfoki06hfrg8kh55mn9kvvs@group.calendar.google.com';

  try {
    // Keep yesterday (1 day) so we can review planned vs. actual
    execSync(`bin/calendar cleanup "${timeBlockingCalendar}" 1`, { stdio: 'pipe' });
    printInfo('Time blocking cleaned');
    return true;
  } catch (error) {
    printError(`Time blocking cleanup failed: ${error.message}`);
    return false;
  }
}

function syncTimeTrackingCalendar() {
  printInfo('Syncing time tracking to calendar...');

  try {
    execSync('bin/calendar sync-time-tracking', { stdio: 'pipe' });
    printInfo('Time tracking synced to calendar');
    return true;
  } catch (error) {
    printError(`Time tracking calendar sync failed: ${error.message}`);
    return false;
  }
}

function syncContacts() {
  printInfo('Syncing contacts...');

  try {
    execSync('bin/contacts sync', { stdio: 'pipe', timeout: 60000 });
    printInfo('Contacts synced');
    return true;
  } catch (error) {
    printError(`Contacts sync failed: ${error.message}`);
    return false;
  }
}

function syncDiary() {
  if (!fs.existsSync('vault/logs/Journal.json')) {
    return true; // Skip if no diary
  }

  printInfo('Syncing Day One diary...');

  try {
    execSync('bin/diary sync', { stdio: 'pipe' });
    printInfo('Diary synced');
    return true;
  } catch (error) {
    printError(`Diary sync failed: ${error.message}`);
    return false;
  }
}

function syncTimeTracking() {
  printInfo('Syncing time tracking...');

  try {
    execSync('bin/time-tracking sync', { stdio: 'pipe' });
    printInfo('Time tracking synced');
    return true;
  } catch (error) {
    printError(`Time tracking sync failed: ${error.message}`);
    return false;
  }
}

function syncOgmMonitoring() {
  printInfo('Syncing OGM monitoring...');

  try {
    execSync('bin/ogm-sync', { stdio: 'pipe', timeout: 60000 });
    printInfo('OGM data synced');
    return true;
  } catch (error) {
    printError(`OGM monitoring sync failed: ${error.message}`);
    return false;
  }
}

// ============================================================================
// Main Sync Orchestration
// ============================================================================

async function runSyncStep(header, func, successMsg) {
  printHeader(header);
  const startTime = Date.now();

  try {
    const result = await func();
    if (result) {
      printStatus(successMsg);
    } else {
      printError(`${successMsg} - returned false`);
    }
  } catch (error) {
    printError(`${successMsg} failed: ${error.message}`);
  }

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  printInfo(`â±ï¸  Took ${elapsed} seconds`);
}

async function main() {
  console.log('');
  console.log(chalk.blue('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.blue('â•‘       TODAY - Full Data Sync          â•‘'));
  console.log(chalk.blue('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log('');
  console.log('Synchronizing all data sources...');
  console.log(`Started at: ${new Date().toISOString().replace('T', ' ').split('.')[0]}`);
  console.log('');

  printInfo('Running all sync operations synchronously...');

  // Critical path operations
  await runSyncStep('â˜ï¸  Turso Sync', syncTursoBidirectional, 'Turso synced');
  await runSyncStep('ðŸ“ Vault Check', checkVaultExists, 'Vault directory verified');
  await runSyncStep('ðŸ—‘ï¸  Cleanup Conflicts', cleanupSyncConflicts, 'Sync conflicts cleaned');
  await runSyncStep('ðŸ§¹ Clean Markdown', cleanMarkdownFiles, 'Markdown cleaned');
  await runSyncStep('ðŸ—„ï¸  Clean Database', cleanDatabaseTaskTitles, 'Database cleaned');
  await runSyncStep('ðŸ“‹ Clean Plan Tasks', cleanPlanFileTasks, 'Plan tasks cleaned');
  await runSyncStep('ðŸ—“ï¸  Cancel Old Plan Tasks', cancelOldPlanTasks, 'Old plan tasks canceled');
  await runSyncStep('ðŸ“¥ Process Inbox', processInbox, 'Inbox processed');

  // Update markdown tasks cache and regenerate topic files
  await runSyncStep('ðŸ—„ï¸  Update Task Cache', updateMarkdownCache, 'Task cache updated');
  await runSyncStep('ðŸ“‚ Generate Topics', generateTopicFiles, 'Topic files generated');

  // Task classification (run in background)
  printInfo('ðŸ” Starting task classification for markdown files...');
  const classifyPid = spawn('bash', ['-c', `
    bin/tasks add-date-added && \
    bin/tasks classify-stages && \
    bin/tasks add-topics && \
    bin/tasks prioritize-status
  `], { detached: true, stdio: 'ignore' });
  classifyPid.unref();
  printInfo(`   Classification running in background (PID: ${classifyPid.pid})`);

  // Email sync (if configured)
  if (fs.existsSync('.env') && fs.readFileSync('.env', 'utf8').includes('EMAIL_ACCOUNT=')) {
    await runSyncStep('ðŸ“§ Email Sync', syncEmail, 'Email synced');
  }

  // Pobox sync (if configured)
  if (fs.existsSync('.env') && fs.readFileSync('.env', 'utf8').includes('POBOX_ACCOUNT=')) {
    await runSyncStep('ðŸ“¤ Pobox Sent Mail', syncPobox, 'Sent emails synced');
  }

  // Calendar sync
  await runSyncStep('ðŸ“… Calendar Sync', syncCalendar, 'Calendar synced');
  await runSyncStep('ðŸ—‘ï¸  Cleanup Time Blocking', cleanupTimeBlocking, 'Time blocking cleaned');
  await runSyncStep('â±ï¸  Sync Time Tracking to Calendar', syncTimeTrackingCalendar, 'Time tracking synced to calendar');

  // Contacts sync
  await runSyncStep('ðŸ‘¥ Contacts Sync', syncContacts, 'Contacts synced');

  // Diary sync (if Journal.json exists)
  if (fs.existsSync('vault/logs/Journal.json')) {
    await runSyncStep('ðŸ“” Day One Diary', syncDiary, 'Diary synced');
  }

  // Time tracking sync
  await runSyncStep('â±ï¸  Time Tracking Sync', syncTimeTracking, 'Time tracking synced');

  // OGM monitoring (if configured)
  if (fs.existsSync('.env') && (fs.readFileSync('.env', 'utf8').includes('GITHUB_ACCESS_TOKEN=') || fs.readFileSync('.env', 'utf8').includes('SENTRY_AUTH_TOKEN='))) {
    await runSyncStep('ðŸŒ OGM Monitoring', syncOgmMonitoring, 'OGM data synced');
  }

  printStatus('All sync operations completed!');
  console.log('');
  console.log(`Completed at: ${new Date().toISOString().replace('T', ' ').split('.')[0]}`);
  console.log('');
  console.log('Next step: Run \'bin/today\' to get AI suggestions on what to do today');
}

// ============================================================================
// Command Line Interface
// ============================================================================

const args = process.argv.slice(2);
const command = args[0];

switch (command) {
  case '--cancel-old-plan-tasks':
    // Optional: pass a specific file path as second argument
    printHeader('ðŸ—“ï¸ Cancel Old Plan Tasks');
    cancelOldPlanTasks(args[1])
      .then(() => {
        printStatus('Old plan tasks processed successfully!');
        process.exit(0);
      })
      .catch((error) => {
        printError(`Old plan task cancellation failed: ${error.message}`);
        process.exit(1);
      });
    break;

  case '--vault':
    // Check vault and process inbox
    (async () => {
      await runSyncStep('ðŸ“ Vault Check', checkVaultExists, 'Vault directory verified');

      if (!process.env.SKIP_MARKDOWN_CLEAN) {
        await runSyncStep('ðŸ§¹ Clean Markdown', cleanMarkdownFiles, 'Markdown cleaned');
      }

      await runSyncStep('ðŸ“¥ Process Inbox', processInbox, 'Inbox processed');
      process.exit(0);
    })();
    break;

  case '--quick':
    // Quick sync - only critical sources
    printInfo('Quick sync mode - vault, inbox, and Turso');
    (async () => {
      checkVaultExists();
      await cleanupSyncConflicts();
      await cleanMarkdownFiles();
      await cleanDatabaseTaskTitles();
      await cleanPlanFileTasks();
      await processInbox();
      await syncTursoBidirectional();
      printStatus('Quick sync completed!');
      process.exit(0);
    })();
    break;

  case '--cleanup-conflicts':
    // Only cleanup sync-conflict files
    printHeader('ðŸ—‘ï¸  Cleanup Sync Conflicts');
    cleanupSyncConflicts()
      .then(() => {
        printStatus('Sync conflicts cleaned successfully!');
        process.exit(0);
      })
      .catch((error) => {
        printError(`Sync conflict cleanup failed: ${error.message}`);
        process.exit(1);
      });
    break;

  case '--process-inbox-only':
    // Only process inbox files
    printHeader('ðŸ“¥ Process Inbox Only');
    processInbox()
      .then(() => {
        printStatus('Inbox processed successfully!');
        process.exit(0);
      })
      .catch((error) => {
        printError(`Inbox processing failed: ${error.message}`);
        process.exit(1);
      });
    break;

  case '--quick-email':
    // Just sync last day of email quickly
    printHeader('ðŸ“§ Quick Email Sync');
    const emailBin = fs.existsSync('bin/email')
      ? 'bin/email'
      : fs.existsSync('bin/email-cli')
      ? 'bin/email-cli'
      : null;
    if (emailBin) {
      printInfo('Downloading emails from last 24 hours...');
      try {
        execSync(`${emailBin} download --days 1`, {
          stdio: 'inherit',
          timeout: 30000
        });
        printStatus('Quick email sync complete');
        process.exit(0);
      } catch (error) {
        printError('Email CLI not found');
        process.exit(1);
      }
    } else {
      printError('Email CLI not found');
      process.exit(1);
    }
    break;

  case '--help':
  case '-h':
    console.log(`
${chalk.bold('Today - Full Data Sync')}

${chalk.gray('Usage:')}
  bin/sync                              Run full sync
  bin/sync --cancel-old-plan-tasks      Clean up old plan files
  bin/sync --cancel-old-plan-tasks FILE Clean up specific plan file
  bin/sync --cleanup-conflicts          Remove duplicate sync-conflict files
  bin/sync --vault                      Check vault and process inbox
  bin/sync --quick                      Quick sync (tasks and inbox only)
  bin/sync --process-inbox-only         Only process inbox files
  bin/sync --quick-email                Download last 24 hours of email
  bin/sync --help                       Show this help

${chalk.gray('Description:')}
  Synchronizes all data sources for the Today system including vault files,
  database, task management, and plan file cleanup.

${chalk.gray('Data sources synced:')}
  â€¢ Vault files (via Resilio Sync)
  â€¢ Markdown formatting cleanup
  â€¢ Local task manager
  â€¢ Email inbox
  â€¢ Calendar events
  â€¢ Contacts
  â€¢ Inbox processing
  â€¢ Local cache
    `);
    process.exit(0);
    break;

  default:
    // No arguments or unrecognized - run full sync
    main().catch((error) => {
      printError(`Sync failed: ${error.message}`);
      console.error(error.stack);
      process.exit(1);
    });
}
