#!/usr/bin/env node

// Calendar integration script for Google Calendar and iCloud
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';
import https from 'https';
import http from 'http';
import { google } from 'googleapis';
import { getDatabase } from '../src/database-service.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DB_PATH = path.join(__dirname, '..', '.data', 'today.db');

class CalendarSync {
  constructor() {
    this.events = [];
    this.db = getDatabase();
    this.initDatabase();

    // Get timezone from config.toml
    try {
      this.defaultTimezone = execSync('bin/get-config timezone', { encoding: 'utf-8' }).trim();
    } catch (error) {
      console.warn('Warning: Could not read timezone from config.toml, using America/New_York');
      this.defaultTimezone = 'America/New_York';
    }
  }
  
  initDatabase() {
    // Ensure calendar_events table exists
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS calendar_events (
        id TEXT PRIMARY KEY,
        source TEXT NOT NULL,
        calendar_name TEXT,
        title TEXT NOT NULL,
        start_date DATETIME NOT NULL,
        end_date DATETIME NOT NULL,
        start_timezone TEXT,
        end_timezone TEXT,
        location TEXT,
        description TEXT,
        all_day BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE INDEX IF NOT EXISTS idx_calendar_events_start_date ON calendar_events(start_date);
      CREATE INDEX IF NOT EXISTS idx_calendar_events_end_date ON calendar_events(end_date);
    `);
  }

  // Google Calendar integration
  async syncGoogleCalendar() {
    try {
      // Check for calendar configuration
      const calendarIds = process.env.GOOGLE_CALENDAR_IDS || process.env.GOOGLE_CALENDAR_ID;
      
      if (!calendarIds) {
        console.log('‚ö†Ô∏è  Google Calendar not configured');
        console.log('   Need GOOGLE_CALENDAR_IDS in .env');
        console.log('   Run "bin/setup --calendar" for setup instructions');
        return [];
      }

      // Parse multiple calendar IDs (comma-separated)
      const calendars = calendarIds.split(',').map(id => id.trim()).filter(Boolean);
      
      // Get service account credentials - either from base64 env var or file
      let auth;
      
      if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        // Use base64-encoded key from environment variable
        console.log('üìÖ Using embedded service account key...');
        const keyJson = Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY, 'base64').toString('utf-8');
        const credentials = JSON.parse(keyJson);
        
        auth = new google.auth.GoogleAuth({
          credentials,
          scopes: ['https://www.googleapis.com/auth/calendar.readonly'],
        });
      } else if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH) {
        // Fall back to file path
        const keyPath = process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH;
        const keyFilePath = path.resolve(keyPath);
        
        try {
          await fs.access(keyFilePath);
        } catch {
          console.log('‚ö†Ô∏è  Google Calendar service account key file not found:', keyPath);
          return [];
        }
        
        auth = new google.auth.GoogleAuth({
          keyFile: keyFilePath,
          scopes: ['https://www.googleapis.com/auth/calendar.readonly'],
        });
      } else {
        console.log('‚ö†Ô∏è  No Google service account credentials found');
        console.log('   Set GOOGLE_SERVICE_ACCOUNT_KEY (base64) or GOOGLE_SERVICE_ACCOUNT_KEY_PATH');
        return [];
      }

      console.log(`üìÖ Fetching events from ${calendars.length} calendar(s)...`);
      
      const calendar = google.calendar({ version: 'v3', auth });
      
      const now = new Date();
      const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      
      const allEvents = [];
      
      // Fetch events from each calendar
      for (const calendarId of calendars) {
        try {
          console.log(`   Fetching from calendar: ${calendarId}`);
          const response = await calendar.events.list({
            calendarId: calendarId === 'primary' ? 'primary' : calendarId,
            timeMin: now.toISOString(),
            timeMax: weekFromNow.toISOString(),
            singleEvents: true,
            orderBy: 'startTime',
          });

          const events = response.data.items || [];
          console.log(`   ‚úì Found ${events.length} events`);
          
          // Add calendar source to each event
          const calendarEvents = events.map(event => ({
            source: 'google',
            calendar: calendarId,
            id: event.id,
            title: event.summary || 'Untitled',
            start: event.start?.dateTime || event.start?.date,
            end: event.end?.dateTime || event.end?.date,
            startTimeZone: event.start?.timeZone || null,  // Preserve original timezone
            endTimeZone: event.end?.timeZone || null,      // Preserve original timezone
            location: event.location,
            description: event.description,
            allDay: !event.start?.dateTime
          }));
          
          allEvents.push(...calendarEvents);
        } catch (error) {
          if (error.message?.includes('Not Found')) {
            console.error(`   ‚ùå Calendar "${calendarId}" not found or not shared`);
          } else if (error.message?.includes('Forbidden')) {
            console.error(`   ‚ùå No permission for calendar "${calendarId}"`);
          } else {
            console.error(`   ‚ùå Error fetching from "${calendarId}": ${error.message}`);
          }
          // Continue with other calendars instead of returning
        }
      }
      
      console.log(`üìÖ Total: ${allEvents.length} events from Google Calendar`);
      return allEvents;
    } catch (error) {
      console.error('Error with Google Calendar setup:', error.message);
      return [];
    }
  }

  // iCloud Calendar integration (via CalDAV)
  async syncICloudCalendar() {
    try {
      // Check for iCloud credentials
      if (!process.env.ICLOUD_USERNAME || !process.env.ICLOUD_APP_PASSWORD) {
        console.log('‚ö†Ô∏è  iCloud Calendar not configured (need ICLOUD_USERNAME and ICLOUD_APP_PASSWORD)');
        console.log('   Get app-specific password at: https://appleid.apple.com/account/manage');
        return [];
      }

      console.log('üìÖ Fetching iCloud Calendar events...');
      
      // We'll use a simple CalDAV request for iCloud
      // This is a basic implementation - you might want to use a CalDAV library for production
      const username = process.env.ICLOUD_USERNAME;
      const password = process.env.ICLOUD_APP_PASSWORD;
      
      // iCloud CalDAV endpoint
      const caldavUrl = `https://caldav.icloud.com/${username}/calendars/`;
      
      // For now, return empty - full CalDAV implementation would go here
      console.log('‚ÑπÔ∏è  iCloud CalDAV integration pending full implementation');
      return [];
      
    } catch (error) {
      console.error('Error fetching iCloud Calendar:', error.message);
      return [];
    }
  }

  // Fetch remote iCal URL
  async fetchRemoteICal(url, name = 'Remote Calendar') {
    return new Promise((resolve) => {
      const client = url.startsWith('https') ? https : http;
      
      console.log(`   Fetching ${name}...`);
      
      const request = client.get(url, { timeout: 10000 }, (res) => {
        let data = '';
        
        res.on('data', (chunk) => {
          data += chunk;
        });
        
        res.on('end', () => {
          if (res.statusCode === 200) {
            const events = this.parseICalContent(data, name);
            console.log(`   ‚úì Found ${events.length} events from ${name}`);
            resolve(events);
          } else {
            console.error(`   ‚ùå Failed to fetch ${name}: HTTP ${res.statusCode}`);
            resolve([]);
          }
        });
      });
      
      request.on('error', (err) => {
        console.error(`   ‚ùå Error fetching ${name}: ${err.message}`);
        resolve([]);
      });
      
      request.on('timeout', () => {
        console.error(`   ‚ùå Timeout fetching ${name}`);
        request.destroy();
        resolve([]);
      });
    });
  }

  // Parse iCal content (shared by file and URL methods)
  parseICalContent(content, source = 'ical') {
    const events = [];
    
    // Basic iCal parsing (simplified but handles multi-line values)
    const lines = content.split(/\r?\n/);
    let currentEvent = null;
    let inEvent = false;
    let currentTimezone = null;
    
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      
      // Handle line continuations (lines starting with space or tab)
      while (i + 1 < lines.length && (lines[i + 1].startsWith(' ') || lines[i + 1].startsWith('\t'))) {
        line += lines[i + 1].substring(1);
        i++;
      }
      
      // Track timezone definitions
      if (line.startsWith('BEGIN:VTIMEZONE')) {
        // Parse timezone ID from next lines
        for (let j = i + 1; j < lines.length && !lines[j].startsWith('END:VTIMEZONE'); j++) {
          if (lines[j].startsWith('TZID:')) {
            currentTimezone = lines[j].substring(5);
            break;
          }
        }
      }
      
      if (line === 'BEGIN:VEVENT') {
        inEvent = true;
        currentEvent = { source };
      } else if (line === 'END:VEVENT' && currentEvent) {
        inEvent = false;
        
        // Only add events with title and start date
        if (currentEvent.title && currentEvent.start) {
          // Check if event is in the future or recent past (last 7 days)
          const eventDate = new Date(currentEvent.start);
          const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          
          if (eventDate >= weekAgo) {
            events.push(currentEvent);
          }
        }
        currentEvent = null;
      } else if (inEvent && currentEvent) {
        // Parse event properties
        const colonIndex = line.indexOf(':');
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex);
          const value = line.substring(colonIndex + 1);
          
          // Handle different property formats
          if (key.startsWith('SUMMARY')) {
            currentEvent.title = value.trim()
              .replace(/\\,/g, ',')
              .replace(/\\n/g, '\n')
              .replace(/\\\\/g, '\\');
          } else if (key.startsWith('DTSTART')) {
            // Check for timezone in the key (e.g., DTSTART;TZID=America/New_York)
            if (key.includes('TZID=')) {
              const tzMatch = key.match(/TZID=([^:;]+)/);
              if (tzMatch) {
                currentEvent.startTimeZone = tzMatch[1];
              }
            }
            currentEvent.start = this.parseICalDate(value.trim());
            currentEvent.allDay = !value.includes('T');
          } else if (key.startsWith('DTEND')) {
            // Check for timezone in the key
            if (key.includes('TZID=')) {
              const tzMatch = key.match(/TZID=([^:;]+)/);
              if (tzMatch) {
                currentEvent.endTimeZone = tzMatch[1];
              }
            }
            currentEvent.end = this.parseICalDate(value.trim());
          } else if (key.startsWith('LOCATION')) {
            currentEvent.location = value.trim()
              .replace(/\\,/g, ',')
              .replace(/\\n/g, '\n')
              .replace(/\\\\/g, '\\');
          } else if (key.startsWith('DESCRIPTION')) {
            currentEvent.description = value.trim()
              .replace(/\\,/g, ',')
              .replace(/\\n/g, '\n')
              .replace(/\\\\/g, '\\');
          } else if (key === 'UID') {
            currentEvent.id = value.trim();
          }
        }
      }
    }
    
    return events;
  }

  // Parse iCal/ICS format (for local calendar files)
  async parseICalFile(filePath) {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const events = this.parseICalContent(content, 'ical-file');
      return events;
    } catch (error) {
      console.error('Error parsing iCal file:', error.message);
      return [];
    }
  }

  parseICalDate(dateStr) {
    // Handle both DATE and DATE-TIME formats
    if (dateStr.length === 8) {
      // YYYYMMDD format
      return `${dateStr.slice(0,4)}-${dateStr.slice(4,6)}-${dateStr.slice(6,8)}`;
    } else if (dateStr.includes('T')) {
      // YYYYMMDDTHHMMSS format
      const date = dateStr.slice(0,8);
      const time = dateStr.slice(9,15);
      return `${date.slice(0,4)}-${date.slice(4,6)}-${date.slice(6,8)}T${time.slice(0,2)}:${time.slice(2,4)}:${time.slice(4,6)}`;
    }
    return dateStr;
  }

  // macOS Calendar app integration (if running on Mac)
  async syncMacCalendar() {
    try {
      // Check if we're on macOS
      if (process.platform !== 'darwin') {
        return [];
      }

      console.log('üìÖ Fetching macOS Calendar events...');
      
      // Use AppleScript to get calendar events
      const script = `
        set outputText to ""
        set todayDate to current date
        set weekFromNow to todayDate + (7 * days)
        
        tell application "Calendar"
          set allCalendars to calendars
          repeat with aCalendar in allCalendars
            set calendarName to name of aCalendar
            set theEvents to (every event of aCalendar whose start date ‚â• todayDate and start date ‚â§ weekFromNow)
            
            repeat with anEvent in theEvents
              set eventSummary to summary of anEvent
              set eventStart to start date of anEvent
              set eventEnd to end date of anEvent
              set eventLocation to location of anEvent
              
              set outputText to outputText & "EVENT:" & eventSummary & "|"
              set outputText to outputText & "START:" & eventStart & "|"
              set outputText to outputText & "END:" & eventEnd & "|"
              set outputText to outputText & "LOCATION:" & eventLocation & "|"
              set outputText to outputText & "CALENDAR:" & calendarName & "\\n"
            end repeat
          end repeat
        end tell
        
        return outputText
      `;
      
      const result = execSync(`osascript -e '${script}'`, { encoding: 'utf-8' });
      
      const events = [];
      const lines = result.split('\n').filter(line => line.trim());
      
      for (const line of lines) {
        const parts = line.split('|');
        const event = { source: 'macos-calendar' };
        
        for (const part of parts) {
          const [key, value] = part.split(':', 2);
          if (key === 'EVENT') event.title = value;
          if (key === 'START') event.start = value;
          if (key === 'END') event.end = value;
          if (key === 'LOCATION') event.location = value;
          if (key === 'CALENDAR') event.calendar = value;
        }
        
        if (event.title) {
          events.push(event);
        }
      }
      
      return events;
    } catch (error) {
      console.error('Error fetching macOS Calendar:', error.message);
      return [];
    }
  }

  // Main sync function
  async sync() {
    console.log('üîÑ Syncing calendar events...');
    
    const allEvents = [];
    
    // Try each calendar source
    const googleEvents = await this.syncGoogleCalendar();
    const icloudEvents = await this.syncICloudCalendar();
    const macEvents = await this.syncMacCalendar();
    
    // Check for local .ics files
    const localIcsPath = path.join(__dirname, '..', 'calendar.ics');
    if (await fs.access(localIcsPath).then(() => true).catch(() => false)) {
      console.log('üìÖ Found local calendar.ics file');
      const localEvents = await this.parseICalFile(localIcsPath);
      allEvents.push(...localEvents);
    }
    
    // Fetch public calendar URLs from configuration
    const calendarsConfigPath = path.join(__dirname, '..', 'config', 'calendars.json');
    try {
      const configContent = await fs.readFile(calendarsConfigPath, 'utf-8');
      const config = JSON.parse(configContent);
      
      if (config.public_calendars && config.public_calendars.length > 0) {
        console.log(`üìÖ Fetching ${config.public_calendars.length} public calendar(s)...`);
        
        // Fetch all public calendars in parallel
        const publicCalendarPromises = config.public_calendars
          .filter(cal => cal.enabled !== false)
          .map(cal => this.fetchRemoteICal(cal.url, cal.name));
        
        const publicCalendarResults = await Promise.all(publicCalendarPromises);
        
        // Flatten and add to all events
        for (const events of publicCalendarResults) {
          allEvents.push(...events);
        }
      }
    } catch (error) {
      // Config file doesn't exist or is invalid - that's OK
      if (error.code !== 'ENOENT') {
        console.log('   Note: calendars.json not found or invalid');
      }
    }
    
    // Combine all events
    allEvents.push(...googleEvents, ...icloudEvents, ...macEvents);
    
    // Sort by start time
    allEvents.sort((a, b) => {
      const dateA = new Date(a.start || 0);
      const dateB = new Date(b.start || 0);
      return dateA - dateB;
    });
    
    // Save to database
    const insertEvent = this.db.prepare(`
      INSERT OR REPLACE INTO calendar_events (
        id, source, calendar_name, title, start_date, end_date,
        start_timezone, end_timezone, location, description, all_day, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
    `);
    
    // Clear old events and insert new ones in a transaction
    const syncEvents = this.db.transaction(() => {
      // Delete events older than 1 year or future events beyond 1 year
      this.db.prepare(`
        DELETE FROM calendar_events 
        WHERE start_date < datetime('now', '-1 year')
           OR start_date > datetime('now', '+1 year')
      `).run();
      
      // Insert all events
      for (const event of allEvents) {
        insertEvent.run(
          event.id || `${event.source}-${event.title}-${event.start}`,
          event.source || 'unknown',
          event.calendar || null,
          event.title,
          event.start,
          event.end || event.start,
          event.startTimeZone || null,
          event.endTimeZone || null,
          event.location || null,
          event.description || null,
          event.allDay ? 1 : 0
        );
      }
    });
    
    syncEvents();
    
    if (allEvents.length > 0) {
      console.log(`‚úÖ Synced ${allEvents.length} calendar events`);
    } else {
      console.log(`‚ö†Ô∏è  No calendar events found - please configure at least one calendar source`);
      console.log(`   Run 'bin/setup --calendar' for setup instructions`);
      return allEvents; // Return empty array but don't claim success
    }
    
    // Show today's events
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const todayEvents = allEvents.filter(event => {
      const eventDate = new Date(event.start);
      return eventDate >= today && eventDate < tomorrow;
    });
    
    if (todayEvents.length > 0) {
      console.log(`\nüìÜ Today's events:`);
      for (const event of todayEvents) {
        const time = new Date(event.start).toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit' 
        });
        console.log(`  ${event.allDay ? 'All day' : time}: ${event.title}`);
        if (event.location) console.log(`    üìç ${event.location}`);
      }
    }
    
    return allEvents;
  }

  // Get events from database
  async getEventsForSummary() {
    try {
      return this.db.prepare(`
        SELECT * FROM calendar_events 
        WHERE start_date >= datetime('now', '-1 month')
          AND start_date <= datetime('now', '+6 months')
        ORDER BY start_date
      `).all().map(event => ({
        id: event.id,
        source: event.source,
        calendar: event.calendar_name,
        title: event.title,
        start: event.start_date,
        end: event.end_date,
        startTimeZone: event.start_timezone,
        endTimeZone: event.end_timezone,
        location: event.location,
        description: event.description,
        allDay: event.all_day === 1
      }));
    } catch (error) {
      console.error('Error getting calendar events from database:', error.message);
      return [];
    }
  }

  // Add event to Google Calendar
  async addGoogleEvent(eventDetails) {
    try {
      // Check for calendar configuration - use specified calendar or default
      let calendarId = eventDetails.calendarId;

      if (!calendarId) {
        calendarId = process.env.GOOGLE_CALENDAR_ID || process.env.GOOGLE_CALENDAR_IDS?.split(',')[0];
      }

      if (!calendarId) {
        throw new Error('Google Calendar not configured. Need GOOGLE_CALENDAR_ID in .env');
      }

      // Get service account credentials
      let auth;
      
      if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        const keyJson = Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY, 'base64').toString('utf-8');
        const credentials = JSON.parse(keyJson);
        
        auth = new google.auth.GoogleAuth({
          credentials,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH) {
        const keyPath = process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH;
        const keyFilePath = path.resolve(keyPath);
        
        auth = new google.auth.GoogleAuth({
          keyFile: keyFilePath,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else {
        throw new Error('No Google service account credentials found');
      }

      const calendar = google.calendar({ version: 'v3', auth });
      
      // Create the event
      const event = {
        summary: eventDetails.title,
        location: eventDetails.location,
        description: eventDetails.description,
        start: {
          dateTime: eventDetails.startDateTime,
          timeZone: eventDetails.timeZone || this.defaultTimezone,
        },
        end: {
          dateTime: eventDetails.endDateTime,
          timeZone: eventDetails.timeZone || this.defaultTimezone,
        },
      };

      const response = await calendar.events.insert({
        calendarId: calendarId,
        resource: event,
      });

      console.log(`‚úÖ Event created: ${response.data.htmlLink}`);
      return response.data;
    } catch (error) {
      console.error('‚ùå Error creating event:', error.message);
      throw error;
    }
  }

  // Delete event from Google Calendar
  async deleteGoogleEvent(eventId, calendarId = null) {
    try {
      if (!calendarId) {
        calendarId = process.env.GOOGLE_CALENDAR_ID || process.env.GOOGLE_CALENDAR_IDS?.split(',')[0];
      }

      if (!calendarId) {
        throw new Error('Google Calendar not configured. Need GOOGLE_CALENDAR_ID in .env');
      }

      // Get service account credentials
      let auth;
      
      if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        const keyJson = Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY, 'base64').toString('utf-8');
        const credentials = JSON.parse(keyJson);
        
        auth = new google.auth.GoogleAuth({
          credentials,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH) {
        const keyPath = process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH;
        const keyFilePath = path.resolve(keyPath);
        
        auth = new google.auth.GoogleAuth({
          keyFile: keyFilePath,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else {
        throw new Error('No Google service account credentials found');
      }

      const calendar = google.calendar({ version: 'v3', auth });
      
      await calendar.events.delete({
        calendarId: calendarId,
        eventId: eventId,
      });

      console.log(`‚úÖ Event deleted: ${eventId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Error deleting event:', error.message);
      throw error;
    }
  }

  // Update event in Google Calendar
  async updateGoogleEvent(eventId, eventDetails) {
    try {
      let calendarId = eventDetails.calendarId;

      if (!calendarId) {
        calendarId = process.env.GOOGLE_CALENDAR_ID || process.env.GOOGLE_CALENDAR_IDS?.split(',')[0];
      }

      if (!calendarId) {
        throw new Error('Google Calendar not configured. Need GOOGLE_CALENDAR_ID in .env');
      }

      // Get service account credentials
      let auth;
      
      if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        const keyJson = Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY, 'base64').toString('utf-8');
        const credentials = JSON.parse(keyJson);
        
        auth = new google.auth.GoogleAuth({
          credentials,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH) {
        const keyPath = process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH;
        const keyFilePath = path.resolve(keyPath);
        
        auth = new google.auth.GoogleAuth({
          keyFile: keyFilePath,
          scopes: ['https://www.googleapis.com/auth/calendar'],
        });
      } else {
        throw new Error('No Google service account credentials found');
      }

      const calendar = google.calendar({ version: 'v3', auth });
      
      // Build the update object
      const event = {};
      if (eventDetails.title) event.summary = eventDetails.title;
      if (eventDetails.location) event.location = eventDetails.location;
      if (eventDetails.description !== undefined) event.description = eventDetails.description;
      
      if (eventDetails.startDateTime) {
        event.start = {
          dateTime: eventDetails.startDateTime,
          timeZone: eventDetails.timeZone || this.defaultTimezone,
        };
      }

      if (eventDetails.endDateTime) {
        event.end = {
          dateTime: eventDetails.endDateTime,
          timeZone: eventDetails.timeZone || this.defaultTimezone,
        };
      }

      const response = await calendar.events.patch({
        calendarId: calendarId,
        eventId: eventId,
        resource: event,
      });

      console.log(`‚úÖ Event updated: ${response.data.htmlLink}`);
      return response.data;
    } catch (error) {
      console.error('‚ùå Error updating event:', error.message);
      throw error;
    }
  }

  // Parse event details from command line arguments
  parseEventArgs(args) {
    const event = {
      title: '',
      startDateTime: '',
      endDateTime: '',
      location: '',
      description: '',
      timeZone: this.defaultTimezone,
      calendarId: null
    };

    let i = 0;
    while (i < args.length) {
      const arg = args[i];
      
      if (arg === '--title' || arg === '-t') {
        event.title = args[++i];
      } else if (arg === '--date' || arg === '-d') {
        const dateStr = args[++i];
        const timeStr = args[++i] || '09:00';
        const endTimeStr = args[++i] || '10:00';
        
        // Create date strings in YYYY-MM-DDTHH:MM:SS format (without timezone)
        // Google Calendar API will apply the timezone specified in the event
        const [startHour, startMin] = timeStr.split(':');
        const [endHour, endMin] = endTimeStr.split(':');
        
        // Format: YYYY-MM-DDTHH:MM:SS (local time in the specified timezone)
        event.startDateTime = `${dateStr}T${startHour.padStart(2, '0')}:${startMin.padStart(2, '0')}:00`;
        event.endDateTime = `${dateStr}T${endHour.padStart(2, '0')}:${endMin.padStart(2, '0')}:00`;
      } else if (arg === '--start') {
        event.startDateTime = args[++i];
      } else if (arg === '--end') {
        event.endDateTime = args[++i];
      } else if (arg === '--location' || arg === '-l') {
        event.location = args[++i];
      } else if (arg === '--description' || arg === '--desc') {
        event.description = args[++i];
      } else if (arg === '--timezone' || arg === '--tz') {
        event.timeZone = args[++i];
      } else if (arg === '--calendar' || arg === '-c') {
        event.calendarId = args[++i];
      } else if (!event.title) {
        // First non-flag argument is the title
        event.title = arg;
      }
      i++;
    }

    return event;
  }
}

// Command line interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const command = process.argv[2];
  const calSync = new CalendarSync();
  
  try {
    switch (command) {
      case 'sync':
        await calSync.sync();
        break;
      
    case 'today':
      const events = await calSync.getEventsForSummary();
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const todayEvents = events.filter(event => {
        const eventDate = new Date(event.start);
        return eventDate >= today && eventDate < tomorrow;
      });
      
      console.log(JSON.stringify(todayEvents, null, 2));
      break;
      
    case 'week':
      const weekEvents = await calSync.getEventsForSummary();
      console.log(JSON.stringify(weekEvents, null, 2));
      break;
    
    case 'add':
      // Parse event details from command line
      const eventArgs = process.argv.slice(3);
      
      if (eventArgs.length === 0 || eventArgs.includes('--help')) {
        console.log(`
Usage: calendar add [options]

Options:
  --title, -t <title>         Event title (required)
  --date, -d <date> <start> <end>  Date and times (e.g., "2025-09-05" "20:00" "21:00")
  --start <datetime>          Start datetime (ISO format)
  --end <datetime>            End datetime (ISO format)
  --location, -l <location>   Event location
  --description <desc>        Event description
  --timezone, --tz <tz>       Timezone (default: America/New_York)
  --calendar, -c <calendar>   Calendar ID or name (defaults to primary calendar)

Examples:
  calendar add --title "Quadz Bar Showtunes" --date "2025-09-05" "20:00" "21:00" --location "Quadz Bar, Palm Springs"
  calendar add "Team Meeting" --start "2025-09-08T10:00:00" --end "2025-09-08T11:00:00"
  calendar add --title "Focus Block" --date "2025-10-04" "14:00" "16:00" --calendar "Time Blocking"
        `);
        break;
      }
      
      const eventDetails = calSync.parseEventArgs(eventArgs);
      
      if (!eventDetails.title) {
        console.error('‚ùå Error: Event title is required');
        process.exit(1);
      }
      
      if (!eventDetails.startDateTime || !eventDetails.endDateTime) {
        console.error('‚ùå Error: Start and end times are required');
        console.log('Use --date followed by date and times, or --start and --end with full datetime');
        process.exit(1);
      }
      
      console.log('üìÖ Creating event...');
      console.log(`  Title: ${eventDetails.title}`);
      console.log(`  Start: ${new Date(eventDetails.startDateTime).toLocaleString()}`);
      console.log(`  End: ${new Date(eventDetails.endDateTime).toLocaleString()}`);
      if (eventDetails.location) console.log(`  Location: ${eventDetails.location}`);
      if (eventDetails.description) console.log(`  Description: ${eventDetails.description}`);
      
      await calSync.addGoogleEvent(eventDetails);
      break;
      
    case 'delete':
      const deleteEventId = process.argv[3];

      if (!deleteEventId || deleteEventId === '--help') {
        console.log(`
Usage: calendar delete <event-id>

Delete an event from Google Calendar by its ID.

Example:
  calendar delete pvu3qkdo96orhscs2nbpm44kq0
        `);
        break;
      }

      console.log(`üóëÔ∏è  Deleting event ${deleteEventId}...`);

      // Look up the event in the database to find which calendar it belongs to
      const eventToDelete = calSync.db.prepare(`
        SELECT calendar_name FROM calendar_events WHERE id = ?
      `).get(deleteEventId);

      let calendarId = null;
      if (eventToDelete && eventToDelete.calendar_name) {
        calendarId = eventToDelete.calendar_name;
        console.log(`   Found event in calendar: ${calendarId}`);
      }

      await calSync.deleteGoogleEvent(deleteEventId, calendarId);
      break;
      
    case 'update':
      const updateEventId = process.argv[3];
      const updateArgs = process.argv.slice(4);
      
      if (!updateEventId || updateEventId === '--help' || updateArgs.length === 0) {
        console.log(`
Usage: calendar update <event-id> [options]

Options (all optional, only specified fields will be updated):
  --title, -t <title>         New event title
  --date, -d <date> <start> <end>  New date and times
  --start <datetime>          New start datetime
  --end <datetime>            New end datetime
  --location, -l <location>   New location
  --description <desc>        New description
  --timezone, --tz <tz>       Timezone for date/time updates
  --calendar, -c <calendar>   Calendar ID or name (defaults to primary calendar)

Example:
  calendar update pvu3qkdo96orhscs2nbpm44kq0 --date "2025-09-07" "17:00" "19:00"
        `);
        break;
      }
      
      const updateDetails = calSync.parseEventArgs(updateArgs);
      
      console.log(`üìù Updating event ${updateEventId}...`);
      if (updateDetails.title) console.log(`  New title: ${updateDetails.title}`);
      if (updateDetails.startDateTime) console.log(`  New start: ${new Date(updateDetails.startDateTime).toLocaleString()}`);
      if (updateDetails.endDateTime) console.log(`  New end: ${new Date(updateDetails.endDateTime).toLocaleString()}`);
      if (updateDetails.location) console.log(`  New location: ${updateDetails.location}`);
      if (updateDetails.description !== undefined) console.log(`  New description: ${updateDetails.description}`);
      
      await calSync.updateGoogleEvent(updateEventId, updateDetails);
      break;

    case 'list-calendars':
    case 'calendars':
      // List available calendars
      const calendarIds = process.env.GOOGLE_CALENDAR_IDS || process.env.GOOGLE_CALENDAR_ID;

      if (!calendarIds) {
        console.log('‚ùå No Google Calendar configured');
        console.log('   Run "calendar setup" for configuration instructions');
        break;
      }

      console.log('üìÖ Available Calendars:');
      const calendars = calendarIds.split(',').map(id => id.trim()).filter(Boolean);

      for (let i = 0; i < calendars.length; i++) {
        const calId = calendars[i];
        console.log(`  ${i + 1}. ${calId}${i === 0 ? ' (default)' : ''}`);
      }

      console.log('\nüí° Usage: Use the calendar ID with --calendar/-c option:');
      console.log('   calendar add "Meeting" --calendar "Time Blocking" --date "2025-10-04" "14:00" "15:00"');
      break;

    case 'setup':
      console.log(`
üìÖ Calendar Setup Instructions

For Google Calendar (Service Account):
1. Go to https://console.cloud.google.com/
2. Create a new project or select existing
3. Enable Google Calendar API:
   - APIs & Services > Enable APIs > Search "Google Calendar API"
4. Create Service Account:
   - APIs & Services > Credentials > Create Credentials > Service Account
   - Name it (e.g., "today-calendar-sync")
   - Click Done
5. Create key for Service Account:
   - Click on your service account
   - Keys tab > Add Key > Create new key > JSON
   - Save as 'google-calendar-key.json' in project root
6. Share your calendar:
   - Copy service account email (ends with @...iam.gserviceaccount.com)
   - In Google Calendar, go to Settings > Share with specific people
   - Add the service account email with "See all event details" permission
7. Add to .env:
   GOOGLE_SERVICE_ACCOUNT_KEY_PATH=./google-calendar-key.json
   GOOGLE_CALENDAR_ID=your-email@gmail.com  # or calendar ID

For iCloud Calendar:
1. Go to https://appleid.apple.com/account/manage
2. Sign in and go to "Sign-In and Security"
3. Under "App-Specific Passwords", generate new password
4. Add to .env:
   ICLOUD_USERNAME=your@icloud.com
   ICLOUD_APP_PASSWORD=xxxx-xxxx-xxxx-xxxx

For Local Calendar:
1. Export your calendar as .ics file
2. Save as calendar.ics in project root

For macOS Calendar:
- Works automatically on Mac (uses AppleScript)
      `);
      break;
      
    default:
      console.log(`
Usage: calendar [command]

Commands:
  sync              - Sync all configured calendars
  today             - Show today's events
  week              - Show this week's events
  add               - Add a new event to Google Calendar
  update            - Update an existing Google Calendar event
  delete            - Delete a Google Calendar event
  list-calendars    - List available calendar IDs
  setup             - Show setup instructions

Calendar data is stored in SQLite database (.data/today.db)

For detailed help on any command:
  calendar <command> --help
      `);
    }
    process.exit(0);
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

export { CalendarSync };