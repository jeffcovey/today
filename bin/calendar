#!/usr/bin/env node

// Calendar CLI - queries events from plugin system
// All operations delegate to "events" plugins
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import { execSync } from 'child_process';
import { getDatabase } from '../src/database-service.js';
import { discoverPlugins, getPluginSources, getPluginAccess } from '../src/plugin-loader.js';
import { getConfiguredTimezone, formatTime } from '../src/date-utils.js';

// Get configured timezone
const TIMEZONE = getConfiguredTimezone();

// Get all calendar sources from all event plugins
async function getAllCalendarSources() {
  const plugins = await discoverPlugins();
  const sources = [];

  for (const [pluginName, plugin] of plugins) {
    if (plugin.type !== 'events') continue;

    const pluginSources = getPluginSources(pluginName);
    for (const { sourceName, config } of pluginSources) {
      sources.push({
        name: sourceName,
        plugin: pluginName,
        pluginMeta: plugin,
        config
      });
    }
  }

  return sources;
}

// Find a calendar source by name
async function findCalendarSource(sourceName) {
  const allSources = await getAllCalendarSources();

  // Exact match first
  let match = allSources.find(s => s.name === sourceName);
  if (match) return match;

  // Partial match
  match = allSources.find(s => s.name.includes(sourceName));
  return match || null;
}

// Get default writable calendar source (first source from a plugin that supports write)
async function getDefaultWritableSource() {
  const allSources = await getAllCalendarSources();

  for (const source of allSources) {
    // Use pluginMeta to check for write support
    if (getPluginAccess(source.pluginMeta) === 'read-write') {
      return source;
    }
  }

  return null;
}

// Get the most recent sync time for events
function getLastSyncTime(db) {
  try {
    const result = db.prepare(`
      SELECT MAX(last_synced_at) as latest
      FROM sync_metadata
      WHERE source LIKE '%calendar%'
    `).get();
    return result?.latest ? new Date(result.latest + 'Z') : null;
  } catch {
    return null;
  }
}

// Quiet sync - ensures database is current before read operations
function ensureSync(db) {
  const STALE_MINUTES = 5;
  const lastSync = getLastSyncTime(db);

  if (lastSync) {
    const ageMinutes = (Date.now() - lastSync.getTime()) / 1000 / 60;
    if (ageMinutes < STALE_MINUTES) {
      return;
    }
  }

  try {
    execSync('bin/plugins sync --type events', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
  } catch {
    // Silently ignore sync errors for read operations
  }
}

// Format time ago string
function formatTimeAgo(date) {
  if (!date) return 'never';
  const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
  if (seconds < 60) return 'just now';
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
  const days = Math.floor(hours / 24);
  return `${days} day${days === 1 ? '' : 's'} ago`;
}

// Get events from database
function getEventsForRange(db, startDate, endDate) {
  return db.prepare(`
    SELECT
      id, source, calendar_name, title,
      start_date as start, end_date as end,
      start_timezone, end_timezone,
      location, description, all_day
    FROM events
    WHERE start_date <= ? AND end_date >= ?
    ORDER BY start_date
  `).all(endDate.toISOString(), startDate.toISOString()).map(event => ({
    ...event,
    allDay: event.all_day === 1,
    calendar: event.calendar_name
  }));
}

// Call a plugin's write command
function callPluginWrite(source, action, eventData) {
  const pluginDir = `plugins/${source.plugin}`;
  const pluginConfig = JSON.stringify(source.config);
  const input = JSON.stringify({ action, event: eventData });

  try {
    const result = execSync(`echo '${input.replace(/'/g, "'\\''")}' | node ${pluginDir}/write.js`, {
      encoding: 'utf8',
      env: {
        ...process.env,
        PLUGIN_CONFIG: pluginConfig
      }
    });
    return JSON.parse(result);
  } catch (error) {
    // Try to parse error output
    if (error.stdout) {
      try {
        return JSON.parse(error.stdout);
      } catch { }
    }
    return { success: false, error: error.message };
  }
}

// Call a plugin's read command with --date
function callPluginRead(source, date) {
  const pluginDir = `plugins/${source.plugin}`;
  const pluginConfig = JSON.stringify(source.config);

  try {
    const result = execSync(`node ${pluginDir}/read.js --date=${date}`, {
      encoding: 'utf8',
      env: {
        ...process.env,
        PLUGIN_CONFIG: pluginConfig
      }
    });
    return JSON.parse(result);
  } catch (error) {
    return { entries: [], error: error.message };
  }
}

// Parse event details from command line arguments
function parseEventArgs(args) {
  const event = {
    title: '',
    start_date: '',
    end_date: '',
    location: '',
    description: '',
    timezone: TIMEZONE,
    sourceArg: null
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg === '--title' || arg === '-t') {
      event.title = args[++i];
    } else if (arg === '--date' || arg === '-d') {
      const dateStr = args[++i];
      const timeStr = args[++i] || '09:00';
      const endTimeStr = args[++i] || '10:00';

      const [startHour, startMin] = timeStr.split(':');
      const [endHour, endMin] = endTimeStr.split(':');

      event.start_date = `${dateStr}T${startHour.padStart(2, '0')}:${startMin.padStart(2, '0')}:00`;
      event.end_date = `${dateStr}T${endHour.padStart(2, '0')}:${endMin.padStart(2, '0')}:00`;
    } else if (arg === '--start') {
      event.start_date = args[++i];
    } else if (arg === '--end') {
      event.end_date = args[++i];
    } else if (arg === '--location' || arg === '-l') {
      event.location = args[++i];
    } else if (arg === '--description' || arg === '--desc') {
      event.description = args[++i];
    } else if (arg === '--timezone' || arg === '--tz') {
      event.timezone = args[++i];
    } else if (arg === '--calendar' || arg === '-c') {
      event.sourceArg = args[++i];
    } else if (!event.title) {
      event.title = arg;
    }
    i++;
  }

  return event;
}

// Commands
async function cmdToday(db) {
  ensureSync(db);

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const events = getEventsForRange(db, today, tomorrow);

  if (events.length === 0) {
    console.log('No events for today.');
  } else {
    console.log(`üìÖ Today's Events (${events.length}):\n`);
    for (const event of events) {
      if (event.allDay) {
        console.log(`  ‚Ä¢ ${event.title}`);
      } else {
        const time = formatTime(event.start, TIMEZONE);
        console.log(`  ‚Ä¢ ${time} - ${event.title}`);
      }
      if (event.calendar) console.log(`    üìÜ ${event.calendar}`);
      if (event.location) console.log(`    üìç ${event.location}`);
      if (event.description) {
        const firstLine = event.description.split('\n')[0];
        console.log(`    ${firstLine}`);
      }
      console.log('');
    }
  }

  const lastSync = getLastSyncTime(db);
  console.log(`Last synced: ${formatTimeAgo(lastSync)}. Run 'bin/calendar sync' to refresh.`);
}

async function cmdWeek(db) {
  ensureSync(db);

  const weekStart = new Date();
  weekStart.setHours(0, 0, 0, 0);
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekEnd.getDate() + 7);

  const events = getEventsForRange(db, weekStart, weekEnd);

  if (events.length === 0) {
    console.log('No events for the next 7 days.');
  } else {
    console.log(`üìÖ This Week's Events (${events.length}):\n`);

    const byDate = {};
    for (const event of events) {
      const dateKey = event.start.split('T')[0];
      if (!byDate[dateKey]) byDate[dateKey] = [];
      byDate[dateKey].push(event);
    }

    for (const dateKey of Object.keys(byDate).sort()) {
      const date = new Date(dateKey + 'T12:00:00');
      const dayName = date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
      console.log(`${dayName}:`);

      for (const event of byDate[dateKey]) {
        if (event.allDay) {
          console.log(`  ‚Ä¢ ${event.title}`);
        } else {
          const time = formatTime(event.start, TIMEZONE);
          console.log(`  ‚Ä¢ ${time} - ${event.title}`);
        }
        if (event.calendar) console.log(`    üìÜ ${event.calendar}`);
        if (event.location) console.log(`    üìç ${event.location}`);
      }
      console.log('');
    }
  }

  const lastSync = getLastSyncTime(db);
  console.log(`Last synced: ${formatTimeAgo(lastSync)}. Run 'bin/calendar sync' to refresh.`);
}

async function cmdSync() {
  console.log('Syncing calendars via plugin system...');
  execSync('bin/plugins sync --type events', {
    encoding: 'utf8',
    stdio: 'inherit'
  });
}

async function cmdAdd(args) {
  const eventDetails = parseEventArgs(args);

  if (!eventDetails.title) {
    console.error('‚ùå Error: Event title is required');
    process.exit(1);
  }

  if (!eventDetails.start_date || !eventDetails.end_date) {
    console.error('‚ùå Error: Start and end times are required');
    console.log('Use --date followed by date and times, or --start and --end with full datetime');
    process.exit(1);
  }

  // Find calendar source
  let source = eventDetails.sourceArg
    ? await findCalendarSource(eventDetails.sourceArg)
    : await getDefaultWritableSource();

  if (!source) {
    console.error('‚ùå Error: No calendar specified and no default configured');
    console.log('Use --calendar/-c to specify a source. Run "calendar list" to see available calendars.');
    process.exit(1);
  }

  // Check if plugin supports write
  if (getPluginAccess(source.pluginMeta) !== 'read-write') {
    console.error(`‚ùå Error: Calendar "${source.name}" (${source.plugin}) does not support write operations`);
    process.exit(1);
  }

  console.log('üìÖ Creating event...');
  console.log(`  Title: ${eventDetails.title}`);
  console.log(`  Start: ${new Date(eventDetails.start_date).toLocaleString()}`);
  console.log(`  End: ${new Date(eventDetails.end_date).toLocaleString()}`);
  console.log(`  Calendar: ${source.name}`);
  if (eventDetails.location) console.log(`  Location: ${eventDetails.location}`);

  const result = callPluginWrite(source, 'create', {
    title: eventDetails.title,
    start_date: eventDetails.start_date,
    end_date: eventDetails.end_date,
    location: eventDetails.location,
    description: eventDetails.description,
    timezone: eventDetails.timezone
  });

  if (result.success) {
    console.log(`‚úÖ Event created: ${result.html_link || result.event_id}`);
  } else {
    console.error(`‚ùå Error: ${result.error}`);
    process.exit(1);
  }
}

async function cmdUpdate(eventId, args) {
  const eventDetails = parseEventArgs(args);

  // Find calendar source
  let source = null;

  if (eventDetails.sourceArg) {
    source = await findCalendarSource(eventDetails.sourceArg);
  } else {
    // Try to look up from database
    const db = getDatabase();
    const eventRecord = db.prepare(`SELECT source FROM events WHERE id = ?`).get(eventId);
    if (eventRecord) {
      const [, sourceName] = eventRecord.source.split('/');
      source = await findCalendarSource(sourceName);
    }
  }

  if (!source) {
    source = await getDefaultWritableSource();
  }

  if (!source) {
    console.error('‚ùå Error: No calendar specified');
    console.log('Use --calendar/-c to specify a source. Run "calendar list" to see available calendars.');
    process.exit(1);
  }

  console.log(`üìù Updating event ${eventId} in ${source.name}...`);

  const updateData = { id: eventId };
  if (eventDetails.title) updateData.title = eventDetails.title;
  if (eventDetails.start_date) updateData.start_date = eventDetails.start_date;
  if (eventDetails.end_date) updateData.end_date = eventDetails.end_date;
  if (eventDetails.location) updateData.location = eventDetails.location;
  if (eventDetails.description) updateData.description = eventDetails.description;
  if (eventDetails.timezone) updateData.timezone = eventDetails.timezone;

  const result = callPluginWrite(source, 'update', updateData);

  if (result.success) {
    console.log(`‚úÖ Event updated: ${result.html_link || result.event_id}`);
  } else {
    console.error(`‚ùå Error: ${result.error}`);
    process.exit(1);
  }
}

async function cmdDelete(eventId, sourceArg) {
  let source = null;

  if (sourceArg) {
    source = await findCalendarSource(sourceArg);
  } else {
    // Try to look up from database
    const db = getDatabase();
    const eventRecord = db.prepare(`SELECT source FROM events WHERE id = ?`).get(eventId);
    if (eventRecord) {
      const [, sourceName] = eventRecord.source.split('/');
      source = await findCalendarSource(sourceName);
      if (source) {
        console.log(`   Found event in calendar: ${sourceName}`);
      }
    }
  }

  if (!source) {
    source = await getDefaultWritableSource();
  }

  if (!source) {
    console.error('‚ùå Error: No calendar specified and could not determine from event');
    console.log('Use --calendar/-c to specify a source. Run "calendar list" to see available calendars.');
    process.exit(1);
  }

  console.log(`üóëÔ∏è  Deleting event ${eventId} from ${source.name}...`);

  const result = callPluginWrite(source, 'delete', { id: eventId });

  if (result.success) {
    console.log(`‚úÖ Event deleted`);
  } else {
    console.error(`‚ùå Error: ${result.error}`);
    process.exit(1);
  }
}

async function cmdShow(sourceArg, dateStr) {
  const showDate = dateStr || new Date().toISOString().split('T')[0];
  const source = await findCalendarSource(sourceArg);

  if (!source) {
    console.error(`‚ùå Calendar source "${sourceArg}" not found`);
    console.log('Run "calendar list" to see available sources.');
    process.exit(1);
  }

  console.log(`üìÖ Fetching events for ${showDate} from ${source.name}...`);

  const data = callPluginRead(source, showDate);
  const events = data.entries || [];

  if (events.length === 0) {
    console.log('No events found for this date');
  } else {
    console.log(`\nFound ${events.length} event(s):\n`);
    for (const event of events) {
      console.log(`üìå ${event.title}`);
      console.log(`   ID: ${event.id}`);
      console.log(`   Start: ${event.start_date}`);
      console.log(`   End: ${event.end_date}`);
      if (event.location) console.log(`   üìç ${event.location}`);
      console.log('');
    }
  }
}

async function cmdCleanup(sourceArg, daysToKeep = 0) {
  const source = await findCalendarSource(sourceArg);

  if (!source) {
    console.error(`‚ùå Calendar source "${sourceArg}" not found`);
    console.log('Run "calendar list" to see available sources.');
    process.exit(1);
  }

  // Check if plugin supports write
  if (getPluginAccess(source.pluginMeta) !== 'read-write') {
    console.error(`‚ùå Error: Calendar "${source.name}" (${source.plugin}) does not support write operations`);
    process.exit(1);
  }

  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
  const cutoffStr = cutoffDate.toISOString().split('T')[0];

  if (daysToKeep > 0) {
    console.log(`üóëÔ∏è  Cleaning up events before ${cutoffStr} from ${source.name}...`);
  } else {
    console.log(`üóëÔ∏è  Cleaning up all past events from ${source.name}...`);
  }

  // Fetch events from the past 2 years up to cutoff
  const twoYearsAgo = new Date(cutoffDate.getTime() - 2 * 365 * 24 * 60 * 60 * 1000);
  let deletedCount = 0;

  // Iterate day by day (crude but works with our --date interface)
  let currentDate = new Date(twoYearsAgo);
  while (currentDate < cutoffDate) {
    const dateStr = currentDate.toISOString().split('T')[0];
    const data = callPluginRead(source, dateStr);

    for (const event of data.entries || []) {
      const result = callPluginWrite(source, 'delete', { id: event.id });
      if (result.success) {
        deletedCount++;
      }
    }

    currentDate.setDate(currentDate.getDate() + 1);
  }

  if (deletedCount > 0) {
    console.log(`‚úÖ Deleted ${deletedCount} past event(s)`);
  } else {
    console.log(`‚úÖ No past events to clean up`);
  }
}

async function cmdSyncTimeTracking(sourceArg, daysBack = 2) {
  const source = await findCalendarSource(sourceArg);

  if (!source) {
    console.error(`‚ùå Calendar source "${sourceArg}" not found`);
    console.log('Run "calendar list" to see available sources.');
    process.exit(1);
  }

  // Check if plugin supports write
  if (getPluginAccess(source.pluginMeta) !== 'read-write') {
    console.error(`‚ùå Error: Calendar "${source.name}" (${source.plugin}) does not support write operations`);
    process.exit(1);
  }

  const TIME_TRACKING_EMOJI = '‚è±Ô∏è';
  const db = getDatabase();

  const endDate = new Date();
  endDate.setHours(23, 59, 59, 999);
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - daysBack);
  startDate.setHours(0, 0, 0, 0);

  console.log(`üîÑ Syncing time tracking entries to ${source.name}...`);
  console.log(`   Date range: ${startDate.toDateString()} to ${endDate.toDateString()}`);

  // Get time entries from database
  const timeEntries = db.prepare(`
    SELECT id, start_time, end_time, description
    FROM time_logs
    WHERE datetime(start_time) >= datetime('now', '-' || ? || ' days')
      AND datetime(start_time) <= datetime('now')
      AND end_time IS NOT NULL
    ORDER BY start_time
  `).all(daysBack);

  console.log(`   Found ${timeEntries.length} time tracking entries in database`);

  // Deduplicate
  const uniqueEntries = new Map();
  for (const entry of timeEntries) {
    const key = `${entry.start_time}|${entry.end_time}|${entry.description}`;
    if (!uniqueEntries.has(key)) {
      uniqueEntries.set(key, entry);
    }
  }

  // Get existing calendar events for the date range
  const existingEvents = [];
  let currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split('T')[0];
    const data = callPluginRead(source, dateStr);
    for (const event of data.entries || []) {
      if (event.title && event.title.startsWith(TIME_TRACKING_EMOJI)) {
        existingEvents.push(event);
      }
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }

  console.log(`   Found ${existingEvents.length} existing time tracking events in calendar`);

  // Map existing events
  const existingEventsMap = new Map();
  for (const event of existingEvents) {
    const title = event.title.replace(TIME_TRACKING_EMOJI + ' ', '');
    const key = `${event.start_date}|${event.end_date}|${title}`;
    existingEventsMap.set(key, event);
  }

  // Find entries to add
  const entriesToAdd = [];
  for (const [, entry] of uniqueEntries) {
    const calendarKey = `${entry.start_time}|${entry.end_time}|${entry.description}`;
    if (!existingEventsMap.has(calendarKey)) {
      entriesToAdd.push(entry);
    }
  }

  // Find events to remove
  const eventsToRemove = [];
  for (const [, event] of existingEventsMap) {
    const title = event.title.replace(TIME_TRACKING_EMOJI + ' ', '');
    const dbKey = `${event.start_date}|${event.end_date}|${title}`;
    if (!uniqueEntries.has(dbKey)) {
      eventsToRemove.push(event);
    }
  }

  console.log(`   ${entriesToAdd.length} entries to add, ${eventsToRemove.length} events to remove`);

  // Add missing entries
  let addedCount = 0;
  for (const entry of entriesToAdd) {
    const result = callPluginWrite(source, 'create', {
      title: `${TIME_TRACKING_EMOJI} ${entry.description}`,
      start_date: entry.start_time,
      end_date: entry.end_time,
      timezone: TIMEZONE
    });
    if (result.success) {
      addedCount++;
    } else {
      console.error(`   ‚ö†Ô∏è  Failed to add "${entry.description}": ${result.error}`);
    }
  }

  // Remove obsolete events
  let removedCount = 0;
  for (const event of eventsToRemove) {
    const result = callPluginWrite(source, 'delete', { id: event.id });
    if (result.success) {
      removedCount++;
    } else {
      console.error(`   ‚ö†Ô∏è  Failed to remove "${event.title}": ${result.error}`);
    }
  }

  if (addedCount > 0 || removedCount > 0) {
    console.log(`‚úÖ Sync complete: Added ${addedCount}, Removed ${removedCount}`);
  } else {
    console.log(`‚úÖ Already in sync (${uniqueEntries.size} entries)`);
  }
}

// CLI
const db = getDatabase();
const command = process.argv[2];

try {
  switch (command) {
    case 'sync':
      await cmdSync();
      break;

    case 'today':
      await cmdToday(db);
      break;

    case 'week':
      await cmdWeek(db);
      break;

    case 'add': {
      const args = process.argv.slice(3);
      if (args.length === 0 || args.includes('--help')) {
        console.log(`
Usage: calendar add [options]

Options:
  --title, -t <title>         Event title (required)
  --date, -d <date> <start> <end>  Date and times (e.g., "2025-09-05" "20:00" "21:00")
  --start <datetime>          Start datetime (ISO format)
  --end <datetime>            End datetime (ISO format)
  --location, -l <location>   Event location
  --description <desc>        Event description
  --timezone, --tz <tz>       Timezone (default: ${TIMEZONE})
  --calendar, -c <source>     Calendar source name (run 'calendar list' to see options)

Examples:
  calendar add --title "Meeting" --date "2025-09-05" "20:00" "21:00" --location "Office"
  calendar add "Focus Block" -c time-blocking --date "2025-12-15" "14:00" "16:00"
        `);
      } else {
        await cmdAdd(args);
      }
      break;
    }

    case 'update': {
      const eventId = process.argv[3];
      const args = process.argv.slice(4);
      if (!eventId || eventId === '--help' || args.length === 0) {
        console.log(`
Usage: calendar update <event-id> [options]

Options (only specified fields will be updated):
  --title, -t <title>         New event title
  --date, -d <date> <start> <end>  New date and times
  --start <datetime>          New start datetime
  --end <datetime>            New end datetime
  --location, -l <location>   New location
  --description <desc>        New description
  --calendar, -c <source>     Calendar source name

Example:
  calendar update abc123 --date "2025-09-07" "17:00" "19:00" -c personal
        `);
      } else {
        await cmdUpdate(eventId, args);
      }
      break;
    }

    case 'delete': {
      const eventId = process.argv[3];
      const calendarArgIdx = process.argv.findIndex(a => a === '-c' || a === '--calendar');
      const calendarArg = calendarArgIdx > 0 ? process.argv[calendarArgIdx + 1] : null;

      if (!eventId || eventId === '--help') {
        console.log(`
Usage: calendar delete <event-id> [-c <source>]

Delete an event from a calendar.
If no calendar is specified, tries to look up from database or uses default.

Example:
  calendar delete abc123
  calendar delete abc123 -c time-blocking
        `);
      } else {
        await cmdDelete(eventId, calendarArg);
      }
      break;
    }

    case 'show':
    case 'get': {
      const sourceArg = process.argv[3];
      const dateStr = process.argv[4];
      if (!sourceArg || sourceArg === '--help') {
        console.log(`
Usage: calendar show <source> [date]

Fetch events directly from a calendar source for a specific date.
Useful for historical events not in the synced database.
Date format: YYYY-MM-DD (default: today)

Run 'calendar list' to see available sources.

Examples:
  calendar show personal
  calendar show personal 2023-01-15
  calendar show airbnb-1 2024-06-01
        `);
      } else {
        await cmdShow(sourceArg, dateStr);
      }
      break;
    }

    case 'cleanup': {
      const sourceArg = process.argv[3];
      const daysToKeep = parseInt(process.argv[4]) || 0;
      if (!sourceArg || sourceArg === '--help') {
        console.log(`
Usage: calendar cleanup <source> [days-to-keep]

Delete past events from a calendar.
Only works with calendars that support write operations.

Arguments:
  source        - Calendar source name (run 'calendar list' to see options)
  days-to-keep  - Number of recent days to keep (default: 0)

Example:
  calendar cleanup time-blocking
  calendar cleanup time-blocking 2
        `);
      } else {
        await cmdCleanup(sourceArg, daysToKeep);
      }
      break;
    }

    case 'sync-time-tracking':
    case 'sync-tracking': {
      const sourceArg = process.argv[3];
      const daysBack = parseInt(process.argv[4]) || 2;
      if (!sourceArg || sourceArg === '--help') {
        console.log(`
Usage: calendar sync-time-tracking <source> [days-back]

Sync time tracking entries with a calendar.
Uses ‚è±Ô∏è emoji prefix to identify time tracking entries.
Only works with calendars that support write operations.

Arguments:
  source     - Calendar source name (run 'calendar list' to see options)
  days-back  - Number of days to look back (default: 2)

Example:
  calendar sync-time-tracking time-blocking
  calendar sync-time-tracking time-blocking 3
        `);
      } else {
        await cmdSyncTimeTracking(sourceArg, daysBack);
      }
      break;
    }

    case 'list':
    case 'list-calendars':
    case 'calendars': {
      const allSources = await getAllCalendarSources();

      if (allSources.length === 0) {
        console.log('No calendar sources configured.');
        console.log('');
        console.log('Add calendars in config.toml. Run "bin/plugins list" to see available plugins.');
      } else {
        console.log('üìÖ Configured Calendar Sources:\n');

        // Group by plugin
        const byPlugin = {};
        for (const s of allSources) {
          if (!byPlugin[s.plugin]) byPlugin[s.plugin] = [];
          byPlugin[s.plugin].push(s);
        }

        const defaultSource = await getDefaultWritableSource();

        for (const [plugin, sources] of Object.entries(byPlugin)) {
          // Check if plugin supports write using pluginMeta
          const access = getPluginAccess(sources[0].pluginMeta);
          const writeSupport = access === 'read-write' ? ' (read/write)' : ' (read-only)';

          console.log(`${plugin}${writeSupport}:`);
          for (const s of sources) {
            const isDefault = defaultSource && s.name === defaultSource.name && s.plugin === defaultSource.plugin;
            const displayName = s.config.name || s.config.calendar_id || s.name;
            console.log(`  ${s.name}${isDefault ? ' (default)' : ''}`);
            console.log(`    ${displayName}`);
          }
          console.log('');
        }

        console.log('Use source names with commands:');
        console.log('  calendar show personal 2023-01-15   # Historical lookup');
        console.log('  calendar add "Meeting" -c personal  # Create event');
      }
      break;
    }

    default:
      console.log(`
Usage: calendar [command]

Commands:
  sync              - Sync all calendars via plugin system
  today             - Show today's events
  week              - Show this week's events
  list              - List configured calendar sources
  add               - Add a new event (-c <source> to specify calendar)
  update            - Update an existing event
  delete            - Delete an event
  show              - Fetch events from a source for a specific date
  cleanup           - Delete past events from a calendar
  sync-time-tracking - Sync time tracking entries with calendar

Use -c/--calendar with source names (e.g., -c personal, -c time-blocking)
Run 'calendar list' to see available calendars.

For detailed help on any command:
  calendar <command> --help
      `);
  }
  process.exit(0);
} catch (error) {
  console.error('Error:', error.message);
  process.exit(1);
}
