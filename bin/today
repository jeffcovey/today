#!/bin/bash

# Quick review script that syncs, updates summary, and starts interactive Claude session
# Usage: bin/today [--no-sync] [optional direct request]
# Examples: 
#   bin/today "Let's work on the PS trip project"
#   bin/today --no-sync "Quick session without sync"
#   bin/today --no-sync

# Load common dotenvx handler
source "$(dirname "$0")/lib/dotenvx-loader.sh"
auto_dotenvx "$@"

# Parse arguments
SKIP_SYNC=false
DIRECT_REQUEST=""
NON_INTERACTIVE=false

# Check for flags
while [[ $# -gt 0 ]]; do
    case $1 in
        --no-sync)
            SKIP_SYNC=true
            shift
            ;;
        --non-interactive)
            NON_INTERACTIVE=true
            shift
            ;;
        *)
            if [ -z "$DIRECT_REQUEST" ]; then
                DIRECT_REQUEST="$1"
            fi
            shift
            ;;
    esac
done

if [ -n "$DIRECT_REQUEST" ]; then
    echo "ğŸ“Š Starting focused session: $DIRECT_REQUEST"
else
    echo "ğŸ“Š Starting daily review process..."
fi

if [ "$SKIP_SYNC" = true ]; then
    echo "âš ï¸  Skipping sync (--no-sync flag provided)"
fi

# Check if Claude CLI is authenticated by testing actual functionality
echo "ğŸ” Checking Claude authentication..."
TEST_RESPONSE=$(claude -p "Say 'ok'" 2>&1)
if echo "$TEST_RESPONSE" | grep -q "Invalid API key\|Please run /login\|not authenticated"; then
    echo ""
    echo "âš ï¸  Claude CLI is not authenticated!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Claude is essential for daily reviews."
    echo "Please authenticate now by running:"
    echo ""
    echo "  claude"
    echo ""
    echo "Then follow the browser prompt to login."
    echo "After authentication, run 'bin/today' again."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    exit 1
fi
echo "âœ… Claude is authenticated"
echo ""

# Check dependencies once per day (quietly) - skip in container if CI env var is set
LAST_DEP_CHECK_FILE=".last-dep-check"
# Simple date for dependency check
TODAY_DATE=$(date +%Y-%m-%d)

# Skip dependency check if running in container with limited network
if [ "$SKIP_DEP_CHECK" != "true" ]; then
    if [ ! -f "$LAST_DEP_CHECK_FILE" ] || [ "$(cat $LAST_DEP_CHECK_FILE 2>/dev/null)" != "$TODAY_DATE" ]; then
        echo "ğŸ” Checking for dependency updates (timeout in 10s)..."
        timeout 10 bin/update-deps --quiet || echo "âš ï¸  Dependency check timed out, continuing..."
        echo "$TODAY_DATE" > "$LAST_DEP_CHECK_FILE"
        echo ""
    fi
fi

# Run sync to update all data sources (unless --no-sync flag provided)
if [ "$SKIP_SYNC" != true ]; then
    echo "ğŸ”„ Syncing data sources..."
    bin/sync
else
    echo "â­ï¸  Skipping sync step"
fi

# Quick markdown lint check (non-blocking)
if command -v npx &> /dev/null && [ -f ".markdownlint.json" ]; then
    echo "ğŸ“ Checking markdown formatting..."
    # Run lint but don't block on errors, just show warnings
    npx markdownlint-cli2 'vault/plans/*.md' 2>&1 | head -10 || true
    echo ""
fi

# Check if database exists and has required tables
DB_PATH=".data/today.db"
DB_MISSING=false
TABLES_MISSING=false

if [ ! -f "$DB_PATH" ]; then
    echo "âš ï¸  Database not found at $DB_PATH"
    DB_MISSING=true
else
    # Check if critical tables exist
    TABLES_EXIST=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name IN ('tasks', 'projects')" 2>/dev/null || echo "0")
    if [ "$TABLES_EXIST" != "2" ]; then
        echo "âš ï¸  Database missing required tables"
        TABLES_MISSING=true
    fi
fi

# If database is missing or incomplete, attempt to recover from Turso
if [ "$DB_MISSING" = "true" ] || [ "$TABLES_MISSING" = "true" ]; then
    echo "ğŸ”„ Database missing or incomplete - recovering from Turso..."
    echo ""

    # Create .data directory if needed
    mkdir -p .data

    # First create database with migrations if it doesn't exist
    if [ "$DB_MISSING" = "true" ]; then
        echo "ğŸ”¨ Creating database and running migrations..."
        node -e "
            import('./src/migrations.js').then(async ({MigrationManager}) => {
                const Database = (await import('better-sqlite3')).default;
                const db = new Database('.data/today.db');
                const manager = new MigrationManager(db);
                await manager.runMigrations();
                db.close();
                console.log('âœ… Database created with schema');
            }).catch(err => {
                console.error('âŒ Failed to create database:', err.message);
                process.exit(1);
            });
        " || exit 1
        echo ""
    fi

    # Now pull data from Turso (without running full sync)
    echo "ğŸ“¥ Pulling data from Turso..."
    if bin/turso-sync pull 2>&1 | grep -v "^\[38;5;142m" | head -20; then
        echo "âœ… Database recovered successfully"
        echo ""

        # Verify database now exists and has tables
        if [ -f "$DB_PATH" ]; then
            TABLES_EXIST=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name IN ('tasks', 'projects')" 2>/dev/null || echo "0")
            if [ "$TABLES_EXIST" != "2" ]; then
                echo "âŒ Database recovery incomplete - tables still missing"
                echo "Please check your Turso configuration"
                exit 1
            fi
        else
            echo "âŒ Database recovery failed"
            echo "Please check your Turso configuration in .env"
            exit 1
        fi
    else
        echo "âŒ Failed to sync data from Turso"
        echo "Please ensure TURSO_DATABASE_URL and TURSO_AUTH_TOKEN are set in .env"
        exit 1
    fi
fi

# Quick check that database has data
LAST_SYNC=$(sqlite3 "$DB_PATH" "SELECT MAX(created_at) FROM sync_log" 2>/dev/null || echo "")
if [ -n "$LAST_SYNC" ]; then
    echo "âœ… Database ready (last sync: $LAST_SYNC)"
    echo ""
else
    # No sync log entries yet, but check if we have other data
    TASK_COUNT=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM tasks" 2>/dev/null || echo "0")
    if [ "$TASK_COUNT" != "0" ]; then
        echo "âœ… Database ready ($TASK_COUNT tasks found)"
        echo ""
    else
        # Database exists but is empty - add initial sync log entry
        echo "ğŸ“ Initializing sync log..."
        sqlite3 "$DB_PATH" "INSERT INTO sync_log (timestamp, sync_type, success, source_system, target_system, created_at) VALUES (datetime('now'), 'initial', 1, 'local', 'turso', datetime('now'))" 2>/dev/null || true
        echo "âœ… Database ready (initialized)"
        echo ""
    fi
    # Set LAST_SYNC to a valid value for the rest of the script
    LAST_SYNC="initialized"
fi

# Only proceed if we have a valid database state
if [ -z "$LAST_SYNC" ]; then
    echo "âŒ Database check failed"
    echo "Please check bin/sync for errors"
    exit 1
fi
    
    # ============================================
    # PRE-COMPUTE ALL CONTEXT DATA
    # ============================================
    
    # Get timezone from config
    TIMEZONE=$(bin/get-config timezone 2>/dev/null || echo "America/New_York")
    
    # 1. Date/Time Information
    CURRENT_TIME=$(TZ=$TIMEZONE date '+%A, %B %d, %Y at %I:%M %p %Z')
    CURRENT_DATE=$(TZ=$TIMEZONE date '+%Y-%m-%d')
    DAY_OF_WEEK=$(TZ=$TIMEZONE date '+%A')
    YEAR=$(date +%Y)
    MONTH=$(date +%m)
    DAY=$(date +%d)
    WEEK=$(date +%V)  # ISO week number
    
    # Determine quarter from month
    if [ $MONTH -le 3 ]; then Q="Q1"
    elif [ $MONTH -le 6 ]; then Q="Q2"
    elif [ $MONTH -le 9 ]; then Q="Q3"
    else Q="Q4"
    fi
    
    # 2. Calculate Stage Theme
    case $DAY_OF_WEEK in
        Monday|Wednesday|Saturday)
            STAGE_THEME="Front Stage"
            STAGE_FOCUS="Meetings, calls, support, emails"
            ;;
        Thursday|Sunday)
            STAGE_THEME="Back Stage"
            STAGE_FOCUS="Maintenance, bills, bug fixes, organizing"
            ;;
        Tuesday|Friday)
            STAGE_THEME="Off Stage"
            STAGE_FOCUS="Personal time, nature, friends, reading"
            ;;
    esac
    
    # 3. Plan File Paths
    YEAR_PLAN="vault/plans/${YEAR}_00.md"
    QUARTER_PLAN="vault/plans/${YEAR}_${Q}_00.md"
    MONTH_PLAN="vault/plans/${YEAR}_${Q}_${MONTH}_00.md"
    WEEK_PLAN="vault/plans/${YEAR}_${Q}_${MONTH}_W${WEEK}_00.md"
    REVIEW_FILE="vault/plans/${YEAR}_${Q}_${MONTH}_W${WEEK}_${DAY}.md"

    # Create daily plan from template if it doesn't exist
    if [ ! -f "$REVIEW_FILE" ]; then
        TEMPLATE_FILE="vault/templates/daily-plan.md"
        if [ -f "$TEMPLATE_FILE" ]; then
            echo "ğŸ“ Creating daily plan from template..."
            mkdir -p "$(dirname "$REVIEW_FILE")"

            # Get additional date variables for template
            MONTH_NAME=$(TZ=$TIMEZONE date '+%B')
            FULL_DATE="$(TZ=$TIMEZONE date '+%B %d, %Y')"

            # Copy template and replace variables
            cp "$TEMPLATE_FILE" "$REVIEW_FILE"

            # Replace template variables
            sed -i '' \
                -e "s/{{DAY_OF_WEEK}}/$DAY_OF_WEEK/g" \
                -e "s/{{MONTH_NAME}}/$MONTH_NAME/g" \
                -e "s/{{DAY}}/$DAY/g" \
                -e "s/{{YEAR}}/$YEAR/g" \
                -e "s/{{FULL_DATE}}/$FULL_DATE/g" \
                -e "s/{{STAGE_THEME}}/$STAGE_THEME/g" \
                -e "s/{{STAGE_FOCUS}}/$STAGE_FOCUS/g" \
                -e 's/{{PRIORITIES_FROM_DATABASE}}//g' \
                -e 's/{{MORNING_TIME_BLOCKS}}//g' \
                -e 's/{{AFTERNOON_TIME_BLOCKS}}//g' \
                -e 's/{{EVENING_TIME_BLOCKS}}//g' \
                "$REVIEW_FILE" 2>/dev/null || \
            sed -i \
                -e "s/{{DAY_OF_WEEK}}/$DAY_OF_WEEK/g" \
                -e "s/{{MONTH_NAME}}/$MONTH_NAME/g" \
                -e "s/{{DAY}}/$DAY/g" \
                -e "s/{{YEAR}}/$YEAR/g" \
                -e "s/{{FULL_DATE}}/$FULL_DATE/g" \
                -e "s/{{STAGE_THEME}}/$STAGE_THEME/g" \
                -e "s/{{STAGE_FOCUS}}/$STAGE_FOCUS/g" \
                -e 's/{{PRIORITIES_FROM_DATABASE}}//g' \
                -e 's/{{MORNING_TIME_BLOCKS}}//g' \
                -e 's/{{AFTERNOON_TIME_BLOCKS}}//g' \
                -e 's/{{EVENING_TIME_BLOCKS}}//g' \
                "$REVIEW_FILE"

            echo "âœ… Created daily plan: $REVIEW_FILE"
            echo ""
        fi
    fi
    
    # Check which plans exist
    EXISTING_PLANS=""
    [ -f "$YEAR_PLAN" ] && EXISTING_PLANS="${EXISTING_PLANS}- Year plan: $YEAR_PLAN\n"
    [ -f "$QUARTER_PLAN" ] && EXISTING_PLANS="${EXISTING_PLANS}- Quarter plan: $QUARTER_PLAN\n"
    [ -f "$MONTH_PLAN" ] && EXISTING_PLANS="${EXISTING_PLANS}- Month plan: $MONTH_PLAN\n"
    [ -f "$WEEK_PLAN" ] && EXISTING_PLANS="${EXISTING_PLANS}- Week plan: $WEEK_PLAN\n"
    
    # Check if today's review exists
    REVIEW_STATUS="new"
    if [ -f "$REVIEW_FILE" ]; then
        REVIEW_STATUS="exists"
    fi
    
    # 4. Task Stats from markdown files
    # Count tasks directly from markdown files
    TASK_COUNT=$(find vault -name "*.md" -type f -not -path "*/templates/*" 2>/dev/null | xargs grep -h "^- \[ \]" 2>/dev/null | wc -l | tr -d ' ' || echo "0")

    # Count overdue tasks (with ğŸ“… due or â³ scheduled dates before today)
    TODAY_DATE=$(date +%Y-%m-%d)
    OVERDUE_COUNT=$(find vault -name "*.md" -type f -not -path "*/templates/*" 2>/dev/null | xargs grep -hE "^- \[ \].*(ğŸ“…|â³)" 2>/dev/null | while read line; do
        # Extract date from line (either due ğŸ“… or scheduled â³)
        DATE=$(echo "$line" | grep -oE "(ğŸ“…|â³) [0-9]{4}-[0-9]{2}-[0-9]{2}" | grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" | head -1)
        if [[ -n "$DATE" ]] && [[ "$DATE" < "$TODAY_DATE" ]]; then
            echo "1"
        fi
    done | wc -l | tr -d ' ' || echo "0")

    # Count high priority tasks (ğŸ”º or â«)
    HIGH_PRIORITY_COUNT=$(find vault -name "*.md" -type f -not -path "*/templates/*" 2>/dev/null | xargs grep -hE "^- \[ \].*(ğŸ”º|â«)" 2>/dev/null | wc -l | tr -d ' ' || echo "0")
    
    if [ -n "$DIRECT_REQUEST" ]; then
        # Direct request mode - skip the full review
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“ Review file: $REVIEW_FILE"
        echo ""
        echo "Starting focused Claude session..."
        echo "Request: $DIRECT_REQUEST"
        echo ""
        echo "ğŸ“Š Task Statistics from markdown:"
        echo "  â€¢ Active tasks: $TASK_COUNT"
        echo "  â€¢ Overdue: $OVERDUE_COUNT"
        echo "  â€¢ High priority: $HIGH_PRIORITY_COUNT"
        echo ""
        echo "Claude will:"
        echo "  â€¢ Review your markdown task files"
        echo "  â€¢ Check today's review if it exists"
        echo "  â€¢ Focus on your specific request"
        echo ""
        echo "ğŸ’¡ Useful commands during the session:"
        echo "  bin/mark-done 'task'  # Mark task complete"
        echo "  bin/progress 'note'   # Add progress note"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        # Create a prompt that includes context but focuses on the request
        if [ "$NON_INTERACTIVE" = true ]; then
            echo "ğŸ¤– Running Claude in non-interactive mode..."
            # Non-interactive mode - use -p flag
            # Create prompt in a variable first to avoid heredoc issues
            PROMPT="$(cat <<EOF
# Focused Work Session - NON-INTERACTIVE MODE

## CRITICAL: You are in NON-INTERACTIVE mode
- You have FULL PERMISSION to create, update, and modify files
- Do NOT ask for permission - execute the requested actions immediately
- The user ran this command specifically requesting: "${DIRECT_REQUEST}"
- Complete the task WITHOUT asking for confirmation

## Pre-Computed Context
- **Current Time**: $CURRENT_TIME
- **Date**: $CURRENT_DATE ($DAY_OF_WEEK)
- **Stage**: $STAGE_THEME - $STAGE_FOCUS
- **Timezone**: $TIMEZONE
- **Review File**: $REVIEW_FILE ($REVIEW_STATUS)
- **Active Tasks**: $TASK_COUNT (Overdue: $OVERDUE_COUNT, High Priority: $HIGH_PRIORITY_COUNT)

## Context Available
- SQLite database at .data/today.db with all current data

## Database Tables Available:
- task_cache: Tasks with titles, stages, due dates
- emails: Recent emails with subjects, senders, reply status
- calendar_events: Upcoming events with times, locations
- contacts: Contact information
- file_tracking: Recently modified files
- people_to_contact: People needing follow-up
- diary: Day One journal entries with text, dates, locations

## Direct Request from User
"${DIRECT_REQUEST}"

## YOUR TASK:
1. Query the database to understand current context
2. Check if today's review exists
3. EXECUTE THE REQUEST FULLY - if it says "update", then UPDATE the file
4. Do NOT ask "May I proceed?" or "Should I update?" - just DO IT
5. Complete the task and exit (this is non-interactive)

Execute the request NOW without asking for permission!
EOF
)"
            # Run Claude with the prompt, allowing file operations
            # Using dangerously-skip-permissions since this is a controlled environment
            claude -p --dangerously-skip-permissions "$PROMPT"
        else
            echo "ğŸ¤– Starting Claude focused session..."
            # Interactive mode - normal claude command
            claude "$(cat <<EOF
# Focused Work Session

## Pre-Computed Context
- **Current Time**: $CURRENT_TIME
- **Date**: $CURRENT_DATE ($DAY_OF_WEEK)
- **Stage**: $STAGE_THEME - $STAGE_FOCUS
- **Timezone**: $TIMEZONE
- **Review File**: $REVIEW_FILE ($REVIEW_STATUS)
- **Active Tasks**: $TASK_COUNT (Overdue: $OVERDUE_COUNT, High Priority: $HIGH_PRIORITY_COUNT)

## Existing Plans
$(echo -e "$EXISTING_PLANS")

## Context Available
- SQLite database at .data/today.db with all current data

## Database Tables Available:
- task_cache: Tasks with titles, stages, due dates
- emails: Recent emails with subjects, senders, reply status
- calendar_events: Upcoming events with times, locations
- contacts: Contact information
- file_tracking: Recently modified files
- people_to_contact: People needing follow-up
- diary: Day One journal entries with text, dates, locations

## Direct Request from User
"${DIRECT_REQUEST}"

Please:
1. Query the database to understand current context
2. Check if today's review exists to understand what's been done
3. Focus on helping with the specific request above
4. You can reference relevant tasks, projects, or information from the database
5. This is an interactive session - continue helping as needed

Let's get started with the request!
EOF
)"
        fi
    else
        # Normal review mode
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“ Review file: $REVIEW_FILE"
        echo ""
        echo "Starting interactive Claude session..."
        echo ""
        echo "ğŸ“Š Task Statistics from markdown:"
        echo "  â€¢ Active tasks: $TASK_COUNT"
        echo "  â€¢ Overdue: $OVERDUE_COUNT"
        echo "  â€¢ High priority: $HIGH_PRIORITY_COUNT"
        echo ""
        echo "Claude will:"
        echo "  â€¢ Review your markdown task files"
        echo "  â€¢ Create or update today's review file"
        echo "  â€¢ Provide recommendations"
        echo "  â€¢ Continue working with you as needed"
        echo ""
        echo "ğŸ’¡ Useful commands during the session:"
        echo "  bin/mark-done 'task'  # Mark task complete"
        echo "  bin/progress 'note'   # Add progress note"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        # Start Claude session with TODAY.md
        if [ "$NON_INTERACTIVE" = true ]; then
            echo "ğŸ¤– Running Claude in non-interactive mode..."
            # Add explicit permission for file operations in non-interactive mode
            PROMPT="$(cat <<EOF
## NON-INTERACTIVE MODE - FULL PERMISSIONS GRANTED

You are running in non-interactive mode. This means:
- You have FULL PERMISSION to create and update all files
- Do NOT ask for permission - just perform the requested actions
- Complete all tasks without waiting for user confirmation
- When instructed to update the review file, UPDATE IT immediately

## Pre-Computed Context (No calculations needed!)
- **Current Time**: $CURRENT_TIME
- **Date**: $CURRENT_DATE ($DAY_OF_WEEK)
- **Stage**: $STAGE_THEME - $STAGE_FOCUS
- **Timezone**: $TIMEZONE
- **Review File**: $REVIEW_FILE ($REVIEW_STATUS)
- **Active Tasks**: $TASK_COUNT (Overdue: $OVERDUE_COUNT, High Priority: $HIGH_PRIORITY_COUNT)

## Existing Plans
$(echo -e "$EXISTING_PLANS")

$(cat TODAY.md | sed '/^### ğŸ”´ CRITICAL FIRST STEPS ğŸ”´/,/^3\. \*\*Query Database/d')
EOF
)"
            # Run Claude with the prompt, allowing file operations
            # Using dangerously-skip-permissions since this is a controlled environment
            claude -p --dangerously-skip-permissions "$PROMPT"
        else
            echo "ğŸ¤– Starting Claude interactive session..."
            claude "$(cat <<EOF
# Daily Review Session

## Pre-Computed Context (No calculations needed!)
- **Current Time**: $CURRENT_TIME
- **Date**: $CURRENT_DATE ($DAY_OF_WEEK)
- **Stage**: $STAGE_THEME - $STAGE_FOCUS
- **Timezone**: $TIMEZONE
- **Review File**: $REVIEW_FILE ($REVIEW_STATUS)
- **Active Tasks**: $TASK_COUNT (Overdue: $OVERDUE_COUNT, High Priority: $HIGH_PRIORITY_COUNT)

## Existing Plans
$(echo -e "$EXISTING_PLANS")

$(cat TODAY.md | sed '1,/^## Session Instructions for Claude/d' | sed '/^### ğŸ”´ CRITICAL FIRST STEPS ğŸ”´/,/^3\. \*\*Query Database/d')
EOF
)"
        fi
    fi
    
    # After Claude session ends
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Claude session ended"
    echo ""
    echo "ğŸ“ Your review should be in: $REVIEW_FILE"
    echo ""
    echo "ğŸ’¡ Continue tracking progress with:"
    echo "   bin/mark-done 'task description'"
    echo "   bin/progress 'note'"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""