#!/usr/bin/env node

/**
 * Today - Daily review and planning tool
 *
 * Usage:
 *   bin/today [options] [command] [request]
 *   bin/today update                  # Update review file via API
 *   bin/today --no-sync               # Skip sync step
 *   bin/today "specific request"      # Focused session with request
 */

import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync, spawnSync } from 'child_process';
// DISABLED - used by vault init (createInterface), skeleton updates (createHash), API update (Anthropic)
// import { createInterface } from 'readline';
// import { createHash } from 'crypto';
// import Anthropic from '@anthropic-ai/sdk';

// Import shared modules
// DISABLED - getClaudeModel used by API update feature
// import { getTimezone, getClaudeModel, getFullConfig } from '../src/config.js';
import { getTimezone, getFullConfig } from '../src/config.js';
import { getAIInstructionsByType } from '../src/plugin-loader.js';
import { getPluginTypes, getAIMetadata, generateAIContextBlock } from '../src/plugin-schemas.js';
import { ensureHealthyDatabase } from '../src/db-health.js';
// DISABLED - used by vault/template features
// import {
//   getStageInfo,
//   getDailyPlanPath,
//   getTemplateVariables,
//   applyTemplateVariables,
// } from '../src/plan-utils.js';
import {
  getCurrentTime,
  // DISABLED - used by vault/template features
  // getDateComponents as getDateComponentsFromDateUtils,
  // addDaysToDate,
  // formatDate,
  // formatTime,
  formatFullDateTime,
  // getTimezoneOffset,
} from '../src/date-utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

// Change to project root
process.chdir(projectRoot);

// ============================================================================
// Date Helpers (DISABLED - used by vault/template features)
// ============================================================================

// /**
//  * Get date components for plan file naming.
//  * Uses timezone-aware utilities from src/date-utils.js.
//  */
// function getDateComponents(targetDate = null) {
//   const timezone = getTimezone();
//   const date = targetDate || getCurrentTime(timezone);
//   const components = getDateComponentsFromDateUtils(date);
//
//   // Convert string components to integers where needed for compatibility
//   return {
//     year: parseInt(components.year),
//     month: parseInt(components.month),
//     day: parseInt(components.day),
//     week: parseInt(components.week),
//     quarter: components.quarter,
//     timezone
//   };
// }
//
// function getReviewFilePath(targetDate = null) {
//   return getDailyPlanPath(getDateComponents(targetDate));
// }
//
// /**
//  * Get tomorrow's date in the configured timezone.
//  * Uses timezone-aware utilities from src/date-utils.js.
//  */
// function getTomorrowDate() {
//   const timezone = getTimezone();
//   const today = getCurrentTime(timezone);
//   return addDaysToDate(today, 1);
// }

// ============================================================================
// Vault Initialization (DISABLED - not yet migrated to plugin system)
// ============================================================================

// function checkVaultExists() {
//   if (fs.existsSync('vault')) return true;
//   if (!fs.existsSync('skeleton')) {
//     console.log('‚ùå Neither vault/ nor skeleton/ directory found.');
//     console.log('   Please ensure you have the complete Today repository.');
//     return false;
//   }
//
//   console.log('‚îÅ'.repeat(60));
//   console.log('üìÅ Vault directory not found');
//   console.log('‚îÅ'.repeat(60));
//   console.log();
//   console.log('The vault/ directory contains your personal notes, tasks, and plans.');
//   console.log('It is excluded from this repository because it\'s meant to be private.');
//   console.log();
//   console.log('Would you like to initialize a new vault from the skeleton template?');
//   console.log();
//
//   const rl = createInterface({ input: process.stdin, output: process.stdout });
//
//   return new Promise((resolve) => {
//     rl.question('Initialize vault? [y/N]: ', (answer) => {
//       rl.close();
//       if (answer.trim().toLowerCase() !== 'y') {
//         console.log();
//         console.log('Vault not initialized. You can manually copy the skeleton:');
//         console.log('  cp -r skeleton vault');
//         console.log();
//         resolve(false);
//         return;
//       }
//
//       console.log();
//       console.log('üì¶ Initializing vault from skeleton...');
//
//       try {
//         execSync('cp -r skeleton vault', { stdio: 'inherit' });
//         // Remove .gitkeep files
//         execSync('find vault -name ".gitkeep" -delete 2>/dev/null || true', { stdio: 'pipe' });
//         console.log('‚úÖ Vault initialized successfully!');
//         console.log();
//         console.log('‚îÅ'.repeat(60));
//         console.log('üìù Next steps:');
//         console.log('‚îÅ'.repeat(60));
//         console.log();
//         console.log('1. Initialize a git repository for version control:');
//         console.log('   cd vault && git init && git add . && git commit -m \'Initial vault\'');
//         console.log();
//         console.log('2. Set up sync (optional but recommended):');
//         console.log('   - Resilio Sync, Syncthing, or a private git remote');
//         console.log();
//         console.log('3. If using Obsidian, install recommended plugins:');
//         console.log('   - Dataview, Tasks, Templater, Calendar, Periodic Notes');
//         console.log();
//         console.log('See vault/README.md for detailed documentation.');
//         console.log('‚îÅ'.repeat(60));
//         console.log();
//         resolve(true);
//       } catch (e) {
//         console.log(`‚ùå Failed to initialize vault: ${e.message}`);
//         resolve(false);
//       }
//     });
//   });
// }

// ============================================================================
// Skeleton Updates Check (DISABLED - not yet migrated to plugin system)
// ============================================================================

// function checkSkeletonUpdates() {
//   if (!fs.existsSync('vault') || !fs.existsSync('skeleton')) return;
//
//   const trackingFile = '.skeleton-hashes';
//   const trackedFiles = [
//     'scripts/time-tracking-widget.js',
//     'scripts/upcoming-events-widget.js',
//     'templates/daily-plan.md',
//     'templates/project.md',
//     '.obsidian/snippets/app-wide.css',
//   ];
//
//   // Load previous hashes
//   const previousHashes = {};
//   if (fs.existsSync(trackingFile)) {
//     try {
//       const content = fs.readFileSync(trackingFile, 'utf8');
//       for (const line of content.split('\n')) {
//         const parts = line.trim().split(':');
//         if (parts.length === 2) {
//           previousHashes[parts[0]] = parts[1];
//         }
//       }
//     } catch {
//       // Ignore
//     }
//   }
//
//   const updatesAvailable = [];
//
//   for (const relPath of trackedFiles) {
//     const skeletonFile = path.join('skeleton', relPath);
//     const vaultFile = path.join('vault', relPath);
//
//     if (!fs.existsSync(skeletonFile)) continue;
//
//     // Calculate current skeleton hash
//     const currentHash = createHash('md5').update(fs.readFileSync(skeletonFile)).digest('hex');
//
//     // Check if skeleton has changed since last check
//     if (previousHashes[relPath] === currentHash) continue;
//
//     // Check if vault file exists and differs from skeleton
//     if (fs.existsSync(vaultFile)) {
//       const vaultHash = createHash('md5').update(fs.readFileSync(vaultFile)).digest('hex');
//       if (currentHash !== vaultHash) {
//         updatesAvailable.push(relPath);
//       }
//     }
//
//     // Update tracking
//     previousHashes[relPath] = currentHash;
//   }
//
//   // Save updated hashes
//   const hashLines = Object.entries(previousHashes).map(([k, v]) => `${k}:${v}`).join('\n');
//   fs.writeFileSync(trackingFile, hashLines);
//
//   if (updatesAvailable.length > 0) {
//     console.log('‚îÅ'.repeat(60));
//     console.log('üì¶ Skeleton updates available');
//     console.log('‚îÅ'.repeat(60));
//     console.log();
//     console.log('The following skeleton files have been updated:');
//     for (const p of updatesAvailable) {
//       console.log(`  - ${p}`);
//     }
//     console.log();
//     console.log('To review and merge updates:');
//     console.log('  diff vault/<file> skeleton/<file>');
//     console.log('  cp skeleton/<file> vault/<file>');
//     console.log();
//     console.log('‚îÅ'.repeat(60));
//     console.log();
//   }
// }

// ============================================================================
// Sync (DISABLED - replaced by plugin system: bin/plugins sync)
// ============================================================================

// function runSync(skipSync = false) {
//   if (skipSync) {
//     console.log('‚è≠Ô∏è  Skipping sync step');
//     return;
//   }
//
//   console.log('üîÑ Syncing data sources...');
//   try {
//     execSync('bin/sync', { stdio: 'inherit' });
//   } catch {
//     // Continue even if sync fails
//   }
// }

// ============================================================================
// Database Check
// ============================================================================

async function checkAndRecoverDatabase() {
  console.log('üîç Checking database health...');
  const result = await ensureHealthyDatabase({ verbose: true });

  if (!result.success) {
    console.error('‚ùå Database check failed');
    process.exit(1);
  }

  if (result.recreated) {
    console.log('‚ÑπÔ∏è  Run bin/sync to populate data from external sources\n');
  }
}

// ============================================================================
// Claude Auth Check (DISABLED - can be re-enabled when needed)
// ============================================================================

// function checkClaudeAuth() {
//   console.log('üîê Checking Claude authentication...');
//   try {
//     const result = spawnSync('claude', ['-p', 'Say "ok"'], { encoding: 'utf8' });
//     const output = (result.stdout || '') + (result.stderr || '');
//
//     if (output.includes('Invalid API key') || output.includes('Please run /login') || output.includes('not authenticated')) {
//       console.log('\n‚ö†Ô∏è  Claude CLI is not authenticated!');
//       console.log('‚îÅ'.repeat(50));
//       console.log('\nClaude is essential for daily reviews.');
//       console.log('Please authenticate now by running:\n');
//       console.log('  claude\n');
//       console.log('Then follow the browser prompt to login.');
//       console.log('After authentication, run \'bin/today\' again.');
//       console.log('‚îÅ'.repeat(50));
//       process.exit(1);
//     }
//
//     console.log('‚úÖ Claude is authenticated\n');
//   } catch {
//     console.log('‚úÖ Claude check passed\n');
//   }
// }

// ============================================================================
// Time Tracking Widgets (DISABLED - depends on vault/template features)
// ============================================================================

// function ensureTimeTrackingWidgets(dryRun = false) {
//   console.log('‚è±Ô∏è  Checking time tracking widgets...');
//
//   const { year, month, week, quarter, timezone } = getDateComponents();
//
//   // Define plan files with their date ranges
//   const quarterEndDays = [31, 30, 30, 31];
//   const quarterNum = parseInt(quarter.slice(1));
//   const planFiles = [
//     [`vault/plans/${year}_00.md`, `${year}-01-01`, `${year}-12-31`, 'Year'],
//     [`vault/plans/${year}_${quarter}_00.md`,
//     `${year}-${String((quarterNum - 1) * 3 + 1).padStart(2, '0')}-01`,
//     `${year}-${String(quarterNum * 3).padStart(2, '0')}-${quarterEndDays[quarterNum - 1]}`,
//       quarter],
//     [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_00.md`,
//     `${year}-${String(month).padStart(2, '0')}-01`,
//     `${year}-${String(month).padStart(2, '0')}-${new Date(year, month, 0).getDate()}`,
//     new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' })],
//     [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_W${String(week).padStart(2, '0')}_00.md`,
//       null, null, `Week ${week}`],
//   ];
//
//   // Calculate week start/end for the week file
//   try {
//     const weekStart = execSync(`TZ=${timezone} date -d "$(date +%Y-W${String(week).padStart(2, '0')}-1)" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
//     const weekEnd = execSync(`TZ=${timezone} date -d "${weekStart} +6 days" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
//     planFiles[3][1] = weekStart;
//     planFiles[3][2] = weekEnd;
//   } catch {
//     // Skip week file if we can't calculate dates
//   }
//
//   const filesUpdated = [];
//
//   for (const [filePath, startDate, endDate, periodName] of planFiles) {
//     if (!fs.existsSync(filePath)) continue;
//     if (!startDate || !endDate) continue;
//
//     const content = fs.readFileSync(filePath, 'utf8');
//
//     // Check if time tracking widget already exists
//     if (content.includes('scripts/time-tracking-widget')) continue;
//     if (/## ‚è±Ô∏è Time Tracking/.test(content)) continue;
//
//     const widgetSection = `
// ## ‚è±Ô∏è Time Tracking - ${periodName}
//
// \`\`\`dataviewjs
// await dv.view("scripts/time-tracking-widget", { startDate: '${startDate}', endDate: '${endDate}' });
// \`\`\`
// `;
//
//     const updatedContent = content.trimEnd() + '\n' + widgetSection + '\n';
//
//     if (dryRun) {
//       console.log(`   Would add time tracking to: ${filePath}`);
//     } else {
//       fs.writeFileSync(filePath, updatedContent);
//       filesUpdated.push([periodName, filePath]);
//     }
//   }
//
//   if (filesUpdated.length > 0 && !dryRun) {
//     console.log(`‚úÖ Added time tracking widgets to ${filesUpdated.length} file(s):`);
//     for (const [periodName, filePath] of filesUpdated) {
//       console.log(`   ${periodName}: ${filePath}`);
//     }
//   } else {
//     console.log('‚úÖ All plan files have time tracking widgets');
//   }
//
//   console.log();
// }

// ============================================================================
// Template Processing (DISABLED - depends on vault/template features)
// ============================================================================

// function createFileFromTemplate(filePath, targetDate, isTomorrow = false) {
//   const templateFile = 'vault/templates/daily-plan.md';
//   if (!fs.existsSync(templateFile)) return;
//
//   // Ensure directory exists
//   fs.mkdirSync(path.dirname(filePath), { recursive: true });
//
//   let content = fs.readFileSync(templateFile, 'utf8');
//
//   // Use shared utilities for template variables
//   const replacements = getTemplateVariables(targetDate);
//   content = applyTemplateVariables(content, replacements);
//
//   // Add draft note for tomorrow's plan
//   if (isTomorrow) {
//     const [, stageFocus] = getStageInfo(targetDate);
//     const draftNote = '\n> [!info] Draft Plan\n> This is a preliminary plan for tomorrow. It will be refined throughout today.\n\n';
//     content = content.replace('**Theme:** ' + stageFocus, '**Theme:** ' + stageFocus + draftNote);
//   }
//
//   fs.writeFileSync(filePath, content);
// }

// DISABLED - depends on template/vault features above
// function createReviewFromTemplate() {
//   const filesCreated = [];
//
//   // Create for today
//   const todayFile = getReviewFilePath();
//   if (!fs.existsSync(todayFile)) {
//     console.log('üìù Creating today\'s plan from template...');
//     createFileFromTemplate(todayFile, new Date(), false);
//     filesCreated.push(['today', todayFile]);
//   }
//
//   // Create for tomorrow
//   const tomorrow = getTomorrowDate();
//   const tomorrowFile = getReviewFilePath(tomorrow);
//   if (!fs.existsSync(tomorrowFile)) {
//     console.log('üìù Creating tomorrow\'s plan from template...');
//     createFileFromTemplate(tomorrowFile, tomorrow, true);
//     filesCreated.push(['tomorrow', tomorrowFile]);
//   }
//
//   if (filesCreated.length > 0) {
//     console.log('‚úÖ Created review files:');
//     for (const [label, p] of filesCreated) {
//       console.log(`   ${label.charAt(0).toUpperCase() + label.slice(1)}: ${p}`);
//     }
//     console.log();
//   }
//
//   return todayFile;
// }

// ============================================================================
// API Update (DISABLED - depends on template/vault features and Anthropic import)
// ============================================================================

// async function updateReviewFile(dryRun = false) {
//   const apiKey = process.env.TODAY_ANTHROPIC_KEY;
//   if (!apiKey) {
//     console.log('‚ùå TODAY_ANTHROPIC_KEY not found in environment');
//     console.log('Please ensure it\'s set in .env and encrypted with dotenvx');
//     process.exit(1);
//   }
//
//   ensureTimeTrackingWidgets(dryRun);
//
//   // Update today's file
//   const todayFile = getReviewFilePath();
//   if (!fs.existsSync(todayFile)) {
//     console.log(`‚ö†Ô∏è  Today's file not found: ${todayFile}`);
//     console.log('Skipping today\'s update');
//   } else {
//     console.log(`üìä Updating today's plan: ${todayFile}...`);
//     if (dryRun) console.log('üîç DRY RUN MODE - No changes will be made');
//     await updateSingleFile(todayFile, false, dryRun, apiKey);
//   }
//
//   // Update tomorrow's file
//   const tomorrow = getTomorrowDate();
//   const tomorrowFile = getReviewFilePath(tomorrow);
//   if (!fs.existsSync(tomorrowFile)) {
//     console.log(`‚ö†Ô∏è  Tomorrow's file not found: ${tomorrowFile}`);
//     console.log('Skipping tomorrow\'s update');
//   } else {
//     console.log(`üìä Updating tomorrow's plan: ${tomorrowFile}...`);
//     await updateSingleFile(tomorrowFile, true, dryRun, apiKey);
//   }
// }

// async function updateSingleFile(reviewFile, isTomorrow, dryRun, apiKey) {
//   // Gather data from all plugin types (including utility)
//   const dailyData = await getDataContext();
//
//   const originalContent = fs.readFileSync(reviewFile, 'utf8');
//   const backupContent = originalContent;
//   const originalLines = originalContent.split('\n').length;
//
//   const timezone = getTimezone();
//   const now = getCurrentTime(timezone);
//   const currentTime = formatTime(now, timezone);
//   const currentDate = formatDate(now);
//   const tzOffset = getTimezoneOffset(now, timezone);
//
//   let prompt;
//   if (isTomorrow) {
//     prompt = `You are updating TOMORROW's daily plan with fresh priorities from the database.
//
// CURRENT TIME: ${currentTime} ET
// CURRENT DATE: ${currentDate}
//
// CURRENT FILE CONTENT (Tomorrow's Plan):
// ${originalContent}
//
// CURRENT DATABASE DATA (tasks, events, emails, etc.):
// ${dailyData.slice(0, 5000)}
//
// YOUR TASK:
// Refresh the "Top Priorities" section with current database data.
// This is a DRAFT plan for tomorrow that gets refined throughout today.
//
// Focus on:
// 1. Overdue tasks that will carry into tomorrow
// 2. Tasks scheduled for tomorrow
// 3. Calendar events scheduled for tomorrow
// 4. High-priority items that need attention
//
// RETURN A JSON OBJECT with updated priorities section:
// {
//   "priorities_update": "### üö® Critical (Do First)\\n\\n- [ ] Task 1\\n- [ ] Task 2\\n\\n### ‚ö° Quick Wins...\\n",
//   "notes": "Brief note about what changed"
// }
//
// IMPORTANT:
// - Keep it lightweight - this is a draft
// - Focus on actionable items
// - Use simple checkboxes: "- [ ] Task description"
// - DO NOT add due dates (üìÖ), scheduled dates (‚è≥), or recurrence (üîÅ) to tasks
// - Created date (‚ûï) is fine - scripts add this automatically
// - Plan files use simple tasks - scheduling belongs in project/topic files only`;
//   } else {
//     prompt = `You are updating TODAY's daily plan with a progress update.
//
// CURRENT TIME: ${currentTime} ET
// CURRENT DATE: ${currentDate}
//
// CURRENT FILE CONTENT:
// ${originalContent}
//
// CURRENT DATABASE DATA (tasks, events, emails, etc.):
// ${dailyData.slice(0, 5000)}
//
// YOUR TASK:
// Create a new Progress Update section to append to the end of the file.
// Compare the current file with the database to see what's changed or been accomplished.
//
// üö® CRITICAL: The database includes DETAILED TIME TRACKING DATA showing what work has been done today.
//    - Time tracking is THE GROUND TRUTH of productivity
//    - Physical work, meetings, coordination, deep work sessions are all tracked there
//    - NEVER assume "zero progress" without checking the time tracking data first
//    - Checkbox completions are NOT the primary measure of productivity
//
// This should summarize:
// 1. What's been accomplished since the last update - CHECK TIME TRACKING DATA FIRST (tasks checked off, workouts done, meetings attended, time tracked)
// 2. Current status of high-priority items
// 3. Any new events, emails, or tasks that need attention
// 4. Overall progress and any blockers
//
// RETURN A JSON OBJECT:
// {
//   "progress_update": "<!-- PROGRESS_UPDATE -->\\n> [!success] üìä Progress Update (${currentTime})\\n>\\n> *${currentDate} HH:MM ${tzOffset}*\\n>\\n> - Brief summary of what's been done\\n> - Current status\\n> - What's next or any blockers\\n<!-- /PROGRESS_UPDATE -->",
//   "tasks_to_check": ["exact task text to mark done (only if you see clear evidence in the file they're completed)"]
// }
//
// NOTE: The progress_update should use the callout format with:
// - "<!-- PROGRESS_UPDATE -->" as the opening marker
// - "> [!success] üìä Progress Update (TIME)" as the header
// - "> " prefix for all lines in the callout
// - "*italicized timestamp*" on the second line
// - "<!-- /PROGRESS_UPDATE -->" as the closing marker
//
// IMPORTANT:
// - Create a MEANINGFUL progress update - there's always something to report
// - Look at completed tasks in the file (marked [x]) since the last Progress Update
// - The update should be 2-4 bullet points, concise but informative
// - Only mark tasks as done if you see clear evidence (like workout exercises checked off)
// - Use the exact timezone offset in the timestamp: ${tzOffset}
// - Use simple checkboxes: "- [ ] Task description"
// - DO NOT add due dates (üìÖ), scheduled dates (‚è≥), or recurrence (üîÅ) to tasks
// - Created date (‚ûï) is fine - scripts add this automatically`;
//   }
//
//   const client = new Anthropic({ apiKey });
//
//   try {
//     const model = getClaudeModel();
//     const response = await client.messages.create({
//       model,
//       max_tokens: 2000,
//       temperature: 0,
//       messages: [{ role: 'user', content: prompt }],
//     });
//
//     let responseText = response.content[0].text;
//
//     // Try to parse as JSON
//     let edits;
//     try {
//       let jsonStr;
//       if (responseText.includes('```json')) {
//         jsonStr = responseText.split('```json')[1].split('```')[0];
//       } else if (responseText.includes('```')) {
//         jsonStr = responseText.split('```')[1].split('```')[0];
//       } else if (responseText.includes('{')) {
//         const start = responseText.indexOf('{');
//         let count = 0;
//         let end = start;
//         for (let i = start; i < responseText.length; i++) {
//           if (responseText[i] === '{') count++;
//           else if (responseText[i] === '}') {
//             count--;
//             if (count === 0) {
//               end = i + 1;
//               break;
//             }
//           }
//         }
//         jsonStr = responseText.slice(start, end);
//       } else {
//         jsonStr = responseText;
//       }
//       edits = JSON.parse(jsonStr);
//     } catch (e) {
//       console.log(`‚ö†Ô∏è  Failed to parse Claude's response as JSON: ${e.message}`);
//       console.log(`Response: ${responseText.slice(0, 200)}...`);
//       process.exit(1);
//     }
//
//     let updatedContent = originalContent;
//
//     if (isTomorrow) {
//       if (edits.priorities_update) {
//         const replacement = `## üìã Top Priorities\n\n${edits.priorities_update}\n`;
//         updatedContent = updatedContent.replace(/## üìã Top Priorities\n\n.*?(?=\n## |$)/s, replacement);
//       }
//     } else {
//       if (edits.progress_update) {
//         updatedContent = updatedContent.trimEnd() + '\n\n' + edits.progress_update + '\n';
//       }
//
//       if (edits.tasks_to_check) {
//         for (const task of edits.tasks_to_check) {
//           const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
//           const uncheckedPattern = new RegExp(`- \\[ \\] ${escapedTask}`);
//           if (uncheckedPattern.test(updatedContent)) {
//             updatedContent = updatedContent.replace(uncheckedPattern, `- [x] ${task} ‚úÖ ${currentDate}`);
//           }
//         }
//       }
//     }
//
//     // SAFETY CHECKS
//     const updatedLines = updatedContent.split('\n').length;
//     if (updatedLines < originalLines * 0.9) {
//       console.log(`‚ö†Ô∏è  Safety check failed: Updated file has ${updatedLines} lines vs original ${originalLines}`);
//       console.log('Aborting update to prevent data loss');
//       process.exit(1);
//     }
//
//     if (updatedContent.length < originalContent.length * 0.9) {
//       console.log('‚ö†Ô∏è  Safety check failed: Updated content is too short');
//       console.log(`Original: ${originalContent.length} chars, Updated: ${updatedContent.length} chars`);
//       process.exit(1);
//     }
//
//     if (dryRun) {
//       console.log('\nüìä Data context sent to AI:');
//       console.log('‚îÄ'.repeat(60));
//       console.log(dailyData.slice(0, 5000));
//       console.log('‚îÄ'.repeat(60));
//       console.log('\nüìù AI response (proposed changes):');
//       if (isTomorrow) {
//         console.log(`Priorities update:\n${(edits.priorities_update || 'None').slice(0, 200)}...`);
//         console.log(`\nNotes: ${edits.notes || 'None'}`);
//       } else {
//         console.log(`Progress update to append:\n${edits.progress_update || 'None'}`);
//         console.log(`\nTasks to check: ${JSON.stringify(edits.tasks_to_check || [])}`);
//       }
//       console.log('\n‚úÖ Dry run complete - no changes made');
//     } else {
//       fs.writeFileSync(reviewFile, updatedContent);
//
//       if (updatedContent !== originalContent) {
//         const fileType = isTomorrow ? "tomorrow's plan" : "today's plan";
//         console.log(`‚úÖ Updated ${fileType}: ${reviewFile}`);
//       } else {
//         console.log(`‚ö†Ô∏è  API returned no changes - ${reviewFile} unchanged`);
//         console.log('This might indicate the AI couldn\'t determine what to update.');
//       }
//     }
//   } catch (e) {
//     console.error(`‚ùå Error: ${e.message}`);
//     if (!dryRun) {
//       console.log('Restoring original content...');
//       fs.writeFileSync(reviewFile, backupContent);
//     }
//     process.exit(1);
//   }
// }

// ============================================================================
// Interactive Session
// ============================================================================

/**
 * Build data context for AI prompt
 * Groups data by plugin type with schema, instructions, and current data
 */
async function getDataContext() {
  try {
    const pluginTypes = getPluginTypes();
    const instructionsByType = await getAIInstructionsByType();
    const sections = [];

    for (const pluginType of pluginTypes) {
      const ai = getAIMetadata(pluginType);
      if (!ai) continue;

      // Context plugins are handled separately - run each plugin's read command
      if (pluginType === 'context') {
        const contextData = await getContextPluginsData(instructionsByType.get('context'));
        if (contextData) {
          sections.push(contextData);
        }
        continue;
      }

      const typeData = instructionsByType.get(pluginType);
      if (!typeData || typeData.sources.length === 0) continue;

      // Run the default command to get current data
      let currentData = '';
      try {
        console.log(`  ${ai.defaultCommand}`);
        currentData = execSync(ai.defaultCommand + ' 2>/dev/null', {
          encoding: 'utf8',
          timeout: 10000
        });
        // Filter out dotenvx noise
        currentData = currentData.split('\n')
          .filter(line => !line.includes('[dotenvx'))
          .join('\n');
      } catch {
        currentData = '(No data available)';
      }

      // Generate context block
      const block = generateAIContextBlock(pluginType, {
        userInstructions: typeData.instructions,
        currentData
      });

      if (block) {
        sections.push(block);
      }
    }

    if (sections.length === 0) return '';

    const intro = `# Data Sources

The following data is synced from external sources via the plugin system.
Each section shows current data and instructions for querying more.

- Run \`bin/plugins list\` to see available plugins
- Run \`bin/plugins sync\` to refresh data from all sources
- Run \`bin/plugins sync <plugin-name>\` to sync a specific plugin

`;

    return intro + sections.join('\n\n---\n\n');
  } catch (error) {
    // Silently fail if plugin system has issues
    return '';
  }
}

/**
 * Get data from context plugins by running their read commands
 */
async function getContextPluginsData(typeData) {
  if (!typeData || typeData.sources.length === 0) return null;

  const lines = ['## Contextual Information', ''];

  for (const sourceId of typeData.sources) {
    try {
      // sourceId format: "plugin-name/source-name"
      const [pluginName] = sourceId.split('/');
      const pluginPath = path.join(projectRoot, 'plugins', pluginName);
      const readScript = path.join(pluginPath, 'read.js');

      if (!fs.existsSync(readScript)) continue;

      // Run from project root so relative paths work correctly
      const output = execSync(`node "${readScript}"`, {
        cwd: projectRoot,
        encoding: 'utf8',
        timeout: 30000
      });

      const data = JSON.parse(output);

      // Format vault-changes output
      if (pluginName === 'vault-changes' && data.files && data.files.length > 0) {
        lines.push(`### Files Changed Today`);
        lines.push(`${data.count} file(s) modified or added today:`);
        lines.push('');
        for (const file of data.files) {
          if (file.title) {
            lines.push(`- **${file.path}**: ${file.title}`);
          } else {
            lines.push(`- **${file.path}**`);
          }
        }
        lines.push('');
      }
      // Add other utility plugin formatters as needed
    } catch {
      // Silently continue if plugin fails
    }
  }

  return lines.length > 2 ? lines.join('\n') : null;
}

async function runInteractiveSession(directRequest = null, nonInteractive = false, dryRun = false) {
  // DISABLED - depends on getReviewFilePath/getTomorrowDate
  // const todayFile = getReviewFilePath();
  // const tomorrowFile = getReviewFilePath(getTomorrowDate());
  const timezone = getTimezone();

  const now = getCurrentTime(timezone);
  const currentTime = formatFullDateTime(now, timezone);

  const dataContext = await getDataContext();
  const config = getFullConfig();

  // Build user profile section
  const profile = config.profile || {};
  const profileLines = [];
  if (profile.name) profileLines.push(`- **Name**: ${profile.name}`);
  if (config.location) profileLines.push(`- **Location**: ${config.location}`);
  if (profile.home_location && profile.home_location !== config.location) {
    profileLines.push(`- **Home**: ${profile.home_location}`);
  }
  profileLines.push(`- **Timezone**: ${timezone}`);
  if (profile.vocation) profileLines.push(`- **Vocation**: ${profile.vocation}`);
  if (profile.wake_time) profileLines.push(`- **Wake time**: ${profile.wake_time}`);
  if (profile.bed_time) profileLines.push(`- **Bed time**: ${profile.bed_time}`);

  // Build the context section (user info and data sources)
  const contextSection = `## Pre-Computed Context
- **Current Time**: ${currentTime}

## Database
- **Path**: .data/today.db (SQLite)
- **Direct queries**: sqlite3 .data/today.db "SELECT ..."

## User Profile
${profileLines.join('\n')}

${dataContext}`;

  // Build the prompt
  let prompt;
  const intro = `You are an agent helping a user. Information about the user and the user's context is provided below.`;

  if (directRequest) {
    const requestSection = `The user's request is:

> ${directRequest}`;

    if (nonInteractive) {
      prompt = `${intro}

## CRITICAL: You are in NON-INTERACTIVE mode
- You have FULL PERMISSION to create, update, and modify files
- Do NOT ask for permission - execute the requested actions immediately
- Complete the task WITHOUT asking for confirmation

${requestSection}

${contextSection}`;
    } else {
      prompt = `${intro}

${requestSection}

${contextSection}`;
    }
  } else {
    prompt = `${intro}

Look at the user's current situation and offer suggestions of what the user should do.

${contextSection}`;
  }

  // Dry run - just output the prompt
  if (dryRun) {
    console.log(prompt);
    return;
  }

  // Actually run Claude
  if (directRequest && nonInteractive) {
    console.log('ü§ñ Running Claude in non-interactive mode...');
    try {
      spawnSync('timeout', ['600', 'claude', '--print', '--dangerously-skip-permissions', prompt], { stdio: 'inherit' });
    } catch (e) {
      console.error(`ERROR: Command timed out or failed after 10 minutes: ${e.message}`);
      process.exit(1);
    }
  } else if (directRequest) {
    console.log(`üìä Starting focused session: ${directRequest}\n`);
    console.log('ü§ñ Starting Claude focused session...');
    spawnSync('claude', [prompt], { stdio: 'inherit' });
  } else {
    console.log('ü§ñ Starting Claude daily review session...');
    spawnSync('claude', [prompt], { stdio: 'inherit' });
  }

  // Session end summary
  console.log('\n' + '‚îÅ'.repeat(50));
  console.log('‚úÖ Claude session ended\n');
  // DISABLED - depends on getReviewFilePath/getTomorrowDate
  // console.log('üìù Your plans are in:');
  // console.log(`   Today: ${todayFile}`);
  // console.log(`   Tomorrow: ${tomorrowFile}\n`);
  console.log('üí° Continue tracking progress with:');
  console.log('   bin/progress \'note\'');
  // DISABLED - update command depends on disabled features
  // console.log('   bin/today update  # Update both files with progress');
  console.log('‚îÅ'.repeat(50) + '\n');
}

// ============================================================================
// Main
// ============================================================================

function showHelp() {
  console.log(`Today - Daily review and planning tool

Usage:
  bin/today [options] [command] [request]

Commands:
  (none)      Start interactive daily review session with Claude
  now         Quick "what should I do right now?" session
  dry-run     Show the prompt that would be sent to Claude (no API call)
  init        (DISABLED) Initialize review file hierarchy
  update      (DISABLED) Update review files via Anthropic API

Options:
  --no-sync         Skip sync step (faster startup)
  --non-interactive Run in non-interactive mode (for automation)
  -h, --help        Show this help message

Examples:
  bin/today                           # Start daily review
  bin/today now                       # Quick "what should I do now?" session
  bin/today dry-run                   # Show prompt without running Claude
  bin/today "fix the bug in login"    # Focused session with specific request

Files:
  Today's plan:    vault/plans/YYYY_QQ_MM_W##_DD.md
  Tomorrow's plan: vault/plans/YYYY_QQ_MM_W##_DD.md (next day)
`);
}

async function main() {
  const args = process.argv.slice(2);

  // Handle help early
  if (args.includes('-h') || args.includes('--help')) {
    showHelp();
    return;
  }

  // Parse arguments
  let command = null;
  let request = [];
  let noSync = false;
  let nonInteractive = false;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--no-sync') {
      noSync = true;
    } else if (args[i] === '--non-interactive') {
      nonInteractive = true;
    } else if (!command && ['init', 'update', 'dry-run', 'now'].includes(args[i])) {
      command = args[i];
    } else {
      request.push(args[i]);
    }
  }

  let directRequest = request.length > 0 ? request.join(' ') : null;

  // DISABLED - checkVaultExists not yet migrated to plugin system
  // // Check if vault exists (unless in non-interactive mode)
  // if (!nonInteractive) {
  //   const vaultExists = await checkVaultExists();
  //   if (!vaultExists) {
  //     console.log('Cannot continue without vault directory.');
  //     process.exit(1);
  //   }
  // }

  // DISABLED - checkSkeletonUpdates not yet migrated to plugin system
  // // Check skeleton updates (unless in non-interactive mode)
  // if (!nonInteractive) {
  //   checkSkeletonUpdates();
  // }

  // Always check database health first (except for help which returns early)
  await checkAndRecoverDatabase();

  // DISABLED - init command depends on template features
  // // Handle init command
  // if (command === 'init') {
  //   console.log('üìÖ Initializing review file hierarchy...');
  //   createReviewFromTemplate();
  //   console.log('‚úÖ Review hierarchy is ready!');
  //   return;
  // }

  // DISABLED - update command depends on API update features
  // // Handle update command
  // if (command === 'update') {
  //   console.log('üìä Running automated review update...');
  //   if (!noSync) runSync();
  //   await updateReviewFile(false);
  //   return;
  // }

  // Handle dry-run command - show what prompt would be sent to AI
  if (command === 'dry-run') {
    await checkAndRecoverDatabase();
    await runInteractiveSession(directRequest, nonInteractive, true /* dryRun */);
    return;
  }

  // Handle now command - quick "what should I do right now?" query
  if (command === 'now') {
    directRequest = 'What should I do *right now*?';
  }

  // Display appropriate message
  if (directRequest) {
    console.log(`üìä Starting focused session: ${directRequest}`);
  } else {
    console.log('üìä Starting daily review process...');
  }

  // DISABLED - checkClaudeAuth not yet migrated
  // // Check Claude authentication (unless non-interactive)
  // if (!nonInteractive) {
  //   checkClaudeAuth();
  // }

  // DISABLED - runSync replaced by bin/plugins sync
  // // Run sync (unless skipped)
  // if (!noSync) {
  //   runSync(false);
  // } else {
  //   console.log('‚ö†Ô∏è  Skipping sync (--no-sync flag provided)');
  // }

  // DISABLED - createReviewFromTemplate depends on template features
  // // Create review file from template if needed
  // createReviewFromTemplate();

  // Run the appropriate session
  await runInteractiveSession(directRequest, nonInteractive);
}

main().catch((e) => {
  console.error(`‚ùå Fatal error: ${e.message}`);
  process.exit(1);
});
