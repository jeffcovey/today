#!/usr/bin/env node

/**
 * Today - Daily review and planning tool
 *
 * Usage:
 *   bin/today [options] [command] [request]
 *   bin/today update                  # Update review file via API
 *   bin/today --no-sync               # Skip sync step
 *   bin/today "specific request"      # Focused session with request
 *
 * Ported from Python to Node.js for codebase consistency.
 */

import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync, spawnSync } from 'child_process';
import { createInterface } from 'readline';
import { createHash } from 'crypto';
import Anthropic from '@anthropic-ai/sdk';

// Import shared modules
import { getTimezone, getConfig, getClaudeModel } from '../src/config.js';
import {
  getQuarter,
  getISOWeek,
  getDateComponents as getDateComponentsFromDate,
  STAGE_MAPPING,
  getStageInfo,
  getDailyPlanPath,
  getPlanFilePath,
  getPlanFileHierarchy,
  walkMarkdownFiles,
  isHighPriority,
  extractTaskDate,
  parseUncompletedTasks,
  getTaskStatistics,
  extractJsonFromResponse,
  getTemplateVariables,
  applyTemplateVariables,
} from '../src/plan-utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

// Change to project root
process.chdir(projectRoot);

// ============================================================================
// Date Helpers
// ============================================================================

/**
 * Get date components, using shell for current date to respect timezone config.
 * For a specific date, delegates to shared utility.
 */
function getDateComponents(targetDate = null) {
  const timezone = getTimezone();

  if (targetDate) {
    // Use shared utility for specific dates
    const components = getDateComponentsFromDate(targetDate);
    return { ...components, timezone };
  }

  // Get current date in configured timezone using shell
  try {
    const result = execSync(`TZ=${timezone} date "+%Y %m %d %V"`, { encoding: 'utf8' });
    const [yearStr, monthStr, dayStr, weekStr] = result.trim().split(' ');
    const year = parseInt(yearStr);
    const month = parseInt(monthStr);
    const day = parseInt(dayStr);
    const week = parseInt(weekStr);
    const quarter = getQuarter(month);
    return { year, month, day, week, quarter, timezone };
  } catch {
    // Fallback to shared utility
    const components = getDateComponentsFromDate(new Date());
    return { ...components, timezone };
  }
}

function getReviewFilePath(targetDate = null) {
  return getDailyPlanPath(getDateComponents(targetDate));
}

/**
 * Get tomorrow's date in the configured timezone.
 * This prevents timezone issues when system runs in UTC but user is in EST/etc.
 */
function getTomorrowDate() {
  const timezone = getTimezone();
  const todayInTz = execSync(`TZ=${timezone} date "+%Y-%m-%d"`, { encoding: 'utf8' }).trim();
  const tomorrow = new Date(todayInTz + 'T12:00:00'); // Use noon to avoid DST edge cases
  tomorrow.setDate(tomorrow.getDate() + 1);
  return tomorrow;
}

function getCurrentStageInfo() {
  const timezone = getTimezone();
  let dayOfWeek;
  try {
    dayOfWeek = execSync(`TZ=${timezone} date "+%A"`, { encoding: 'utf8' }).trim();
  } catch {
    dayOfWeek = new Date().toLocaleDateString('en-US', { weekday: 'long' });
  }
  return getStageInfo(dayOfWeek);
}

// Note: getTaskStatistics is now imported from src/plan-utils.js

// ============================================================================
// Health Metrics
// ============================================================================

function getHealthMetrics() {
  const healthFiles = [];
  try {
    const files = fs.readdirSync('vault/logs');
    for (const file of files) {
      if (file.startsWith('HealthAutoExport') && (file.endsWith('.json') || file.endsWith('.zip'))) {
        healthFiles.push(path.join('vault/logs', file));
      }
    }
  } catch {
    return '';
  }

  if (healthFiles.length === 0) return '';

  // Sort by modification time
  healthFiles.sort((a, b) => {
    try {
      return fs.statSync(b).mtimeMs - fs.statSync(a).mtimeMs;
    } catch {
      return 0;
    }
  });

  const healthExport = healthFiles[0];

  try {
    let data;
    if (healthExport.endsWith('.json')) {
      data = JSON.parse(fs.readFileSync(healthExport, 'utf8'));
    } else {
      // For zip files, we'd need a zip library - skip for now
      return '';
    }

    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];
    const metrics = {};

    for (const metric of data?.data?.metrics || []) {
      if (metric.name === 'step_count') {
        const dailySteps = {};
        for (const entry of metric.data || []) {
          const dateStr = entry.date.split(' ')[0];
          dailySteps[dateStr] = (dailySteps[dateStr] || 0) + (entry.qty || 0);
        }

        const dates = Object.keys(dailySteps).sort().slice(-7);
        if (dates.length > 0) {
          const avgSteps = dates.reduce((sum, d) => sum + dailySteps[d], 0) / dates.length;
          metrics.avgSteps = Math.round(avgSteps);
          if (dailySteps[yesterdayStr]) {
            metrics.yesterdaySteps = Math.round(dailySteps[yesterdayStr]);
          }
        }
      } else if (metric.name === 'weight_body_mass') {
        const weights = (metric.data || [])
          .map(e => [e.date.split(' ')[0], e.qty || 0])
          .sort((a, b) => a[0].localeCompare(b[0]));
        if (weights.length > 0) {
          metrics.weight = `${weights[weights.length - 1][1].toFixed(1)} lbs`;
        }
      }
    }

    if (Object.keys(metrics).length > 0) {
      const lines = ['\n## Health Metrics (Last 7 days)'];
      if (metrics.avgSteps) lines.push(`- **Average Steps**: ${metrics.avgSteps}/day`);
      if (metrics.yesterdaySteps) lines.push(`- **Yesterday**: ${metrics.yesterdaySteps} steps`);
      if (metrics.weight) lines.push(`- **Weight**: ${metrics.weight}`);
      return lines.join('\n');
    }
  } catch {
    // Silently fail
  }

  return '';
}

// ============================================================================
// Plan File Helpers
// ============================================================================

function getExistingPlans() {
  const components = getDateComponents();
  const hierarchy = getPlanFileHierarchy(components);
  const plans = [];

  for (const { path: filePath, label } of hierarchy) {
    if (fs.existsSync(filePath)) {
      plans.push(`- ${label}: ${filePath}`);
    }
  }

  return plans.length > 0 ? plans.join('\n') : 'No planning files found';
}

function getChangedVaultFiles() {
  try {
    const timezone = getTimezone();
    const result = execSync(`TZ=${timezone} date -d "today 00:00:00" "+%s"`, { encoding: 'utf8' });
    const todayMidnightTs = parseInt(result.trim()) * 1000;

    const excludeDirs = new Set(['.sync', 'templates', '.git', '.git.nosync', '.obsidian', '.trash']);
    const files = [];

    const walkDir = (dir) => {
      if (!fs.existsSync(dir)) return;
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (excludeDirs.has(entry.name)) continue;
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          walkDir(fullPath);
        } else if (entry.name.endsWith('.md')) {
          try {
            const stat = fs.statSync(fullPath);
            if (stat.mtimeMs >= todayMidnightTs) {
              files.push(fullPath);
            }
          } catch {
            // Ignore
          }
        }
      }
    };

    walkDir('vault');

    if (files.length === 0) return '';

    // Sort by modification time (most recent first)
    files.sort((a, b) => {
      try {
        return fs.statSync(b).mtimeMs - fs.statSync(a).mtimeMs;
      } catch {
        return 0;
      }
    });

    const lines = ['\n## üìù Files Changed/Added Today in Vault'];
    lines.push(`\n${files.length} file(s) modified or added today:\n`);

    for (const filepath of files) {
      try {
        const content = fs.readFileSync(filepath, 'utf8').slice(0, 500);
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch) {
          lines.push(`- **${filepath}**: ${titleMatch[1].trim()}`);
        } else {
          lines.push(`- **${filepath}**`);
        }
      } catch {
        lines.push(`- **${filepath}**`);
      }
    }

    return lines.join('\n');
  } catch {
    return '';
  }
}

// ============================================================================
// Vault Initialization
// ============================================================================

function checkVaultExists() {
  if (fs.existsSync('vault')) return true;
  if (!fs.existsSync('skeleton')) {
    console.log('‚ùå Neither vault/ nor skeleton/ directory found.');
    console.log('   Please ensure you have the complete Today repository.');
    return false;
  }

  console.log('‚îÅ'.repeat(60));
  console.log('üìÅ Vault directory not found');
  console.log('‚îÅ'.repeat(60));
  console.log();
  console.log('The vault/ directory contains your personal notes, tasks, and plans.');
  console.log('It is excluded from this repository because it\'s meant to be private.');
  console.log();
  console.log('Would you like to initialize a new vault from the skeleton template?');
  console.log();

  const rl = createInterface({ input: process.stdin, output: process.stdout });

  return new Promise((resolve) => {
    rl.question('Initialize vault? [y/N]: ', (answer) => {
      rl.close();
      if (answer.trim().toLowerCase() !== 'y') {
        console.log();
        console.log('Vault not initialized. You can manually copy the skeleton:');
        console.log('  cp -r skeleton vault');
        console.log();
        resolve(false);
        return;
      }

      console.log();
      console.log('üì¶ Initializing vault from skeleton...');

      try {
        execSync('cp -r skeleton vault', { stdio: 'inherit' });
        // Remove .gitkeep files
        execSync('find vault -name ".gitkeep" -delete 2>/dev/null || true', { stdio: 'pipe' });
        console.log('‚úÖ Vault initialized successfully!');
        console.log();
        console.log('‚îÅ'.repeat(60));
        console.log('üìù Next steps:');
        console.log('‚îÅ'.repeat(60));
        console.log();
        console.log('1. Initialize a git repository for version control:');
        console.log('   cd vault && git init && git add . && git commit -m \'Initial vault\'');
        console.log();
        console.log('2. Set up sync (optional but recommended):');
        console.log('   - Resilio Sync, Syncthing, or a private git remote');
        console.log();
        console.log('3. If using Obsidian, install recommended plugins:');
        console.log('   - Dataview, Tasks, Templater, Calendar, Periodic Notes');
        console.log();
        console.log('See vault/README.md for detailed documentation.');
        console.log('‚îÅ'.repeat(60));
        console.log();
        resolve(true);
      } catch (e) {
        console.log(`‚ùå Failed to initialize vault: ${e.message}`);
        resolve(false);
      }
    });
  });
}

// ============================================================================
// Skeleton Updates Check
// ============================================================================

function checkSkeletonUpdates() {
  if (!fs.existsSync('vault') || !fs.existsSync('skeleton')) return;

  const trackingFile = '.skeleton-hashes';
  const trackedFiles = [
    'scripts/time-tracking-widget.js',
    'scripts/upcoming-events-widget.js',
    'templates/daily-plan.md',
    'templates/project.md',
    '.obsidian/snippets/app-wide.css',
  ];

  // Load previous hashes
  const previousHashes = {};
  if (fs.existsSync(trackingFile)) {
    try {
      const content = fs.readFileSync(trackingFile, 'utf8');
      for (const line of content.split('\n')) {
        const parts = line.trim().split(':');
        if (parts.length === 2) {
          previousHashes[parts[0]] = parts[1];
        }
      }
    } catch {
      // Ignore
    }
  }

  const updatesAvailable = [];

  for (const relPath of trackedFiles) {
    const skeletonFile = path.join('skeleton', relPath);
    const vaultFile = path.join('vault', relPath);

    if (!fs.existsSync(skeletonFile)) continue;

    // Calculate current skeleton hash
    const currentHash = createHash('md5').update(fs.readFileSync(skeletonFile)).digest('hex');

    // Check if skeleton has changed since last check
    if (previousHashes[relPath] === currentHash) continue;

    // Check if vault file exists and differs from skeleton
    if (fs.existsSync(vaultFile)) {
      const vaultHash = createHash('md5').update(fs.readFileSync(vaultFile)).digest('hex');
      if (currentHash !== vaultHash) {
        updatesAvailable.push(relPath);
      }
    }

    // Update tracking
    previousHashes[relPath] = currentHash;
  }

  // Save updated hashes
  const hashLines = Object.entries(previousHashes).map(([k, v]) => `${k}:${v}`).join('\n');
  fs.writeFileSync(trackingFile, hashLines);

  if (updatesAvailable.length > 0) {
    console.log('‚îÅ'.repeat(60));
    console.log('üì¶ Skeleton updates available');
    console.log('‚îÅ'.repeat(60));
    console.log();
    console.log('The following skeleton files have been updated:');
    for (const p of updatesAvailable) {
      console.log(`  - ${p}`);
    }
    console.log();
    console.log('To review and merge updates:');
    console.log('  diff vault/<file> skeleton/<file>');
    console.log('  cp skeleton/<file> vault/<file>');
    console.log();
    console.log('‚îÅ'.repeat(60));
    console.log();
  }
}

// ============================================================================
// Dependency Check
// ============================================================================

function checkDependencies() {
  const lastCheckFile = '.last-dep-check';
  const todayDate = new Date().toISOString().split('T')[0];

  if (process.env.SKIP_DEP_CHECK === 'true') return;

  try {
    if (fs.existsSync(lastCheckFile)) {
      const lastCheck = fs.readFileSync(lastCheckFile, 'utf8').trim();
      if (lastCheck === todayDate) return;
    }
  } catch {
    // Continue
  }

  console.log('üîç Checking for dependency updates (timeout in 10s)...');
  try {
    execSync('timeout 10 bin/update-deps --quiet', { stdio: 'pipe' });
  } catch {
    console.log('‚ö†Ô∏è  Dependency check timed out, continuing...');
  }

  fs.writeFileSync(lastCheckFile, todayDate);
  console.log();
}

// ============================================================================
// Sync
// ============================================================================

function runSync(skipSync = false) {
  if (skipSync) {
    console.log('‚è≠Ô∏è  Skipping sync step');
    return;
  }

  console.log('üîÑ Syncing data sources...');
  try {
    execSync('bin/sync', { stdio: 'inherit' });
  } catch {
    // Continue even if sync fails
  }
}

// ============================================================================
// Database Check
// ============================================================================

function checkAndRecoverDatabase() {
  const dbPath = '.data/today.db';
  let dbMissing = !fs.existsSync(dbPath);
  let tablesMissing = false;

  if (!dbMissing) {
    try {
      const result = execSync(
        `sqlite3 "${dbPath}" "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name IN ('tasks', 'projects')"`,
        { encoding: 'utf8' }
      );
      if (parseInt(result.trim()) !== 2) {
        tablesMissing = true;
        console.log('‚ö†Ô∏è  Database missing required tables');
      }
    } catch {
      tablesMissing = true;
    }
  } else {
    console.log(`‚ö†Ô∏è  Database not found at ${dbPath}`);
  }

  if (dbMissing || tablesMissing) {
    console.log('üîÑ Database missing or incomplete - recovering...\n');
    fs.mkdirSync('.data', { recursive: true });

    if (dbMissing) {
      console.log('üî® Creating database and running migrations...');
      try {
        execSync('node src/migrations.js', { stdio: 'inherit' });
        console.log('‚úÖ Database created with schema');
        console.log('‚ÑπÔ∏è  Database is a local cache - data will be populated from external sources\n');
      } catch (e) {
        console.error(`‚ùå Failed to create database: ${e.message}`);
        process.exit(1);
      }
    }
  }

  // Quick check that database has data
  try {
    const lastSync = execSync(
      `sqlite3 "${dbPath}" "SELECT MAX(created_at) FROM sync_log"`,
      { encoding: 'utf8' }
    ).trim();

    if (lastSync) {
      console.log(`‚úÖ Database ready (last sync: ${lastSync})\n`);
    } else {
      const taskCount = execSync(
        `sqlite3 "${dbPath}" "SELECT COUNT(*) FROM tasks"`,
        { encoding: 'utf8' }
      ).trim();

      if (parseInt(taskCount) > 0) {
        console.log(`‚úÖ Database ready (${taskCount} tasks found)\n`);
      } else {
        console.log('üìù Initializing sync log...');
        execSync(
          `sqlite3 "${dbPath}" "INSERT INTO sync_log (timestamp, sync_type, success, source_system, target_system, created_at) VALUES (datetime('now'), 'initial', 1, 'local', 'local', datetime('now'))"`,
          { stdio: 'pipe' }
        );
        console.log('‚úÖ Database ready (initialized)\n');
      }
    }
  } catch (e) {
    console.error(`‚ùå Database check failed: ${e.message}`);
    process.exit(1);
  }
}

// ============================================================================
// Claude Auth Check
// ============================================================================

function checkClaudeAuth() {
  console.log('üîê Checking Claude authentication...');
  try {
    const result = spawnSync('claude', ['-p', 'Say "ok"'], { encoding: 'utf8' });
    const output = (result.stdout || '') + (result.stderr || '');

    if (output.includes('Invalid API key') || output.includes('Please run /login') || output.includes('not authenticated')) {
      console.log('\n‚ö†Ô∏è  Claude CLI is not authenticated!');
      console.log('‚îÅ'.repeat(50));
      console.log('\nClaude is essential for daily reviews.');
      console.log('Please authenticate now by running:\n');
      console.log('  claude\n');
      console.log('Then follow the browser prompt to login.');
      console.log('After authentication, run \'bin/today\' again.');
      console.log('‚îÅ'.repeat(50));
      process.exit(1);
    }

    console.log('‚úÖ Claude is authenticated\n');
  } catch {
    console.log('‚úÖ Claude check passed\n');
  }
}

// ============================================================================
// Time Tracking Widgets
// ============================================================================

function ensureTimeTrackingWidgets(dryRun = false) {
  console.log('‚è±Ô∏è  Checking time tracking widgets...');

  const { year, month, day, week, quarter, timezone } = getDateComponents();

  // Define plan files with their date ranges
  const quarterEndDays = [31, 30, 30, 31];
  const quarterNum = parseInt(quarter.slice(1));
  const planFiles = [
    [`vault/plans/${year}_00.md`, `${year}-01-01`, `${year}-12-31`, 'Year'],
    [`vault/plans/${year}_${quarter}_00.md`,
      `${year}-${String((quarterNum - 1) * 3 + 1).padStart(2, '0')}-01`,
      `${year}-${String(quarterNum * 3).padStart(2, '0')}-${quarterEndDays[quarterNum - 1]}`,
      quarter],
    [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_00.md`,
      `${year}-${String(month).padStart(2, '0')}-01`,
      `${year}-${String(month).padStart(2, '0')}-${new Date(year, month, 0).getDate()}`,
      new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' })],
    [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_W${String(week).padStart(2, '0')}_00.md`,
      null, null, `Week ${week}`],
  ];

  // Calculate week start/end for the week file
  try {
    const weekStart = execSync(`TZ=${timezone} date -d "$(date +%Y-W${String(week).padStart(2, '0')}-1)" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
    const weekEnd = execSync(`TZ=${timezone} date -d "${weekStart} +6 days" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
    planFiles[3][1] = weekStart;
    planFiles[3][2] = weekEnd;
  } catch {
    // Skip week file if we can't calculate dates
  }

  const filesUpdated = [];

  for (const [filePath, startDate, endDate, periodName] of planFiles) {
    if (!fs.existsSync(filePath)) continue;
    if (!startDate || !endDate) continue;

    const content = fs.readFileSync(filePath, 'utf8');

    // Check if time tracking widget already exists
    if (content.includes('scripts/time-tracking-widget')) continue;
    if (/## ‚è±Ô∏è Time Tracking/.test(content)) continue;

    const widgetSection = `
## ‚è±Ô∏è Time Tracking - ${periodName}

\`\`\`dataviewjs
await dv.view("scripts/time-tracking-widget", { startDate: '${startDate}', endDate: '${endDate}' });
\`\`\`
`;

    const updatedContent = content.trimEnd() + '\n' + widgetSection + '\n';

    if (dryRun) {
      console.log(`   Would add time tracking to: ${filePath}`);
    } else {
      fs.writeFileSync(filePath, updatedContent);
      filesUpdated.push([periodName, filePath]);
    }
  }

  if (filesUpdated.length > 0 && !dryRun) {
    console.log(`‚úÖ Added time tracking widgets to ${filesUpdated.length} file(s):`);
    for (const [periodName, filePath] of filesUpdated) {
      console.log(`   ${periodName}: ${filePath}`);
    }
  } else {
    console.log('‚úÖ All plan files have time tracking widgets');
  }

  console.log();
}

// ============================================================================
// Template Processing
// ============================================================================

function createFileFromTemplate(filePath, targetDate, isTomorrow = false) {
  const templateFile = 'vault/templates/daily-plan.md';
  if (!fs.existsSync(templateFile)) return;

  // Ensure directory exists
  fs.mkdirSync(path.dirname(filePath), { recursive: true });

  let content = fs.readFileSync(templateFile, 'utf8');

  // Use shared utilities for template variables
  const replacements = getTemplateVariables(targetDate);
  content = applyTemplateVariables(content, replacements);

  // Add draft note for tomorrow's plan
  if (isTomorrow) {
    const [, stageFocus] = getStageInfo(targetDate);
    const draftNote = '\n> [!info] Draft Plan\n> This is a preliminary plan for tomorrow. It will be refined throughout today.\n\n';
    content = content.replace('**Theme:** ' + stageFocus, '**Theme:** ' + stageFocus + draftNote);
  }

  fs.writeFileSync(filePath, content);
}

function createReviewFromTemplate() {
  const filesCreated = [];

  // Create for today
  const todayFile = getReviewFilePath();
  if (!fs.existsSync(todayFile)) {
    console.log('üìù Creating today\'s plan from template...');
    createFileFromTemplate(todayFile, new Date(), false);
    filesCreated.push(['today', todayFile]);
  }

  // Create for tomorrow
  const tomorrow = getTomorrowDate();
  const tomorrowFile = getReviewFilePath(tomorrow);
  if (!fs.existsSync(tomorrowFile)) {
    console.log('üìù Creating tomorrow\'s plan from template...');
    createFileFromTemplate(tomorrowFile, tomorrow, true);
    filesCreated.push(['tomorrow', tomorrowFile]);
  }

  if (filesCreated.length > 0) {
    console.log('‚úÖ Created review files:');
    for (const [label, p] of filesCreated) {
      console.log(`   ${label.charAt(0).toUpperCase() + label.slice(1)}: ${p}`);
    }
    console.log();
  }

  return todayFile;
}

// ============================================================================
// API Update
// ============================================================================

async function updateReviewFile(dryRun = false) {
  const apiKey = process.env.TODAY_ANTHROPIC_KEY;
  if (!apiKey) {
    console.log('‚ùå TODAY_ANTHROPIC_KEY not found in environment');
    console.log('Please ensure it\'s set in .env and encrypted with dotenvx');
    process.exit(1);
  }

  ensureTimeTrackingWidgets(dryRun);

  // Update today's file
  const todayFile = getReviewFilePath();
  if (!fs.existsSync(todayFile)) {
    console.log(`‚ö†Ô∏è  Today's file not found: ${todayFile}`);
    console.log('Skipping today\'s update');
  } else {
    console.log(`üìä Updating today's plan: ${todayFile}...`);
    if (dryRun) console.log('üîç DRY RUN MODE - No changes will be made');
    await updateSingleFile(todayFile, false, dryRun, apiKey);
  }

  // Update tomorrow's file
  const tomorrow = getTomorrowDate();
  const tomorrowFile = getReviewFilePath(tomorrow);
  if (!fs.existsSync(tomorrowFile)) {
    console.log(`‚ö†Ô∏è  Tomorrow's file not found: ${tomorrowFile}`);
    console.log('Skipping tomorrow\'s update');
  } else {
    console.log(`üìä Updating tomorrow's plan: ${tomorrowFile}...`);
    await updateSingleFile(tomorrowFile, true, dryRun, apiKey);
  }
}

async function updateSingleFile(reviewFile, isTomorrow, dryRun, apiKey) {
  // Get current database data
  let dailyData;
  try {
    dailyData = execSync('bin/db-query daily', { encoding: 'utf8' });
  } catch (e) {
    console.error(`‚ùå Failed to query database: ${e.message}`);
    process.exit(1);
  }

  // Get detailed time tracking data
  try {
    const timeTracking = execSync('bin/track today', { encoding: 'utf8' });
    dailyData += '\n\n=== DETAILED TIME TRACKING ===\n' + timeTracking;
  } catch {
    // Continue without time tracking details
  }

  // Get changed vault files
  const changedFiles = getChangedVaultFiles();
  if (changedFiles) {
    dailyData += '\n\n' + changedFiles;
  }

  const originalContent = fs.readFileSync(reviewFile, 'utf8');
  const backupContent = originalContent;
  const originalLines = originalContent.split('\n').length;

  const timezone = getTimezone();
  const currentTime = execSync(`TZ=${timezone} date "+%I:%M %p"`, { encoding: 'utf8' }).trim();
  const currentDate = execSync(`TZ=${timezone} date "+%Y-%m-%d"`, { encoding: 'utf8' }).trim();
  const tzOffset = execSync(`TZ=${timezone} date "+%z"`, { encoding: 'utf8' }).trim();

  let prompt;
  if (isTomorrow) {
    prompt = `You are updating TOMORROW's daily plan with fresh priorities from the database.

CURRENT TIME: ${currentTime} ET
CURRENT DATE: ${currentDate}

CURRENT FILE CONTENT (Tomorrow's Plan):
${originalContent}

CURRENT DATABASE DATA (tasks, events, emails, etc.):
${dailyData.slice(0, 5000)}

YOUR TASK:
Refresh the "Top Priorities" section with current database data.
This is a DRAFT plan for tomorrow that gets refined throughout today.

Focus on:
1. Overdue tasks that will carry into tomorrow
2. Tasks scheduled for tomorrow
3. Calendar events scheduled for tomorrow
4. High-priority items that need attention

RETURN A JSON OBJECT with updated priorities section:
{
  "priorities_update": "### üö® Critical (Do First)\\n\\n- [ ] Task 1\\n- [ ] Task 2\\n\\n### ‚ö° Quick Wins...\\n",
  "notes": "Brief note about what changed"
}

IMPORTANT:
- Keep it lightweight - this is a draft
- Focus on actionable items
- Use simple checkboxes: "- [ ] Task description"
- DO NOT add due dates (üìÖ), scheduled dates (‚è≥), or recurrence (üîÅ) to tasks
- Created date (‚ûï) is fine - scripts add this automatically
- Plan files use simple tasks - scheduling belongs in project/topic files only`;
  } else {
    prompt = `You are updating TODAY's daily plan with a progress update.

CURRENT TIME: ${currentTime} ET
CURRENT DATE: ${currentDate}

CURRENT FILE CONTENT:
${originalContent}

CURRENT DATABASE DATA (tasks, events, emails, etc.):
${dailyData.slice(0, 5000)}

YOUR TASK:
Create a new Progress Update section to append to the end of the file.
Compare the current file with the database to see what's changed or been accomplished.

üö® CRITICAL: The database includes DETAILED TIME TRACKING DATA showing what work has been done today.
   - Time tracking is THE GROUND TRUTH of productivity
   - Physical work, meetings, coordination, deep work sessions are all tracked there
   - NEVER assume "zero progress" without checking the time tracking data first
   - Checkbox completions are NOT the primary measure of productivity

This should summarize:
1. What's been accomplished since the last update - CHECK TIME TRACKING DATA FIRST (tasks checked off, workouts done, meetings attended, time tracked)
2. Current status of high-priority items
3. Any new events, emails, or tasks that need attention
4. Overall progress and any blockers

RETURN A JSON OBJECT:
{
  "progress_update": "<!-- PROGRESS_UPDATE -->\\n> [!success] üìä Progress Update (${currentTime})\\n>\\n> *${currentDate} HH:MM ${tzOffset}*\\n>\\n> - Brief summary of what's been done\\n> - Current status\\n> - What's next or any blockers\\n<!-- /PROGRESS_UPDATE -->",
  "tasks_to_check": ["exact task text to mark done (only if you see clear evidence in the file they're completed)"]
}

NOTE: The progress_update should use the callout format with:
- "<!-- PROGRESS_UPDATE -->" as the opening marker
- "> [!success] üìä Progress Update (TIME)" as the header
- "> " prefix for all lines in the callout
- "*italicized timestamp*" on the second line
- "<!-- /PROGRESS_UPDATE -->" as the closing marker

IMPORTANT:
- Create a MEANINGFUL progress update - there's always something to report
- Look at completed tasks in the file (marked [x]) since the last Progress Update
- The update should be 2-4 bullet points, concise but informative
- Only mark tasks as done if you see clear evidence (like workout exercises checked off)
- Use the exact timezone offset in the timestamp: ${tzOffset}
- Use simple checkboxes: "- [ ] Task description"
- DO NOT add due dates (üìÖ), scheduled dates (‚è≥), or recurrence (üîÅ) to tasks
- Created date (‚ûï) is fine - scripts add this automatically`;
  }

  const client = new Anthropic({ apiKey });

  try {
    const model = getClaudeModel();
    const response = await client.messages.create({
      model,
      max_tokens: 2000,
      temperature: 0,
      messages: [{ role: 'user', content: prompt }],
    });

    let responseText = response.content[0].text;

    // Try to parse as JSON
    let edits;
    try {
      let jsonStr;
      if (responseText.includes('```json')) {
        jsonStr = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        jsonStr = responseText.split('```')[1].split('```')[0];
      } else if (responseText.includes('{')) {
        const start = responseText.indexOf('{');
        let count = 0;
        let end = start;
        for (let i = start; i < responseText.length; i++) {
          if (responseText[i] === '{') count++;
          else if (responseText[i] === '}') {
            count--;
            if (count === 0) {
              end = i + 1;
              break;
            }
          }
        }
        jsonStr = responseText.slice(start, end);
      } else {
        jsonStr = responseText;
      }
      edits = JSON.parse(jsonStr);
    } catch (e) {
      console.log(`‚ö†Ô∏è  Failed to parse Claude's response as JSON: ${e.message}`);
      console.log(`Response: ${responseText.slice(0, 200)}...`);
      process.exit(1);
    }

    let updatedContent = originalContent;

    if (isTomorrow) {
      if (edits.priorities_update) {
        const replacement = `## üìã Top Priorities\n\n${edits.priorities_update}\n`;
        updatedContent = updatedContent.replace(/## üìã Top Priorities\n\n.*?(?=\n## |$)/s, replacement);
      }
    } else {
      if (edits.progress_update) {
        updatedContent = updatedContent.trimEnd() + '\n\n' + edits.progress_update + '\n';
      }

      if (edits.tasks_to_check) {
        for (const task of edits.tasks_to_check) {
          const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const uncheckedPattern = new RegExp(`- \\[ \\] ${escapedTask}`);
          if (uncheckedPattern.test(updatedContent)) {
            updatedContent = updatedContent.replace(uncheckedPattern, `- [x] ${task} ‚úÖ ${currentDate}`);
          }
        }
      }
    }

    // SAFETY CHECKS
    const updatedLines = updatedContent.split('\n').length;
    if (updatedLines < originalLines * 0.9) {
      console.log(`‚ö†Ô∏è  Safety check failed: Updated file has ${updatedLines} lines vs original ${originalLines}`);
      console.log('Aborting update to prevent data loss');
      process.exit(1);
    }

    if (updatedContent.length < originalContent.length * 0.9) {
      console.log('‚ö†Ô∏è  Safety check failed: Updated content is too short');
      console.log(`Original: ${originalContent.length} chars, Updated: ${updatedContent.length} chars`);
      process.exit(1);
    }

    if (dryRun) {
      console.log('\nüìù Proposed changes:');
      if (isTomorrow) {
        console.log(`Priorities update:\n${(edits.priorities_update || 'None').slice(0, 200)}...`);
        console.log(`\nNotes: ${edits.notes || 'None'}`);
      } else {
        console.log(`Progress update to append:\n${edits.progress_update || 'None'}`);
        console.log(`\nTasks to check: ${JSON.stringify(edits.tasks_to_check || [])}`);
      }
      console.log('\n‚úÖ Dry run complete - no changes made');
    } else {
      fs.writeFileSync(reviewFile, updatedContent);

      if (updatedContent !== originalContent) {
        const fileType = isTomorrow ? "tomorrow's plan" : "today's plan";
        console.log(`‚úÖ Updated ${fileType}: ${reviewFile}`);
      } else {
        console.log(`‚ö†Ô∏è  API returned no changes - ${reviewFile} unchanged`);
        console.log('This might indicate the AI couldn\'t determine what to update.');
      }
    }
  } catch (e) {
    console.error(`‚ùå Error: ${e.message}`);
    if (!dryRun) {
      console.log('Restoring original content...');
      fs.writeFileSync(reviewFile, backupContent);
    }
    process.exit(1);
  }
}

// ============================================================================
// Interactive Session
// ============================================================================

function runInteractiveSession(directRequest = null, nonInteractive = false) {
  const todayFile = getReviewFilePath();
  const tomorrowFile = getReviewFilePath(getTomorrowDate());
  const [stageTheme, stageFocus] = getStageInfo();
  const timezone = getTimezone();

  const currentTime = execSync(`TZ=${timezone} date "+%A, %B %d, %Y at %I:%M %p %Z"`, { encoding: 'utf8' }).trim();
  const currentDate = execSync(`TZ=${timezone} date "+%Y-%m-%d"`, { encoding: 'utf8' }).trim();
  const dayOfWeek = execSync(`TZ=${timezone} date "+%A"`, { encoding: 'utf8' }).trim();

  const taskStats = getTaskStatistics();
  const healthMetrics = getHealthMetrics();
  const existingPlans = getExistingPlans();
  const changedFiles = getChangedVaultFiles();

  // Read TODAY.md for context
  let todayContext = '';
  if (fs.existsSync('TODAY.md')) {
    let todayContent = fs.readFileSync('TODAY.md', 'utf8');
    todayContent = todayContent.replace(/### üî¥ CRITICAL FIRST STEPS üî¥.*?(?=##|$)/s, '');
    const match = todayContent.match(/## Session Instructions for Claude.*/s);
    if (match) {
      todayContext = match[0];
    }
  }

  const commonContext = `## Pre-Computed Context
- **Current Time**: ${currentTime}
- **Date**: ${currentDate} (${dayOfWeek})
- **Stage**: ${stageTheme} - ${stageFocus}
- **Today's Review File**: ${todayFile}
- **Tomorrow's Review File**: ${tomorrowFile}
- **Active Tasks**: ${taskStats.total} (Overdue: ${taskStats.overdue}, High Priority: ${taskStats.highPriority})
- **Time Blocking Calendar**: e1jdfoki06hfrg8kh55mn9kvvs@group.calendar.google.com
${healthMetrics}

## Existing Plans
${existingPlans}
${changedFiles}

## Database Tables Available:
- markdown_tasks: Current tasks stored directly from markdown files
- emails: Recent emails with subjects, senders, reply status
- calendar_events: Upcoming events with times, locations
- contacts: Contact information
- file_tracking: Recently modified files
- people_to_contact: People needing follow-up
- diary: Day One journal entries with text, dates, locations

## Available Commands
- bin/db-query daily - Get comprehensive daily review data
- bin/db-query tasks - Get priority tasks
- bin/mark-done 'task' - Mark a task as complete
- bin/progress 'note' - Add a progress note
- bin/calendar add --title "Task" --date "YYYY-MM-DD" "HH:MM" "HH:MM" --calendar "e1jdfoki06hfrg8kh55mn9kvvs@group.calendar.google.com" - Create time blocking events

${todayContext}`;

  let prompt;
  if (directRequest) {
    if (nonInteractive) {
      console.log('ü§ñ Running Claude in non-interactive mode...');
      prompt = `# Focused Work Session - NON-INTERACTIVE MODE

## CRITICAL: You are in NON-INTERACTIVE mode
- You have FULL PERMISSION to create, update, and modify files
- Do NOT ask for permission - execute the requested actions immediately
- The user ran this command specifically requesting: "${directRequest}"
- Complete the task WITHOUT asking for confirmation

${commonContext}

## Direct Request from User
"${directRequest}"

Execute the request NOW without asking for permission!`;

      try {
        spawnSync('timeout', ['600', 'claude', '--print', '--dangerously-skip-permissions', prompt], { stdio: 'inherit' });
      } catch (e) {
        console.error(`ERROR: Command timed out or failed after 10 minutes: ${e.message}`);
        process.exit(1);
      }
    } else {
      console.log(`üìä Starting focused session: ${directRequest}\n`);
      console.log('ü§ñ Starting Claude focused session...');

      prompt = `# Focused Work Session

${commonContext}

## User Request
"${directRequest}"

Please help me with this specific request.`;

      spawnSync('claude', [prompt], { stdio: 'inherit' });
    }
  } else {
    console.log('ü§ñ Starting Claude daily review session...');
    prompt = `# Daily Review Session

${commonContext}

Please help me with my daily review.`;

    spawnSync('claude', [prompt], { stdio: 'inherit' });
  }

  // Session end summary
  console.log('\n' + '‚îÅ'.repeat(50));
  console.log('‚úÖ Claude session ended\n');
  console.log('üìù Your plans are in:');
  console.log(`   Today: ${todayFile}`);
  console.log(`   Tomorrow: ${tomorrowFile}\n`);
  console.log('üí° Continue tracking progress with:');
  console.log('   bin/mark-done \'task description\'');
  console.log('   bin/progress \'note\'');
  console.log('   bin/today update  # Update both files with progress');
  console.log('‚îÅ'.repeat(50) + '\n');
}

// ============================================================================
// Main
// ============================================================================

function showHelp() {
  console.log(`Today - Daily review and planning tool

Usage:
  bin/today [options] [command] [request]

Commands:
  (none)      Start interactive daily review session with Claude
  init        Initialize review file hierarchy (create today/tomorrow plans)
  update      Update review files via Anthropic API (non-interactive)
  dry-run     Preview what update would do without making changes

Options:
  --no-sync         Skip the data sync step
  --non-interactive Run in non-interactive mode (for automation)
  -h, --help        Show this help message

Examples:
  bin/today                           # Start daily review
  bin/today update                    # Update plans via API
  bin/today --no-sync                 # Skip sync, start review
  bin/today "fix the bug in login"    # Focused session with specific request

Files:
  Today's plan:    vault/plans/YYYY_QQ_MM_W##_DD.md
  Tomorrow's plan: vault/plans/YYYY_QQ_MM_W##_DD.md (next day)
`);
}

async function main() {
  const args = process.argv.slice(2);

  // Handle help early
  if (args.includes('-h') || args.includes('--help')) {
    showHelp();
    return;
  }

  // Parse arguments
  let command = null;
  let request = [];
  let noSync = false;
  let nonInteractive = false;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--no-sync') {
      noSync = true;
    } else if (args[i] === '--non-interactive') {
      nonInteractive = true;
    } else if (!command && ['init', 'update', 'dry-run'].includes(args[i])) {
      command = args[i];
    } else {
      request.push(args[i]);
    }
  }

  const directRequest = request.length > 0 ? request.join(' ') : null;

  // Check if vault exists (unless in non-interactive mode)
  if (!nonInteractive) {
    const vaultExists = await checkVaultExists();
    if (!vaultExists) {
      console.log('Cannot continue without vault directory.');
      process.exit(1);
    }
  }

  // Check dependencies once per day (unless in non-interactive mode)
  if (!nonInteractive) {
    checkDependencies();
    checkSkeletonUpdates();
  }

  // Handle init command
  if (command === 'init') {
    console.log('üìÖ Initializing review file hierarchy...');
    createReviewFromTemplate();
    console.log('‚úÖ Review hierarchy is ready!');
    return;
  }

  // Handle update command
  if (command === 'update') {
    console.log('üìä Running automated review update...');
    if (!noSync) runSync();
    await updateReviewFile(false);
    return;
  }

  // Handle dry-run command
  if (command === 'dry-run') {
    console.log('üìä Running review update in dry-run mode...');
    if (!noSync) runSync();
    await updateReviewFile(true);
    return;
  }

  // Display appropriate message
  if (directRequest) {
    console.log(`üìä Starting focused session: ${directRequest}`);
  } else {
    console.log('üìä Starting daily review process...');
  }

  // Check Claude authentication (unless non-interactive)
  if (!nonInteractive) {
    checkClaudeAuth();
  }

  // Run sync (unless skipped)
  if (!noSync) {
    runSync(false);
  } else {
    console.log('‚ö†Ô∏è  Skipping sync (--no-sync flag provided)');
  }

  // Check and recover database if needed
  checkAndRecoverDatabase();

  // Create review file from template if needed
  createReviewFromTemplate();

  // Run the appropriate session
  runInteractiveSession(directRequest, nonInteractive);
}

main().catch((e) => {
  console.error(`‚ùå Fatal error: ${e.message}`);
  process.exit(1);
});
