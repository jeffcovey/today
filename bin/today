#!/usr/bin/env node

/**
 * Today - Daily review and planning tool
 *
 * Usage:
 *   bin/today [options] [command] [request]
 *   bin/today update                  # Update review file via API
 *   bin/today --no-sync               # Skip sync step
 *   bin/today "specific request"      # Focused session with request
 */

import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync, spawnSync } from 'child_process';
// DISABLED - used by vault init (createInterface) and skeleton updates (createHash)
// import { createInterface } from 'readline';
// import { createHash } from 'crypto';

// Import shared modules
import { getTimezone, getFullConfig } from '../src/config.js';
import { getInteractiveModel, getInteractiveProviderName } from '../src/ai-provider.js';
import { parse as parseToml, stringify as stringifyToml } from 'smol-toml';
import color from 'picocolors';
import { getAIInstructionsByType, getPluginSources } from '../src/plugin-loader.js';
import { getPluginTypes, getAIMetadata, generateAIContextBlock, schemas } from '../src/plugin-schemas.js';
import { ensureHealthyDatabase } from '../src/db-health.js';
import { getDatabase } from '../src/database-service.js';
// DISABLED - used by vault/template features
// import {
//   getStageInfo,
//   getDailyPlanPath,
//   getTemplateVariables,
//   applyTemplateVariables,
// } from '../src/plan-utils.js';
import {
  getCurrentTime,
  // DISABLED - used by vault/template features
  // getDateComponents as getDateComponentsFromDateUtils,
  // addDaysToDate,
  // formatDate,
  formatTime,
  formatFullDateTime,
  // getTimezoneOffset,
} from '../src/date-utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

// Change to project root
process.chdir(projectRoot);

// ============================================================================
// Date Helpers (DISABLED - used by vault/template features)
// ============================================================================

// /**
//  * Get date components for plan file naming.
//  * Uses timezone-aware utilities from src/date-utils.js.
//  */
// function getDateComponents(targetDate = null) {
//   const timezone = getTimezone();
//   const date = targetDate || getCurrentTime(timezone);
//   const components = getDateComponentsFromDateUtils(date);
//
//   // Convert string components to integers where needed for compatibility
//   return {
//     year: parseInt(components.year),
//     month: parseInt(components.month),
//     day: parseInt(components.day),
//     week: parseInt(components.week),
//     quarter: components.quarter,
//     timezone
//   };
// }
//
// function getReviewFilePath(targetDate = null) {
//   return getDailyPlanPath(getDateComponents(targetDate));
// }
//
// /**
//  * Get tomorrow's date in the configured timezone.
//  * Uses timezone-aware utilities from src/date-utils.js.
//  */
// function getTomorrowDate() {
//   const timezone = getTimezone();
//   const today = getCurrentTime(timezone);
//   return addDaysToDate(today, 1);
// }

// ============================================================================
// Vault Initialization (DISABLED - not yet migrated to plugin system)
// ============================================================================

// function checkVaultExists() {
//   if (fs.existsSync('vault')) return true;
//   if (!fs.existsSync('skeleton')) {
//     console.log('‚ùå Neither vault/ nor skeleton/ directory found.');
//     console.log('   Please ensure you have the complete Today repository.');
//     return false;
//   }
//
//   console.log('‚îÅ'.repeat(60));
//   console.log('üìÅ Vault directory not found');
//   console.log('‚îÅ'.repeat(60));
//   console.log();
//   console.log('The vault/ directory contains your personal notes, tasks, and plans.');
//   console.log('It is excluded from this repository because it\'s meant to be private.');
//   console.log();
//   console.log('Would you like to initialize a new vault from the skeleton template?');
//   console.log();
//
//   const rl = createInterface({ input: process.stdin, output: process.stdout });
//
//   return new Promise((resolve) => {
//     rl.question('Initialize vault? [y/N]: ', (answer) => {
//       rl.close();
//       if (answer.trim().toLowerCase() !== 'y') {
//         console.log();
//         console.log('Vault not initialized. You can manually copy the skeleton:');
//         console.log('  cp -r skeleton vault');
//         console.log();
//         resolve(false);
//         return;
//       }
//
//       console.log();
//       console.log('üì¶ Initializing vault from skeleton...');
//
//       try {
//         execSync('cp -r skeleton vault', { stdio: 'inherit' });
//         // Remove .gitkeep files
//         execSync('find vault -name ".gitkeep" -delete 2>/dev/null || true', { stdio: 'pipe' });
//         console.log('‚úÖ Vault initialized successfully!');
//         console.log();
//         console.log('‚îÅ'.repeat(60));
//         console.log('üìù Next steps:');
//         console.log('‚îÅ'.repeat(60));
//         console.log();
//         console.log('1. Initialize a git repository for version control:');
//         console.log('   cd vault && git init && git add . && git commit -m \'Initial vault\'');
//         console.log();
//         console.log('2. Set up sync (optional but recommended):');
//         console.log('   - Resilio Sync, Syncthing, or a private git remote');
//         console.log();
//         console.log('3. If using Obsidian, install recommended plugins:');
//         console.log('   - Dataview, Tasks, Templater, Calendar, Periodic Notes');
//         console.log();
//         console.log('See vault/README.md for detailed documentation.');
//         console.log('‚îÅ'.repeat(60));
//         console.log();
//         resolve(true);
//       } catch (e) {
//         console.log(`‚ùå Failed to initialize vault: ${e.message}`);
//         resolve(false);
//       }
//     });
//   });
// }

// ============================================================================
// Skeleton Updates Check (DISABLED - not yet migrated to plugin system)
// ============================================================================

// function checkSkeletonUpdates() {
//   if (!fs.existsSync('vault') || !fs.existsSync('skeleton')) return;
//
//   const trackingFile = '.skeleton-hashes';
//   const trackedFiles = [
//     'scripts/time-tracking-widget.js',
//     'scripts/upcoming-events-widget.js',
//     'templates/daily-plan.md',
//     'templates/project.md',
//     '.obsidian/snippets/app-wide.css',
//   ];
//
//   // Load previous hashes
//   const previousHashes = {};
//   if (fs.existsSync(trackingFile)) {
//     try {
//       const content = fs.readFileSync(trackingFile, 'utf8');
//       for (const line of content.split('\n')) {
//         const parts = line.trim().split(':');
//         if (parts.length === 2) {
//           previousHashes[parts[0]] = parts[1];
//         }
//       }
//     } catch {
//       // Ignore
//     }
//   }
//
//   const updatesAvailable = [];
//
//   for (const relPath of trackedFiles) {
//     const skeletonFile = path.join('skeleton', relPath);
//     const vaultFile = path.join('vault', relPath);
//
//     if (!fs.existsSync(skeletonFile)) continue;
//
//     // Calculate current skeleton hash
//     const currentHash = createHash('md5').update(fs.readFileSync(skeletonFile)).digest('hex');
//
//     // Check if skeleton has changed since last check
//     if (previousHashes[relPath] === currentHash) continue;
//
//     // Check if vault file exists and differs from skeleton
//     if (fs.existsSync(vaultFile)) {
//       const vaultHash = createHash('md5').update(fs.readFileSync(vaultFile)).digest('hex');
//       if (currentHash !== vaultHash) {
//         updatesAvailable.push(relPath);
//       }
//     }
//
//     // Update tracking
//     previousHashes[relPath] = currentHash;
//   }
//
//   // Save updated hashes
//   const hashLines = Object.entries(previousHashes).map(([k, v]) => `${k}:${v}`).join('\n');
//   fs.writeFileSync(trackingFile, hashLines);
//
//   if (updatesAvailable.length > 0) {
//     console.log('‚îÅ'.repeat(60));
//     console.log('üì¶ Skeleton updates available');
//     console.log('‚îÅ'.repeat(60));
//     console.log();
//     console.log('The following skeleton files have been updated:');
//     for (const p of updatesAvailable) {
//       console.log(`  - ${p}`);
//     }
//     console.log();
//     console.log('To review and merge updates:');
//     console.log('  diff vault/<file> skeleton/<file>');
//     console.log('  cp skeleton/<file> vault/<file>');
//     console.log();
//     console.log('‚îÅ'.repeat(60));
//     console.log();
//   }
// }

// ============================================================================
// Sync (DISABLED - replaced by plugin system: bin/plugins sync)
// ============================================================================

// function runSync(skipSync = false) {
//   if (skipSync) {
//     console.log('‚è≠Ô∏è  Skipping sync step');
//     return;
//   }
//
//   console.log('üîÑ Syncing data sources...');
//   try {
//     execSync('bin/sync', { stdio: 'inherit' });
//   } catch {
//     // Continue even if sync fails
//   }
// }

// ============================================================================
// Database Check
// ============================================================================

async function checkAndRecoverDatabase() {
  // Skip in tests for faster execution
  if (process.env.SKIP_DB_HEALTH) {
    return;
  }

  console.log('üîç Checking database health...');
  const result = await ensureHealthyDatabase({ verbose: true });

  if (!result.success) {
    console.error('‚ùå Database check failed');
    process.exit(1);
  }

  if (result.recreated) {
    console.log('‚ÑπÔ∏è  Run bin/sync to populate data from external sources\n');
  }
}

// ============================================================================
// Claude Auth Check (DISABLED - can be re-enabled when needed)
// ============================================================================

// function checkClaudeAuth() {
//   console.log('üîê Checking Claude authentication...');
//   try {
//     const result = spawnSync('claude', ['-p', 'Say "ok"'], { encoding: 'utf8' });
//     const output = (result.stdout || '') + (result.stderr || '');
//
//     if (output.includes('Invalid API key') || output.includes('Please run /login') || output.includes('not authenticated')) {
//       console.log('\n‚ö†Ô∏è  Claude CLI is not authenticated!');
//       console.log('‚îÅ'.repeat(50));
//       console.log('\nClaude is essential for daily reviews.');
//       console.log('Please authenticate now by running:\n');
//       console.log('  claude\n');
//       console.log('Then follow the browser prompt to login.');
//       console.log('After authentication, run \'bin/today\' again.');
//       console.log('‚îÅ'.repeat(50));
//       process.exit(1);
//     }
//
//     console.log('‚úÖ Claude is authenticated\n');
//   } catch {
//     console.log('‚úÖ Claude check passed\n');
//   }
// }

// ============================================================================
// Time Tracking Widgets (DISABLED - depends on vault/template features)
// ============================================================================

// function ensureTimeTrackingWidgets(dryRun = false) {
//   console.log('‚è±Ô∏è  Checking time tracking widgets...');
//
//   const { year, month, week, quarter, timezone } = getDateComponents();
//
//   // Define plan files with their date ranges
//   const quarterEndDays = [31, 30, 30, 31];
//   const quarterNum = parseInt(quarter.slice(1));
//   const planFiles = [
//     [`vault/plans/${year}_00.md`, `${year}-01-01`, `${year}-12-31`, 'Year'],
//     [`vault/plans/${year}_${quarter}_00.md`,
//     `${year}-${String((quarterNum - 1) * 3 + 1).padStart(2, '0')}-01`,
//     `${year}-${String(quarterNum * 3).padStart(2, '0')}-${quarterEndDays[quarterNum - 1]}`,
//       quarter],
//     [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_00.md`,
//     `${year}-${String(month).padStart(2, '0')}-01`,
//     `${year}-${String(month).padStart(2, '0')}-${new Date(year, month, 0).getDate()}`,
//     new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' })],
//     [`vault/plans/${year}_${quarter}_${String(month).padStart(2, '0')}_W${String(week).padStart(2, '0')}_00.md`,
//       null, null, `Week ${week}`],
//   ];
//
//   // Calculate week start/end for the week file
//   try {
//     const weekStart = execSync(`TZ=${timezone} date -d "$(date +%Y-W${String(week).padStart(2, '0')}-1)" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
//     const weekEnd = execSync(`TZ=${timezone} date -d "${weekStart} +6 days" "+%Y-%m-%d"`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
//     planFiles[3][1] = weekStart;
//     planFiles[3][2] = weekEnd;
//   } catch {
//     // Skip week file if we can't calculate dates
//   }
//
//   const filesUpdated = [];
//
//   for (const [filePath, startDate, endDate, periodName] of planFiles) {
//     if (!fs.existsSync(filePath)) continue;
//     if (!startDate || !endDate) continue;
//
//     const content = fs.readFileSync(filePath, 'utf8');
//
//     // Check if time tracking widget already exists
//     if (content.includes('scripts/time-tracking-widget')) continue;
//     if (/## ‚è±Ô∏è Time Tracking/.test(content)) continue;
//
//     const widgetSection = `
// ## ‚è±Ô∏è Time Tracking - ${periodName}
//
// \`\`\`dataviewjs
// await dv.view("scripts/time-tracking-widget", { startDate: '${startDate}', endDate: '${endDate}' });
// \`\`\`
// `;
//
//     const updatedContent = content.trimEnd() + '\n' + widgetSection + '\n';
//
//     if (dryRun) {
//       console.log(`   Would add time tracking to: ${filePath}`);
//     } else {
//       fs.writeFileSync(filePath, updatedContent);
//       filesUpdated.push([periodName, filePath]);
//     }
//   }
//
//   if (filesUpdated.length > 0 && !dryRun) {
//     console.log(`‚úÖ Added time tracking widgets to ${filesUpdated.length} file(s):`);
//     for (const [periodName, filePath] of filesUpdated) {
//       console.log(`   ${periodName}: ${filePath}`);
//     }
//   } else {
//     console.log('‚úÖ All plan files have time tracking widgets');
//   }
//
//   console.log();
// }

// ============================================================================
// Template Processing (DISABLED - depends on vault/template features)
// ============================================================================

// function createFileFromTemplate(filePath, targetDate, isTomorrow = false) {
//   const templateFile = 'vault/templates/daily-plan.md';
//   if (!fs.existsSync(templateFile)) return;
//
//   // Ensure directory exists
//   fs.mkdirSync(path.dirname(filePath), { recursive: true });
//
//   let content = fs.readFileSync(templateFile, 'utf8');
//
//   // Use shared utilities for template variables
//   const replacements = getTemplateVariables(targetDate);
//   content = applyTemplateVariables(content, replacements);
//
//   // Add draft note for tomorrow's plan
//   if (isTomorrow) {
//     const [, stageFocus] = getStageInfo(targetDate);
//     const draftNote = '\n> [!info] Draft Plan\n> This is a preliminary plan for tomorrow. It will be refined throughout today.\n\n';
//     content = content.replace('**Theme:** ' + stageFocus, '**Theme:** ' + stageFocus + draftNote);
//   }
//
//   fs.writeFileSync(filePath, content);
// }

// DISABLED - depends on template/vault features above
// function createReviewFromTemplate() {
//   const filesCreated = [];
//
//   // Create for today
//   const todayFile = getReviewFilePath();
//   if (!fs.existsSync(todayFile)) {
//     console.log('üìù Creating today\'s plan from template...');
//     createFileFromTemplate(todayFile, new Date(), false);
//     filesCreated.push(['today', todayFile]);
//   }
//
//   // Create for tomorrow
//   const tomorrow = getTomorrowDate();
//   const tomorrowFile = getReviewFilePath(tomorrow);
//   if (!fs.existsSync(tomorrowFile)) {
//     console.log('üìù Creating tomorrow\'s plan from template...');
//     createFileFromTemplate(tomorrowFile, tomorrow, true);
//     filesCreated.push(['tomorrow', tomorrowFile]);
//   }
//
//   if (filesCreated.length > 0) {
//     console.log('‚úÖ Created review files:');
//     for (const [label, p] of filesCreated) {
//       console.log(`   ${label.charAt(0).toUpperCase() + label.slice(1)}: ${p}`);
//     }
//     console.log();
//   }
//
//   return todayFile;
// }

// ============================================================================
// Interactive Session
// ============================================================================

/**
 * Build data context for AI prompt
 * Groups data by plugin type with schema, instructions, and current data
 */
async function getDataContext() {
  // Skip context gathering in test mode for faster tests
  if (process.env.SKIP_CONTEXT === 'true') {
    return `# Data Sources
(Context gathering skipped for testing)`;
  }

  try {
    const pluginTypes = getPluginTypes();
    const instructionsByType = await getAIInstructionsByType();
    const sections = [];

    for (const pluginType of pluginTypes) {
      const ai = getAIMetadata(pluginType);
      if (!ai) continue;

      // Context plugins are handled separately - run each plugin's read command
      if (pluginType === 'context') {
        const contextData = await getContextPluginsData(instructionsByType.get('context'));
        if (contextData) {
          sections.push(contextData);
        }
        continue;
      }

      const typeData = instructionsByType.get(pluginType);
      if (!typeData || typeData.sources.length === 0) continue;

      // Run the default command to get current data
      let currentData = '';
      try {
        console.log(`  ‚è≥ ${ai.name || pluginType}...`);
        currentData = execSync(ai.defaultCommand + ' 2>/dev/null', {
          encoding: 'utf8',
          timeout: 10000
        });
        // Filter out dotenvx noise
        currentData = currentData.split('\n')
          .filter(line => !line.includes('[dotenvx'))
          .join('\n');
      } catch {
        currentData = '(No data available)';
      }

      // Generate context block
      const block = generateAIContextBlock(pluginType, {
        userInstructions: typeData.instructions,
        currentData
      });

      if (block) {
        sections.push(block);
      }
    }

    if (sections.length === 0) return '';

    const intro = `# Data Sources

The following data is synced from external sources via the plugin system.
Each section shows current data and instructions for querying more.

- Run \`bin/plugins list\` to see available plugins
- Run \`bin/plugins sync\` to refresh data from all sources
- Run \`bin/plugins sync <plugin-name>\` to sync a specific plugin

`;

    return intro + sections.join('\n\n---\n\n');
  } catch (error) {
    // Silently fail if plugin system has issues
    return '';
  }
}

/**
 * Get data context for a specific date using CLI commands
 * Used for generating summaries of past days
 * Uses dateCommand from schema to call each CLI with --date
 */
async function getDataContextForDate(targetDate) {
  const sections = [];
  const pluginTypes = getPluginTypes();

  // Only include types relevant for historical data (have dateCommand defined)
  const historicalTypes = ['time-logs', 'diary', 'events', 'tasks', 'habits'];

  for (const pluginType of pluginTypes) {
    if (!historicalTypes.includes(pluginType)) continue;

    const schema = schemas[pluginType];
    if (!schema || !schema.ai?.dateCommand) continue;

    // Build the command with $DATE substituted
    const command = schema.ai.dateCommand.replace('$DATE', targetDate);

    try {
      const output = execSync(command, {
        cwd: projectRoot,
        encoding: 'utf8',
        timeout: 30000,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      // Filter out dotenvx noise and empty lines
      const cleanOutput = output.split('\n')
        .filter(line => !line.includes('[dotenvx'))
        .join('\n')
        .trim();

      if (!cleanOutput || cleanOutput.includes('No ')) continue;

      // Generate the full context block using the schema system
      const block = generateAIContextBlock(pluginType, {
        userInstructions: [],
        currentData: cleanOutput,
        commandUsed: command
      });

      if (block) {
        sections.push(block);
      }
    } catch {
      // Command failed - skip this type
    }
  }

  if (sections.length === 0) {
    return `# Data Sources\n(No data found for ${targetDate})`;
  }

  const intro = `# Data Sources for ${targetDate}

The following data was retrieved for the specified date.

`;

  return intro + sections.join('\n\n---\n\n');
}

/**
 * Get data from context plugins by running their read commands
 */
async function getContextPluginsData(typeData) {
  if (!typeData || typeData.sources.length === 0) return null;

  const lines = ['## Contextual Information', ''];

  for (const sourceId of typeData.sources) {
    try {
      // sourceId format: "plugin-name/source-name"
      const [pluginName, sourceName] = sourceId.split('/');
      const pluginPath = path.join(projectRoot, 'plugins', pluginName);
      const readScript = path.join(pluginPath, 'read.js');

      if (!fs.existsSync(readScript)) continue;

      // Get the source config for this plugin
      const sources = getPluginSources(pluginName);
      const sourceConfig = sources.find(s => s.sourceName === sourceName)?.config || {};

      console.log(`  ‚è≥ ${pluginName}...`);

      // Run from project root so relative paths work correctly
      const output = execSync(`node "${readScript}"`, {
        cwd: projectRoot,
        encoding: 'utf8',
        timeout: 30000,
        env: {
          ...process.env,
          PROJECT_ROOT: projectRoot,
          PLUGIN_CONFIG: JSON.stringify(sourceConfig),
          SOURCE_ID: sourceId
        }
      });

      const data = JSON.parse(output);

      // Context plugins should provide a 'context' field with pre-formatted text
      if (data.context) {
        lines.push(data.context);
        lines.push('');
      }
    } catch {
      // Silently continue if plugin fails
    }
  }

  return lines.length > 2 ? lines.join('\n') : null;
}

async function runInteractiveSession(directRequest = null, nonInteractive = false, dryRun = false, targetDate = null) {
  // DISABLED - depends on getReviewFilePath/getTomorrowDate
  // const todayFile = getReviewFilePath();
  // const tomorrowFile = getReviewFilePath(getTomorrowDate());
  const timezone = getTimezone();

  const now = getCurrentTime(timezone);
  const currentTime = formatFullDateTime(now, timezone);

  // Gather context from plugins or database (for specific dates)
  let dataContext;
  if (targetDate) {
    console.log(`üìä Gathering context for ${targetDate}...`);
    dataContext = await getDataContextForDate(targetDate);
  } else {
    console.log('üìä Gathering context...');
    dataContext = await getDataContext();
  }
  console.log('‚úÖ Context ready\n');
  const config = getFullConfig();

  // Build user profile section
  const profile = config.profile || {};
  const profileLines = [];
  if (profile.name) profileLines.push(`- **Name**: ${profile.name}`);
  if (config.location) profileLines.push(`- **Location**: ${config.location}`);
  if (profile.home_location && profile.home_location !== config.location) {
    profileLines.push(`- **Home**: ${profile.home_location}`);
  }
  profileLines.push(`- **Timezone**: ${timezone}`);
  if (profile.vocation) profileLines.push(`- **Vocation**: ${profile.vocation}`);
  if (profile.wake_time) profileLines.push(`- **Wake time**: ${profile.wake_time}`);
  if (profile.bed_time) profileLines.push(`- **Bed time**: ${profile.bed_time}`);
  if (profile.birthdate) profileLines.push(`- **Birthdate**: ${profile.birthdate}`);

  // Build the context section (user info and data sources)
  const timeInfo = targetDate
    ? `- **Target Date**: ${targetDate}\n- **Generated At**: ${currentTime} (${timezone})`
    : `- **Current Time**: ${currentTime} (${timezone})`;

  // Get user's general AI instructions
  const aiInstructions = config.ai?.ai_instructions?.trim();
  const aiInstructionsSection = aiInstructions
    ? `\n## User Instructions\n${aiInstructions}\n`
    : '';

  const contextSection = `## Pre-Computed Context
${timeInfo}

## Database
- **Path**: .data/today.db (SQLite)
- **Direct queries**: sqlite3 .data/today.db "SELECT ..."

## User Profile
${profileLines.join('\n')}
${aiInstructionsSection}
${dataContext}`;

  // Dry run with --date: just output data context (for consumption by other tools)
  if (dryRun && targetDate) {
    console.log(contextSection);
    return;
  }

  // Build the prompt
  let prompt;
  const intro = `You are an agent helping a user. Information about the user and the user's context is provided below.`;

  if (directRequest) {
    const requestSection = `The user's request is:

> ${directRequest}`;

    if (nonInteractive) {
      prompt = `${intro}

## CRITICAL: You are in NON-INTERACTIVE mode
- You have FULL PERMISSION to create, update, and modify files
- Do NOT ask for permission - execute the requested actions immediately
- Complete the task WITHOUT asking for confirmation

${requestSection}

${contextSection}`;
    } else {
      prompt = `${intro}

${requestSection}

${contextSection}`;
    }
  } else {
    prompt = `${intro}

Look at the user's current situation and offer suggestions of what the user should do.

${contextSection}`;
  }

  // Dry run - just output the prompt
  if (dryRun) {
    console.log(prompt);
    return;
  }

  // Actually run the AI session
  const interactiveProvider = getInteractiveProviderName();
  const model = getInteractiveModel();

  // Check provider - currently only Claude Code CLI is supported
  if (interactiveProvider !== 'anthropic') {
    console.error(`Error: Interactive sessions only support 'anthropic' provider currently.`);
    console.error(`Your config has: interactive_provider = "${interactiveProvider}"`);
    console.error(`Please set interactive_provider = "anthropic" in config.toml`);
    process.exit(1);
  }

  if (directRequest && nonInteractive) {
    console.log('ü§ñ Running in non-interactive mode...');
    try {
      spawnSync('timeout', ['600', 'claude', '--model', model, '--print', '--dangerously-skip-permissions', prompt], { stdio: 'inherit' });
    } catch (e) {
      console.error(`ERROR: Command timed out or failed after 10 minutes: ${e.message}`);
      process.exit(1);
    }
  } else if (directRequest) {
    console.log('ü§ñ Starting session...');
    spawnSync('claude', ['--model', model, prompt], { stdio: 'inherit' });
  } else {
    console.log('ü§ñ Starting daily review...');
    spawnSync('claude', ['--model', model, prompt], { stdio: 'inherit' });
  }

  // Session end summary
  console.log('\n' + '‚îÅ'.repeat(50));
  console.log('‚úÖ Session ended\n');
  // DISABLED - depends on getReviewFilePath/getTomorrowDate
  // console.log('üìù Your plans are in:');
  // console.log(`   Today: ${todayFile}`);
  // console.log(`   Tomorrow: ${tomorrowFile}\n`);
  console.log('üí° Track progress with:');
  console.log('   bin/diary add progress \'note\'');
  console.log('‚îÅ'.repeat(50) + '\n');
}

// ============================================================================
// Configuration UI (ink-based React TUI)
// ============================================================================

import { runConfigure } from '../src/configure-ui.js';

// ============================================================================
// Main
// ============================================================================

function showHelp() {
  console.log(`Today - Daily review and planning tool

Usage:
  bin/today [options] [command] [request]

Commands:
  (none)      Start interactive daily review session
  configure   Open configuration UI for system settings
  now         Quick "what should I do right now?" session
  dry-run     Show the prompt that would be sent to the AI (no API call)

Options:
  --date DATE       Target date (YYYY-MM-DD) - queries historical data
  --no-sync         Skip sync step (faster startup)
  --non-interactive Run in non-interactive mode (for automation)
  -h, --help        Show this help message

Examples:
  bin/today                           # Start daily review
  bin/today configure                 # Configure system settings
  bin/today now                       # Quick "what should I do now?" session
  bin/today dry-run                   # Show prompt without running Claude
  bin/today dry-run --date 2025-12-15 # Show prompt for a specific date
  bin/today "fix the bug in login"    # Focused session with specific request

Files:
  Today's plan:    vault/plans/YYYY_QQ_MM_W##_DD.md
  Tomorrow's plan: vault/plans/YYYY_QQ_MM_W##_DD.md (next day)
`);
}

async function main() {
  const args = process.argv.slice(2);

  // Handle help early
  if (args.includes('-h') || args.includes('--help')) {
    showHelp();
    return;
  }

  // Parse arguments
  let command = null;
  let request = [];
  let noSync = false;
  let nonInteractive = false;
  let targetDate = null;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--no-sync') {
      noSync = true;
    } else if (args[i] === '--non-interactive') {
      nonInteractive = true;
    } else if (args[i] === '--date' && args[i + 1]) {
      targetDate = args[i + 1];
      i++; // Skip the next arg (the date value)
    } else if (!command && ['init', 'update', 'dry-run', 'now', 'configure'].includes(args[i])) {
      command = args[i];
    } else {
      request.push(args[i]);
    }
  }

  let directRequest = request.length > 0 ? request.join(' ') : null;

  // DISABLED - checkVaultExists not yet migrated to plugin system
  // // Check if vault exists (unless in non-interactive mode)
  // if (!nonInteractive) {
  //   const vaultExists = await checkVaultExists();
  //   if (!vaultExists) {
  //     console.log('Cannot continue without vault directory.');
  //     process.exit(1);
  //   }
  // }

  // DISABLED - checkSkeletonUpdates not yet migrated to plugin system
  // // Check skeleton updates (unless in non-interactive mode)
  // if (!nonInteractive) {
  //   checkSkeletonUpdates();
  // }

  // Handle configure command - doesn't need database
  if (command === 'configure') {
    await runConfigure();
    return;
  }

  // Always check database health first (except for help which returns early)
  await checkAndRecoverDatabase();

  // DISABLED - init command depends on template features
  // // Handle init command
  // if (command === 'init') {
  //   console.log('üìÖ Initializing review file hierarchy...');
  //   createReviewFromTemplate();
  //   console.log('‚úÖ Review hierarchy is ready!');
  //   return;
  // }

  // Handle dry-run command - show what prompt would be sent to AI
  if (command === 'dry-run') {
    await runInteractiveSession(directRequest, nonInteractive, true /* dryRun */, targetDate);
    return;
  }

  // Handle now command - quick "what should I do right now?" query
  if (command === 'now') {
    directRequest = 'What should I do *right now*?';
  }

  // Display appropriate message
  if (directRequest) {
    console.log(`üìä Starting focused session: ${directRequest}`);
  } else {
    console.log('üìä Starting daily review process...');
  }

  // DISABLED - checkClaudeAuth not yet migrated
  // // Check Claude authentication (unless non-interactive)
  // if (!nonInteractive) {
  //   checkClaudeAuth();
  // }

  // Run sync (unless skipped or using historical date)
  if (targetDate) {
    console.log('‚ö†Ô∏è  Skipping sync (using historical date)');
  } else if (!noSync) {
    console.log('üîÑ Syncing data sources...');
    try {
      execSync('bin/plugins sync', { stdio: 'inherit', cwd: projectRoot });
    } catch (error) {
      console.error('‚ö†Ô∏è  Sync completed with some errors');
    }
  } else {
    console.log('‚ö†Ô∏è  Skipping sync (--no-sync flag provided)');
  }

  // DISABLED - createReviewFromTemplate depends on template features
  // // Create review file from template if needed
  // createReviewFromTemplate();

  // Run the appropriate session
  await runInteractiveSession(directRequest, nonInteractive, false, targetDate);
}

main().catch((e) => {
  console.error(`‚ùå Fatal error: ${e.message}`);
  process.exit(1);
});
