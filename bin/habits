#!/usr/bin/env node

import { getDatabase } from '../src/database-service.js';
import { ensureSyncForType, getSyncStatusMessage } from '../src/plugin-loader.js';
import { getTodayDate } from '../src/date-utils.js';
import { program } from 'commander';
import { colors } from '../src/cli-utils.js';
import { execSync } from 'child_process';

// Status emoji map
const STATUS_EMOJI = {
  completed: '‚úÖ',
  pending: '‚è≥',
  skipped: '‚è≠Ô∏è',
  partial: 'üî∂'
};

program
  .name('habits')
  .description('Habit tracking for Today system');

// Sync command - syncs habits via plugin system
program
  .command('sync')
  .description('Sync habits from all enabled habit plugins')
  .action(async () => {
    console.log(colors.blue('‚Ñπ') + ' Syncing habits plugins to database...');

    try {
      const result = execSync('bin/plugins sync --type habits', { encoding: 'utf8' });
      // Strip dotenvx output and show result
      const lines = result.split('\n').filter(l => !l.includes('[dotenvx'));
      console.log(lines.join('\n'));
    } catch (error) {
      if (error.stdout?.includes('No plugins of type')) {
        console.log(colors.yellow('‚ö†') + ' No habits plugins are enabled.');
        console.log('');
        console.log('To sync habits, configure a plugin:');
        console.log('');
        console.log('  ' + colors.cyan('bin/plugins configure'));
      } else {
        console.error(colors.red('‚úó') + ' Sync failed:', error.message);
        process.exit(1);
      }
    }
  });

// Today command - show today's habits
program
  .command('today')
  .description('Show today\'s habits and their status')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    const db = getDatabase();
    ensureSyncForType(db, 'habits');

    const today = getTodayDate();

    let sql = `
      SELECT habit_id, title, status, value, category, goal_type,
             json_extract(metadata, '$.current_streak') as streak,
             json_extract(metadata, '$.target_type') as target_type,
             json_extract(metadata, '$.target_value') as target_value
      FROM habits
      WHERE date = ?
    `;
    const params = [today];

    if (options.source) {
      sql += ` AND source LIKE ?`;
      params.push(`%${options.source}%`);
    }

    sql += ` ORDER BY status DESC, category, title`;

    const habits = db.prepare(sql).all(...params);

    if (habits.length === 0) {
      console.log(colors.blue('‚Ñπ') + ' No habits for today');
      console.log(getSyncStatusMessage(db, 'habits'));
      return;
    }

    // Group by status and goal type
    const pending = habits.filter(h => h.status === 'pending' && h.goal_type !== 'limit');
    const completed = habits.filter(h => h.status === 'completed');
    const limits = habits.filter(h => h.goal_type === 'limit' && h.status !== 'completed');
    const other = habits.filter(h => !['pending', 'completed'].includes(h.status) && h.goal_type !== 'limit');

    console.log('');
    console.log(colors.cyan(`Today's Habits`) + ` (${today})`);
    console.log('');

    // Helper to format habit line based on goal_type
    const formatHabit = (h, showStreak = false) => {
      let emoji = STATUS_EMOJI[h.status] || '‚ùì';
      let suffix = '';

      if (h.goal_type === 'limit') {
        // Limit habits: show value vs target
        if (h.status === 'completed' || h.status === 'partial') {
          emoji = '‚úÖ'; // Under the limit = success
          if (h.value != null && h.target_value) {
            const val = Number(h.value).toFixed(1).replace(/\.0$/, '');
            suffix = colors.gray(` (${val}/${h.target_value})`);
          }
        } else if (h.status === 'skipped') {
          emoji = '‚ùå'; // Exceeded limit
        }
      } else {
        // Achieve habits
        if (h.value && h.target_type === 'timer') {
          suffix = colors.gray(` (${formatDuration(h.value)})`);
        } else if (h.target_type === 'steps' && h.value != null && h.target_value) {
          suffix = colors.gray(` (${h.value}/${h.target_value} steps)`);
        }
      }

      if (showStreak && h.streak > 0) {
        suffix += colors.gray(` üî•${h.streak}`);
      }

      return `  ${emoji} ${h.title}${suffix}`;
    };

    if (pending.length > 0) {
      console.log(colors.yellow('Pending:'));
      for (const h of pending) {
        let suffix = '';
        // Show steps for routines
        if (h.target_type === 'steps' && h.target_value) {
          const done = h.value || 0;
          suffix = colors.gray(` (${done}/${h.target_value} steps)`);
        }
        if (h.streak > 0) {
          suffix += colors.gray(` (${h.streak} day streak)`);
        }
        console.log(`  ${STATUS_EMOJI.pending} ${h.title}${suffix}`);
      }
      console.log('');
    }

    if (completed.length > 0) {
      console.log(colors.green('Completed:'));
      for (const h of completed) {
        console.log(formatHabit(h, true));
      }
      console.log('');
    }

    if (limits.length > 0) {
      console.log(colors.blue('Limits:'));
      for (const h of limits) {
        console.log(formatHabit(h, true));
      }
      console.log('');
    }

    if (other.length > 0) {
      console.log(colors.gray('Skipped/Partial:'));
      for (const h of other) {
        console.log(formatHabit(h, false));
      }
      console.log('');
    }

    // Summary
    console.log(colors.gray(`${completed.length}/${habits.length} completed`));
    console.log(getSyncStatusMessage(db, 'habits'));
  });

// List command - list all habits
program
  .command('list')
  .description('List habits from database')
  .option('-d, --date <date>', 'Show habits for specific date (YYYY-MM-DD)')
  .option('-c, --category <category>', 'Filter by category')
  .option('--status <status>', 'Filter by status (completed, pending, skipped)')
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    const db = getDatabase();
    ensureSyncForType(db, 'habits');

    const date = options.date || getTodayDate();

    let conditions = ['date = ?'];
    const params = [date];

    if (options.category) {
      conditions.push('category = ?');
      params.push(options.category);
    }

    if (options.status) {
      conditions.push('status = ?');
      params.push(options.status);
    }

    if (options.source) {
      conditions.push('source LIKE ?');
      params.push(`%${options.source}%`);
    }

    const sql = `
      SELECT habit_id, title, status, value, category,
             json_extract(metadata, '$.current_streak') as streak
      FROM habits
      WHERE ${conditions.join(' AND ')}
      ORDER BY category, title
    `;

    const habits = db.prepare(sql).all(...params);

    if (habits.length === 0) {
      console.log(colors.blue('‚Ñπ') + ` No habits found for ${date}`);
      return;
    }

    console.log('');
    let currentCategory = undefined; // Use undefined so null (uncategorized) is detected as change
    for (const h of habits) {
      if (h.category !== currentCategory) {
        if (currentCategory !== undefined) console.log('');
        console.log(colors.cyan(h.category || 'Uncategorized'));
        currentCategory = h.category;
      }
      const emoji = STATUS_EMOJI[h.status] || '‚ùì';
      const streakStr = h.streak > 0 ? colors.gray(` üî•${h.streak}`) : '';
      console.log(`  ${emoji} ${h.title}${streakStr}`);
    }

    console.log('');
    console.log(colors.gray(`${habits.length} habits`));
    console.log(getSyncStatusMessage(db, 'habits'));
  });

// Streaks command - show current streaks
program
  .command('streaks')
  .description('Show current streaks for all habits')
  .option('--min <days>', 'Minimum streak length to show', (val) => parseInt(val, 10), 1)
  .option('--source <source>', 'Filter by plugin source')
  .action(async (options) => {
    const db = getDatabase();
    ensureSyncForType(db, 'habits');

    const today = getTodayDate();

    let sql = `
      SELECT DISTINCT habit_id, title, category,
             json_extract(metadata, '$.current_streak') as streak
      FROM habits
      WHERE date = ?
    `;
    const params = [today];

    if (options.source) {
      sql += ` AND source LIKE ?`;
      params.push(`%${options.source}%`);
    }

    sql += ` ORDER BY streak DESC, title`;

    const habits = db.prepare(sql).all(...params);

    // Filter by minimum streak
    const filtered = habits.filter(h => (h.streak || 0) >= options.min);

    if (filtered.length === 0) {
      console.log(colors.blue('‚Ñπ') + ` No habits with streak >= ${options.min} days`);
      return;
    }

    console.log('');
    console.log(colors.cyan('Current Streaks'));
    console.log('');

    for (const h of filtered) {
      const streakBar = 'üî•'.repeat(Math.min(h.streak, 5));
      const extraDays = h.streak > 5 ? `+${h.streak - 5}` : '';
      console.log(`  ${streakBar}${extraDays} ${h.title} (${h.streak} days)`);
    }

    console.log('');
    console.log(getSyncStatusMessage(db, 'habits'));
  });

// History command - show habit history
program
  .command('history <habit>')
  .description('Show history for a specific habit')
  .option('-d, --days <days>', 'Number of days to show', parseInt, 14)
  .option('--source <source>', 'Filter by plugin source')
  .action(async (habitName, options) => {
    const db = getDatabase();
    ensureSyncForType(db, 'habits');

    let sql = `
      SELECT date, status, value,
             json_extract(metadata, '$.target_type') as target_type
      FROM habits
      WHERE title LIKE ?
    `;
    const params = [`%${habitName}%`];

    if (options.source) {
      sql += ` AND source LIKE ?`;
      params.push(`%${options.source}%`);
    }

    sql += ` ORDER BY date DESC LIMIT ?`;
    params.push(options.days);

    const entries = db.prepare(sql).all(...params);

    if (entries.length === 0) {
      console.log(colors.blue('‚Ñπ') + ` No history found for "${habitName}"`);
      return;
    }

    // Get the actual habit title from first entry
    const firstEntry = db.prepare(`
      SELECT title FROM habits WHERE title LIKE ? LIMIT 1
    `).get(`%${habitName}%`);

    console.log('');
    console.log(colors.cyan(firstEntry?.title || habitName));
    console.log('');

    for (const e of entries) {
      const emoji = STATUS_EMOJI[e.status] || '‚ùì';
      const valueStr = e.value && e.target_type === 'timer'
        ? ` (${formatDuration(e.value)})`
        : '';
      console.log(`  ${e.date} ${emoji}${valueStr}`);
    }

    console.log('');
    console.log(getSyncStatusMessage(db, 'habits'));
  });

// Helper: format duration in seconds to human readable
function formatDuration(seconds) {
  if (!seconds || seconds <= 0) return '0s';

  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
  }
  if (minutes > 0) {
    return secs > 0 ? `${minutes}m ${secs}s` : `${minutes}m`;
  }
  return `${secs}s`;
}

// Handle --date option at top level (used by bin/today for historical queries)
// Shows habits and their completion status for a specific date
const dateArgIdx = process.argv.findIndex(a => a === '--date');
if (dateArgIdx > 0 && process.argv[dateArgIdx + 1]) {
  const targetDate = process.argv[dateArgIdx + 1];
  const db = getDatabase();
  ensureSyncForType(db, 'habits');

  const sql = `
    SELECT habit_id, title, status, value, category, goal_type,
           json_extract(metadata, '$.target_type') as target_type
    FROM habits
    WHERE date = ?
    ORDER BY status DESC, category, title
  `;

  const habits = db.prepare(sql).all(targetDate);

  if (habits.length === 0) {
    console.log(`No habits for ${targetDate}`);
  } else {
    for (const h of habits) {
      let emoji = STATUS_EMOJI[h.status] || '‚óã';
      if (h.goal_type === 'limit' && h.status === 'completed') emoji = '‚úì';

      let suffix = '';
      if (h.value && h.target_type === 'timer') {
        suffix = `, ${formatDuration(h.value)}`;
      }

      const category = h.category ? `[${h.category}] ` : '';
      console.log(`${emoji} ${category}${h.title}${suffix}`);
    }
  }
  process.exit(0);
}

program.parse();
