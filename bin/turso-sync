#!/usr/bin/env node

/**
 * Turso Sync Utility
 * Uses the DatabaseService for all sync operations
 * 
 * This is now a thin wrapper around DatabaseService that provides
 * command-line interface for manual sync control
 */

import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { DatabaseService, getDatabase } from '../src/database-service.js';
import { MigrationManager } from '../src/migrations.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const LOCAL_DB = path.join(process.cwd(), '.data', 'today.db');
const SYNC_STATE_FILE = path.join(process.cwd(), '.data', 'turso-sync.json');

class TursoSync {
  constructor() {
    // Force a new instance for manual control (don't use singleton)
    this.db = new DatabaseService(LOCAL_DB, { 
      forceNew: true, 
      autoSync: false  // Manual control only
    });
    this.syncState = this.loadSyncState();
  }

  loadSyncState() {
    if (fs.existsSync(SYNC_STATE_FILE)) {
      try {
        return JSON.parse(fs.readFileSync(SYNC_STATE_FILE, 'utf8'));
      } catch (e) {
        return { lastSync: null, initialized: false };
      }
    }
    return { lastSync: null, initialized: false };
  }

  saveSyncState() {
    const dir = path.dirname(SYNC_STATE_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(SYNC_STATE_FILE, JSON.stringify(this.syncState, null, 2));
  }

  async status() {
    console.log(chalk.blue('ðŸ“Š Turso Sync Status\n'));

    // Local database status
    if (fs.existsSync(LOCAL_DB)) {
      const stats = fs.statSync(LOCAL_DB);
      const localSize = (stats.size / 1024 / 1024).toFixed(2);
      const localModified = new Date(stats.mtime).toLocaleString();
      
      console.log(chalk.cyan('Local Database:'));
      console.log(chalk.white(`   Path: ${LOCAL_DB}`));
      console.log(chalk.white(`   Size: ${localSize} MB`));
      console.log(chalk.white(`   Modified: ${localModified}`));
      
      try {
        const localTaskCount = this.db.get('SELECT COUNT(*) as count FROM tasks')?.count || 0;
        console.log(chalk.white(`   Tasks: ${localTaskCount}`));
      } catch (e) {
        console.log(chalk.yellow('   Unable to count tasks'));
      }
    } else {
      console.log(chalk.yellow('âš ï¸  No local database found'));
      console.log(chalk.gray('   Run: bin/turso-sync pull'));
    }

    // Get sync status from DatabaseService
    const syncStatus = await this.db.getSyncStatus();
    
    console.log(chalk.cyan('\nTurso Database:'));
    if (syncStatus.connected) {
      const dbUrl = (syncStatus.syncUrl || '').replace('libsql://', '').substring(0, 60);
      console.log(chalk.white(`   URL: ${dbUrl}...`));
      console.log(chalk.green(`   Status: ${syncStatus.message}`));
      
      // Try to get task count from Turso
      if (this.db.tursoClient) {
        try {
          const result = await this.db.tursoClient.execute('SELECT COUNT(*) as count FROM tasks');
          const tursoTaskCount = result.rows[0].count;
          console.log(chalk.white(`   Tasks: ${tursoTaskCount}`));
          
          // Compare counts
          if (fs.existsSync(LOCAL_DB)) {
            const localTaskCount = this.db.get('SELECT COUNT(*) as count FROM tasks')?.count || 0;
            if (localTaskCount !== tursoTaskCount) {
              console.log(chalk.yellow('\nâš ï¸  Databases are out of sync'));
              console.log(chalk.gray('   Run: bin/turso-sync sync (for bidirectional sync)'));
            } else {
              console.log(chalk.green('\nâœ… Databases appear to be in sync'));
            }
          }
        } catch (error) {
          console.log(chalk.red(`   Error: ${error.message}`));
        }
      }
    } else {
      console.log(chalk.yellow(`   Status: ${syncStatus.message}`));
      if (syncStatus.error) {
        console.log(chalk.red(`   Error: ${syncStatus.error}`));
      }
    }

    if (this.syncState.lastSync) {
      console.log(chalk.gray(`\nLast sync: ${new Date(this.syncState.lastSync).toLocaleString()}`));
    }
  }

  async pull(options = {}) {
    const { full = false, batchSize = 500 } = options;
    
    if (full) {
      console.log(chalk.blue('ðŸ”„ Full pull from Turso (batched for large tables)...\n'));
    } else {
      console.log(chalk.blue('ðŸ“¥ Pulling from Turso to local...\n'));
    }
    
    if (!this.db.isConnectedToTurso()) {
      console.log(chalk.red('âŒ Not connected to Turso'));
      console.log(chalk.gray('   Check your TURSO_DATABASE_URL and TURSO_AUTH_TOKEN'));
      return;
    }

    // Run migrations first
    if (!fs.existsSync(LOCAL_DB)) {
      console.log(chalk.yellow('ðŸ”„ Initial setup - creating local database...'));
    }
    
    const migrations = new MigrationManager(this.db.localDb);
    await migrations.runMigrations();
    
    // Check if we need to create schema from Turso
    const needsSchema = await this.checkNeedsSchema();
    if (needsSchema) {
      console.log(chalk.yellow('ðŸ“‹ Creating schema from Turso...'));
      await this.createSchemaFromTurso();
    }
    
    const startTime = Date.now();
    
    if (full) {
      // Full batched pull - gets ALL data
      await this.fullPullBatched(batchSize);
    } else {
      // Use DatabaseService's incremental pull method
      console.log(chalk.gray('   Checking for updates...'));
      await this.db.pullFromTurso();
    }
    
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(chalk.green(`\nâœ… Pull completed in ${elapsed}s`));
    
    this.syncState.lastSync = new Date().toISOString();
    this.syncState.initialized = true;
    this.saveSyncState();
  }

  async fullPullBatched(batchSize = 500) {
    console.log(chalk.cyan('Step 1: Getting table list from Turso...'));
    
    // Get all tables from Turso
    const tablesResult = await this.db.tursoClient.execute(`
      SELECT name FROM sqlite_master 
      WHERE type='table' 
      AND name NOT LIKE 'sqlite_%'
      AND name NOT LIKE '_litestream_%'
      ORDER BY name
    `);
    
    const tables = tablesResult.rows.map(row => row.name);
    console.log(chalk.gray(`   Found ${tables.length} tables\n`));
    
    console.log(chalk.cyan('Step 2: Pulling ALL data from each table (in batches)...'));
    
    let totalRows = 0;
    for (const tableName of tables) {
      process.stdout.write(chalk.gray(`   ${tableName}... `));
      
      try {
        // First, get the total count
        const countResult = await this.db.tursoClient.execute(`SELECT COUNT(*) as count FROM ${tableName}`);
        const totalCount = countResult.rows[0].count;
        
        if (totalCount === 0) {
          console.log(chalk.gray('empty'));
          continue;
        }
        
        // Clear local table first
        this.db.exec(`DELETE FROM ${tableName}`);
        
        // Pull data in batches
        let offset = 0;
        let rowsPulled = 0;
        let columns = null;
        let stmt = null;
        
        while (offset < totalCount) {
          // Get batch of rows
          const dataResult = await this.db.tursoClient.execute(`
            SELECT * FROM ${tableName} 
            LIMIT ${batchSize} 
            OFFSET ${offset}
          `);
          
          if (dataResult.rows.length === 0) break;
          
          // Setup insert statement on first batch
          if (!columns) {
            columns = Object.keys(dataResult.rows[0]);
            const placeholders = columns.map(() => '?').join(', ');
            const insertSQL = `INSERT OR REPLACE INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            stmt = this.db.localDb.prepare(insertSQL);
          }
          
          // Insert batch in a transaction
          const transaction = this.db.localDb.transaction(() => {
            for (const row of dataResult.rows) {
              const values = columns.map(col => row[col]);
              stmt.run(...values);
            }
          });
          
          transaction();
          rowsPulled += dataResult.rows.length;
          offset += batchSize;
          
          // Show progress for large tables
          if (totalCount > batchSize * 2) {
            process.stdout.write(chalk.gray(`${Math.round(rowsPulled / totalCount * 100)}%... `));
          }
        }
        
        totalRows += rowsPulled;
        console.log(chalk.green(`${rowsPulled} rows`));
        
      } catch (error) {
        console.log(chalk.yellow(`failed: ${error.message}`));
        // Try to continue with other tables
      }
    }
    
    console.log(chalk.green(`\nâœ… Full pull complete: ${totalRows} total rows from ${tables.length} tables`));
    
    // Show final status
    const taskCount = this.db.get('SELECT COUNT(*) as count FROM tasks')?.count || 0;
    console.log(chalk.cyan(`\nLocal database now has ${taskCount} tasks`));
    
    // Check database size
    const stats = fs.statSync(LOCAL_DB);
    const sizeMB = (stats.size / 1024 / 1024).toFixed(1);
    console.log(chalk.cyan(`Database size: ${sizeMB} MB`));
  }

  async push() {
    console.log(chalk.blue('ðŸ“¤ Pushing from local to Turso...\n'));
    
    if (!this.db.isConnectedToTurso()) {
      console.log(chalk.red('âŒ Not connected to Turso'));
      console.log(chalk.gray('   Check your TURSO_DATABASE_URL and TURSO_AUTH_TOKEN'));
      return;
    }

    if (!fs.existsSync(LOCAL_DB)) {
      console.log(chalk.red('âŒ No local database to push'));
      return;
    }

    console.log(chalk.gray('   Scanning for changes...'));
    const startTime = Date.now();
    
    // Get tables with recent changes
    const cutoffTime = new Date(Date.now() - 10 * 60 * 1000).toISOString();
    console.log(chalk.gray(`   Looking for changes since ${new Date(cutoffTime).toLocaleTimeString()}...`));
    
    // Manually push recent changes (since autoSync is off)
    await this.manualPush();
    
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(chalk.green(`\nâœ… Push completed in ${elapsed}s`));
    
    this.syncState.lastSync = new Date().toISOString();
    this.saveSyncState();
  }

  async manualPush() {
    // Since DatabaseService queues pushes automatically, we need to manually
    // find and push recent changes
    const tables = await this.db.getSyncTables();
    let totalPushed = 0;
    let tablesWithChanges = 0;
    
    for (const tableName of tables) {
      try {
        // Skip system tables
        if (tableName.startsWith('_') || tableName.startsWith('sqlite_')) continue;
        
        // Check if table has recent changes
        const hasTimestamp = await this.db.tableHasTimestamp(tableName);
        let rows = [];
        
        if (hasTimestamp) {
          // Use appropriate windows based on table type
          let windowMs;
          if (tableName === 'tasks') {
            windowMs = 24 * 60 * 60 * 1000;  // 24 hours for tasks
          } else if (['contacts', 'emails', 'markdown_sync', 'task_cache', 'contact_addresses', 
                      'contact_emails', 'contact_phones'].includes(tableName)) {
            windowMs = 30 * 1000;  // 30 seconds for bulk-updated tables
          } else {
            windowMs = 5 * 60 * 1000;  // 5 minutes for other tables
          }
          const cutoffDate = new Date(Date.now() - windowMs);
          // Format as SQLite datetime: YYYY-MM-DD HH:MM:SS
          const cutoff = cutoffDate.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, '');
          
          // Build query based on available columns
          const columns = this.db.all(`PRAGMA table_info(${tableName})`);
          const columnNames = columns.map(c => c.name);
          const whereClauses = [];
          const params = [];
          
          if (columnNames.includes('updated_at')) {
            whereClauses.push('datetime(updated_at) > datetime(?)');
            params.push(cutoff);
          }
          if (columnNames.includes('created_at')) {
            whereClauses.push('datetime(created_at) > datetime(?)');
            params.push(cutoff);
          }
          if (columnNames.includes('last_synced')) {
            whereClauses.push('datetime(last_synced) > datetime(?)');
            params.push(cutoff);
          }
          
          if (whereClauses.length > 0) {
            const query = `SELECT * FROM ${tableName} WHERE ${whereClauses.join(' OR ')}`;
            rows = this.db.all(query, ...params);
          }
        } else {
          // Tables without timestamps - only sync very small static tables
          const count = this.db.get(`SELECT COUNT(*) as count FROM ${tableName}`)?.count || 0;
          if (count < 20) {  // Only sync tiny reference tables without timestamps
            rows = this.db.all(`SELECT * FROM ${tableName}`);
          }
        }
        
        if (rows.length > 0) {
          console.log(chalk.gray(`   ${tableName}: ${rows.length} rows to sync`));
          
          // For large datasets, use batch transactions
          const batchSize = 50;
          let processedInTable = 0;
          
          for (let i = 0; i < rows.length; i += batchSize) {
            const batch = rows.slice(i, Math.min(i + batchSize, rows.length));
            
            // Show progress for large tables
            if (rows.length > 100 && i > 0 && i % 100 === 0) {
              console.log(chalk.gray(`     Progress: ${i}/${rows.length} rows...`));
            }
            
            // Build batch insert statement
            try {
              const columns = Object.keys(batch[0]);
              const statements = batch.map(row => ({
                sql: `INSERT OR REPLACE INTO ${tableName} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')})`,
                args: Object.values(row)
              }));
              
              // Execute as batch transaction
              await this.db.tursoClient.batch(statements);
              totalPushed += batch.length;
              processedInTable += batch.length;
            } catch (error) {
              // Fall back to individual inserts on batch error
              for (const row of batch) {
                try {
                  const columns = Object.keys(row);
                  const sql = `INSERT OR REPLACE INTO ${tableName} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')})`;
                  await this.db.tursoClient.execute({ sql, args: Object.values(row) });
                  totalPushed++;
                  processedInTable++;
                } catch (err) {
                  // Ignore constraint errors
                }
              }
            }
          }
          tablesWithChanges++;
        }
      } catch (error) {
        // Skip tables that don't exist
      }
    }
    
    if (tablesWithChanges > 0) {
      console.log(chalk.green(`   âœ“ Pushed ${totalPushed} rows across ${tablesWithChanges} tables`));
    } else {
      console.log(chalk.gray('   No recent changes to push'));
    }
  }

  async sync() {
    console.log(chalk.cyan('ðŸ”„ Performing bidirectional sync...\n'));
    
    if (!this.db.isConnectedToTurso()) {
      console.log(chalk.red('âŒ Not connected to Turso'));
      console.log(chalk.gray('   Check your TURSO_DATABASE_URL and TURSO_AUTH_TOKEN'));
      return;
    }

    // Compare timestamps to determine sync direction
    const localTimestamp = this.db.getLocalLastModified();
    const tursoTimestamp = await this.db.getTursoLastModified();
    
    console.log(chalk.gray('   Comparing timestamps...'));
    if (localTimestamp) {
      console.log(chalk.gray(`   Local:  ${new Date(localTimestamp).toLocaleString()}`));
    }
    if (tursoTimestamp) {
      console.log(chalk.gray(`   Turso:  ${new Date(tursoTimestamp).toLocaleString()}`));
    }
    
    // Bidirectional sync based on timestamps
    if (tursoTimestamp && (!localTimestamp || tursoTimestamp > localTimestamp)) {
      console.log(chalk.blue('\nStep 1: Pulling newer data from Turso...'));
      await this.db.pullFromTurso();
    } else {
      console.log(chalk.gray('\nStep 1: Local is up-to-date, skipping pull'));
    }
    
    console.log(chalk.blue('\nStep 2: Pushing local changes to Turso...'));
    await this.manualPush();
    
    console.log(chalk.green('\nâœ… Bidirectional sync complete'));
    
    this.syncState.lastSync = new Date().toISOString();
    this.syncState.initialized = true;
    this.saveSyncState();
  }

  async watch() {
    console.log(chalk.blue('ðŸ‘€ Watching for changes...\n'));
    console.log(chalk.gray('   Syncing every 60 seconds'));
    console.log(chalk.gray('   Press Ctrl+C to stop\n'));

    // Enable auto-sync
    this.db.autoSync = true;
    this.db.startPullCheckInterval();
    
    // Also do manual pushes periodically
    const interval = setInterval(async () => {
      try {
        console.log(chalk.gray(`[${new Date().toLocaleTimeString()}] Checking for changes...`));
        
        // DatabaseService handles pulls automatically
        // We just need to handle pushes
        await this.db.forcePush();
        
        // Also do a manual push for tables without individual operations
        await this.manualPush();
        
      } catch (error) {
        console.log(chalk.red(`[${new Date().toLocaleTimeString()}] Sync error: ${error.message}`));
      }
    }, 60000);

    process.on('SIGINT', async () => {
      clearInterval(interval);
      console.log(chalk.yellow('\n\nStopping sync...'));
      this.db.stopPullCheckInterval();
      await this.db.forcePush();
      await this.db.close();
      process.exit(0);
    });
  }

  async checkNeedsSchema() {
    try {
      // Check if we have the main tables
      const result = this.db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='tasks'");
      return !result; // Need schema if tasks table doesn't exist
    } catch (e) {
      return true; // Need schema if query fails
    }
  }

  async createSchemaFromTurso() {
    try {
      // Get all table schemas from Turso
      const schemasResult = await this.db.tursoClient.execute(`
        SELECT sql FROM sqlite_master 
        WHERE type='table' 
        AND name NOT LIKE 'sqlite_%'
        AND name NOT LIKE '_litestream_%'
        AND sql IS NOT NULL
        ORDER BY name
      `);
      
      let created = 0;
      for (const row of schemasResult.rows) {
        if (row.sql) {
          try {
            this.db.exec(row.sql);
            created++;
          } catch (e) {
            // Table might already exist, that's OK
          }
        }
      }
      
      // Also get and create indexes
      const indexesResult = await this.db.tursoClient.execute(`
        SELECT sql FROM sqlite_master 
        WHERE type='index' 
        AND name NOT LIKE 'sqlite_%'
        AND sql IS NOT NULL
      `);
      
      let indexCount = 0;
      for (const row of indexesResult.rows) {
        if (row.sql) {
          try {
            this.db.exec(row.sql);
            indexCount++;
          } catch (e) {
            // Index might already exist
          }
        }
      }
      
      console.log(chalk.green(`   âœ“ Created ${created} tables and ${indexCount} indexes from Turso`));
    } catch (error) {
      console.log(chalk.red(`   Error creating schema: ${error.message}`));
      throw error;
    }
  }

  async close() {
    await this.db.close();
  }
}

async function main() {
  const sync = new TursoSync();
  const command = process.argv[2] || 'status';
  const args = process.argv.slice(3);

  try {
    switch (command) {
      case 'status':
        await sync.status();
        break;
        
      case 'sync':
        await sync.sync();
        break;
        
      case 'pull':
        // Check for --full flag
        const fullPull = args.includes('--full');
        await sync.pull({ full: fullPull });
        break;
        
      case 'push':
        // Check for --all flag
        if (args.includes('--all')) {
          console.log(chalk.yellow('ðŸ“¤ Note: --all flag is deprecated'));
          console.log(chalk.gray('   Push now automatically syncs all necessary tables'));
        }
        await sync.push();
        break;
        
      case 'watch':
        await sync.watch();
        break;
        
      case 'help':
      default:
        console.log(chalk.cyan('Turso Sync Utility\n'));
        console.log('Usage: bin/turso-sync [command] [options]');
        console.log('\nCommands:');
        console.log('  status    - Show sync status and compare databases');
        console.log('  sync      - Bidirectional sync (pull + push, newest wins)');
        console.log('  pull      - Pull from Turso to local (incremental)');
        console.log('  push      - Push recent changes to Turso');
        console.log('  watch     - Auto-sync every 60 seconds');
        console.log('  help      - Show this help');
        console.log('\nOptions:');
        console.log('  pull --full  - Full pull of ALL data (batched for large tables)');
        console.log('               - Use for initial setup or recovery from 502 errors');
        console.log('\nNote:');
        console.log('  This utility uses DatabaseService for all operations.');
        console.log('  The sync is incremental and handles all tables automatically.');
        console.log('  Timestamps are used to determine what needs syncing.');
        break;
    }
    
    // Close connections
    await sync.close();
    
    // Exit cleanly (except for watch)
    if (command !== 'watch') {
      // Force exit after a short delay because Turso client keeps event loop alive
      setTimeout(() => {
        process.exit(0);
      }, 100);
    }
  } catch (error) {
    console.error(chalk.red('Error:'), error.message);
    if (process.env.DEBUG) {
      console.error(error.stack);
    }
    await sync.close();
    setTimeout(() => {
      process.exit(1);
    }, 100);
  }
}

main();