#!/usr/bin/env node

// Sync sent emails from Pobox account
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import { ImapFlow } from 'imapflow';
import chalk from 'chalk';
import { SQLiteCache } from '../src/sqlite-cache.js';
import { simpleParser } from 'mailparser';

async function syncPoboxSent() {
  if (!process.env.POBOX_ACCOUNT || !process.env.POBOX_PASSWORD) {
    console.error(chalk.red('âŒ Pobox credentials not found'));
    console.log(chalk.yellow('Add to your .env file:'));
    console.log(chalk.green('POBOX_ACCOUNT=jeff.covey@pobox.com'));
    console.log(chalk.green('POBOX_PASSWORD=your-password'));
    process.exit(1);
  }

  const cache = new SQLiteCache();
  
  // Initialize email table if needed
  cache.db.exec(`
    CREATE TABLE IF NOT EXISTS emails (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      uid INTEGER,
      message_id TEXT,
      from_address TEXT,
      to_address TEXT,
      subject TEXT,
      date DATETIME,
      headers TEXT,
      text_content TEXT,
      html_content TEXT,
      attachments TEXT,
      flags TEXT,
      size INTEGER,
      raw_source TEXT,
      folder TEXT DEFAULT 'INBOX',
      downloaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(uid, folder)
    );
    CREATE INDEX IF NOT EXISTS idx_emails_date ON emails(date);
    CREATE INDEX IF NOT EXISTS idx_emails_from ON emails(from_address);
    CREATE INDEX IF NOT EXISTS idx_emails_to ON emails(to_address);
    CREATE INDEX IF NOT EXISTS idx_emails_folder ON emails(folder);
  `);

  const client = new ImapFlow({
    host: 'mail.pobox.com',
    port: 993,
    secure: true,
    auth: {
      user: process.env.POBOX_ACCOUNT,
      pass: process.env.POBOX_PASSWORD
    },
    logger: false
  });

  try {
    console.log(chalk.blue(`ðŸ”Œ Connecting to Pobox for ${process.env.POBOX_ACCOUNT}...`));
    await client.connect();
    console.log(chalk.green('âœ… Connected successfully'));

    // List all folders to find Sent folder
    const folders = await client.list();
    const sentFolder = folders.find(f => 
      f.path.toLowerCase().includes('sent') || 
      f.specialUse === '\\Sent'
    );

    if (!sentFolder) {
      console.error(chalk.red('âŒ Could not find Sent folder'));
      await client.logout();
      return;
    }

    console.log(chalk.blue(`ðŸ“‚ Found Sent folder: ${sentFolder.path}`));
    
    const lock = await client.getMailboxLock(sentFolder.path);
    
    try {
      // Calculate date range (last 30 days by default)
      const days = parseInt(process.argv[2]) || 30;
      const sinceDate = new Date();
      sinceDate.setDate(sinceDate.getDate() - days);
      
      console.log(chalk.blue(`ðŸ“§ Fetching sent emails from last ${days} days...`));
      
      let downloaded = 0;
      let skipped = 0;
      
      for await (const message of client.fetch(
        { since: sinceDate },
        { envelope: true, source: true, flags: true }
      )) {
        // Check if already downloaded
        const existing = cache.db.prepare(
          'SELECT id FROM emails WHERE uid = ? AND folder = ?'
        ).get(message.uid, 'Sent');
        
        if (existing) {
          skipped++;
          continue;
        }

        if (message.source) {
          const parsed = await simpleParser(message.source);
          
          // Store in database
          cache.db.prepare(`
            INSERT OR REPLACE INTO emails (
              uid, message_id, from_address, to_address, subject, date,
              headers, text_content, html_content, attachments, flags,
              size, raw_source, folder
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).run(
            message.uid,
            parsed.messageId || `uid-${message.uid}-sent`,
            parsed.from?.text || '',
            parsed.to?.text || '',
            parsed.subject || '(no subject)',
            parsed.date || new Date(),
            JSON.stringify(parsed.headerLines?.map(h => [h.key, h.line]) || []),
            parsed.text || '',
            parsed.html || '',
            JSON.stringify(parsed.attachments?.map(a => ({
              filename: a.filename,
              contentType: a.contentType,
              size: a.size
            })) || []),
            JSON.stringify(message.flags || []),
            message.source.length,
            null, // Don't store raw source to save space
            'Sent'
          );
          
          downloaded++;
          
          if (downloaded % 10 === 0) {
            console.log(chalk.gray(`  Downloaded ${downloaded} emails...`));
          }
        }
      }
      
      console.log(chalk.green(`âœ… Downloaded ${downloaded} new sent emails`));
      if (skipped > 0) {
        console.log(chalk.gray(`   (Skipped ${skipped} already downloaded)`));
      }
      
      // Show stats
      const stats = cache.db.prepare(`
        SELECT COUNT(*) as count FROM emails WHERE folder = 'Sent'
      `).get();
      
      console.log(chalk.blue(`ðŸ“Š Total sent emails in database: ${stats.count}`));
      
    } finally {
      lock.release();
    }
    
    await client.logout();
    console.log(chalk.green('âœ… Disconnected from Pobox'));
    
  } catch (error) {
    console.error(chalk.red('âŒ Error:'), error.message);
    if (error.message.includes('Authentication')) {
      console.log(chalk.yellow('\nMake sure your Pobox credentials are correct.'));
      console.log(chalk.yellow('You may need to use an app-specific password.'));
    }
    process.exit(1);
  }
}

// Run the sync
syncPoboxSent().catch(error => {
  console.error(chalk.red('Fatal error:'), error);
  process.exit(1);
});