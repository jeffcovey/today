#!/usr/bin/env node

/**
 * OlderGay.Men Data Sync Script
 * Fetches monitoring data from GitHub, Sentry, and Scout APM
 * and stores it in the local SQLite database for bin/today to use
 */

import Database from 'better-sqlite3';
import chalk from 'chalk';
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const DB_PATH = path.join(__dirname, '../.data/today.db');

// Utility functions for colored output
const print = {
  status: (msg) => console.log(chalk.green(`‚úì ${msg}`)),
  error: (msg) => console.error(chalk.red(`‚úó ${msg}`)),
  info: (msg) => console.log(chalk.blue(`‚Ñπ ${msg}`)),
  warning: (msg) => console.log(chalk.yellow(`‚ö† ${msg}`)),
  header: (msg) => {
    console.log('');
    console.log(chalk.yellow('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'));
    console.log(chalk.yellow.bold(msg));
    console.log(chalk.yellow('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'));
  }
};

// Initialize database tables
function initDatabase(db) {
  print.info('Initializing OGM monitoring tables...');

  db.exec(`
    -- GitHub Issues table
    CREATE TABLE IF NOT EXISTS ogm_github_issues (
      number INTEGER PRIMARY KEY,
      title TEXT NOT NULL,
      state TEXT NOT NULL,
      created_at DATETIME NOT NULL,
      updated_at DATETIME NOT NULL,
      closed_at DATETIME,
      body TEXT,
      labels TEXT,
      comments_count INTEGER DEFAULT 0,
      url TEXT,
      synced_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    -- Sentry Issues table
    CREATE TABLE IF NOT EXISTS ogm_sentry_issues (
      id TEXT PRIMARY KEY,
      title TEXT NOT NULL,
      culprit TEXT,
      level TEXT,
      status TEXT,
      count INTEGER DEFAULT 0,
      user_count INTEGER DEFAULT 0,
      first_seen DATETIME NOT NULL,
      last_seen DATETIME,
      synced_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    -- Scout Performance Metrics table
    CREATE TABLE IF NOT EXISTS ogm_scout_metrics (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      metric_type TEXT NOT NULL,
      timestamp DATETIME NOT NULL,
      value REAL NOT NULL,
      percentile_95 REAL,
      throughput REAL,
      error_rate REAL,
      synced_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    -- Correlations table (linking issues to errors)
    CREATE TABLE IF NOT EXISTS ogm_correlations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      github_issue INTEGER,
      sentry_issue TEXT,
      correlation_type TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (github_issue) REFERENCES ogm_github_issues(number),
      FOREIGN KEY (sentry_issue) REFERENCES ogm_sentry_issues(id)
    );

    -- Summary statistics table
    CREATE TABLE IF NOT EXISTS ogm_summary_stats (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      stat_date DATE NOT NULL,
      open_issues INTEGER DEFAULT 0,
      closed_issues_today INTEGER DEFAULT 0,
      active_errors INTEGER DEFAULT 0,
      avg_response_time REAL,
      p95_response_time REAL,
      error_rate REAL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(stat_date)
    );

    -- Create indexes for better query performance
    CREATE INDEX IF NOT EXISTS idx_issues_state ON ogm_github_issues(state);
    CREATE INDEX IF NOT EXISTS idx_issues_updated ON ogm_github_issues(updated_at);
    CREATE INDEX IF NOT EXISTS idx_sentry_status ON ogm_sentry_issues(status);
    CREATE INDEX IF NOT EXISTS idx_sentry_last_seen ON ogm_sentry_issues(last_seen);
    CREATE INDEX IF NOT EXISTS idx_metrics_type ON ogm_scout_metrics(metric_type, timestamp);
    CREATE INDEX IF NOT EXISTS idx_summary_date ON ogm_summary_stats(stat_date);
    CREATE UNIQUE INDEX IF NOT EXISTS idx_github_issue_number ON ogm_github_issues(number);
  `);

  print.status('Database tables initialized');
}

// Sync GitHub issues
async function syncGitHubIssues(db) {
  print.header('üìä Syncing GitHub Issues');

  const token = process.env.GITHUB_ACCESS_TOKEN || process.env.GITHUB_TOKEN;
  if (!token) {
    print.error('GITHUB_ACCESS_TOKEN or GITHUB_TOKEN not configured');
    print.info('Create a token at: https://github.com/settings/tokens');
    return false;
  }

  try {
    print.info('Fetching open issues from GitHub...');

    const response = await fetch(
      'https://api.github.com/repos/OlderGay-Men/OlderGay.Men/issues?state=open&per_page=100',
      {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`GitHub API returned ${response.status}: ${response.statusText}`);
    }

    const issues = await response.json();

    if (issues.message) {
      print.error(`GitHub API error: ${issues.message}`);
      return false;
    }

    print.info(`Received ${issues.length} issues from GitHub`);

    // Prepare upsert statement with parameterized queries
    const upsert = db.prepare(`
      INSERT INTO ogm_github_issues
      (number, title, state, created_at, updated_at, closed_at, body, labels, comments_count, url, synced_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(number) DO UPDATE SET
        title = excluded.title,
        state = excluded.state,
        updated_at = excluded.updated_at,
        closed_at = excluded.closed_at,
        body = excluded.body,
        labels = excluded.labels,
        comments_count = excluded.comments_count,
        url = excluded.url,
        synced_at = CURRENT_TIMESTAMP
    `);

    let issueCount = 0;
    for (const issue of issues) {
      // Skip pull requests
      if (issue.pull_request) continue;

      try {
        const labels = issue.labels?.map(l => l.name).join(',') || '';

        upsert.run(
          issue.number,
          issue.title || 'Untitled',
          issue.state || 'open',
          issue.created_at,
          issue.updated_at,
          issue.closed_at || null,
          issue.body || '',
          labels,
          issue.comments || 0,
          issue.html_url || ''
        );
        issueCount++;
      } catch (error) {
        print.error(`Failed to insert issue #${issue.number}: ${error.message}`);
      }
    }

    print.status(`Synced ${issueCount} GitHub issues`);

    // Get total count
    const totalCount = db.prepare("SELECT COUNT(*) as count FROM ogm_github_issues WHERE state='open'").get();
    print.info(`Total open issues in database: ${totalCount.count}`);

    return true;
  } catch (error) {
    print.error(`GitHub sync failed: ${error.message}`);
    return false;
  }
}

// Sync Sentry issues
async function syncSentryIssues(db) {
  print.header('üîç Syncing Sentry Issues');

  const token = process.env.SENTRY_AUTH_TOKEN || process.env.SENTRY_API_KEY;
  if (!token) {
    print.error('SENTRY_AUTH_TOKEN not configured');
    print.info('Get your token at: https://sentry.io/settings/account/api/auth-tokens/');
    return false;
  }

  const org = process.env.SENTRY_ORG || 'oldergaymen';
  const project = process.env.SENTRY_PROJECT || 'rails';

  try {
    print.info('Fetching unresolved issues from Sentry...');

    const response = await fetch(
      `https://sentry.io/api/0/projects/${org}/${project}/issues/?query=is:unresolved&limit=100`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Sentry API returned ${response.status}: ${response.statusText}`);
    }

    const issues = await response.json();

    if (issues.error) {
      print.error(`Sentry API error: ${issues.error}`);
      return false;
    }

    print.info(`Received ${issues.length} issues from Sentry`);

    // Prepare upsert statement
    const upsert = db.prepare(`
      INSERT INTO ogm_sentry_issues
      (id, title, culprit, level, status, count, user_count, first_seen, last_seen, synced_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        title = excluded.title,
        culprit = excluded.culprit,
        level = excluded.level,
        status = excluded.status,
        count = excluded.count,
        user_count = excluded.user_count,
        last_seen = excluded.last_seen,
        synced_at = CURRENT_TIMESTAMP
    `);

    let issueCount = 0;
    for (const issue of issues) {
      try {
        upsert.run(
          issue.id,
          issue.title || 'Unknown',
          issue.culprit || '',
          issue.level || 'error',
          issue.status || 'unresolved',
          issue.count || 0,
          issue.userCount || 0,
          issue.firstSeen,
          issue.lastSeen || issue.firstSeen
        );
        issueCount++;
      } catch (error) {
        print.error(`Failed to insert Sentry issue ${issue.id}: ${error.message}`);
      }
    }

    print.status(`Synced ${issueCount} Sentry issues`);

    // Get total count
    const totalCount = db.prepare("SELECT COUNT(*) as count FROM ogm_sentry_issues WHERE status='unresolved'").get();
    print.info(`Total unresolved issues in database: ${totalCount.count}`);

    return true;
  } catch (error) {
    print.error(`Sentry sync failed: ${error.message}`);
    return false;
  }
}

// Sync Scout metrics (stubbed - would need actual API implementation)
async function syncScoutMetrics(db) {
  print.header('üîç Syncing Scout Performance Metrics');
  print.info('Scout metrics sync not yet implemented');
  return true;
}

// Generate summary statistics
function generateSummary(db) {
  print.header('üìà Generating Summary Statistics');

  const today = new Date().toISOString().split('T')[0];

  // Calculate metrics
  const openIssues = db.prepare("SELECT COUNT(*) as count FROM ogm_github_issues WHERE state='open'").get();
  const closedToday = db.prepare("SELECT COUNT(*) as count FROM ogm_github_issues WHERE state='closed' AND DATE(closed_at)=?").get(today);
  const activeErrors = db.prepare("SELECT COUNT(*) as count FROM ogm_sentry_issues WHERE status='unresolved'").get();

  console.log('');
  console.log(`Summary for ${today}:`);
  console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  console.log(`GitHub Issues:     ${openIssues.count} open`);
  console.log(`Closed Today:      ${closedToday.count}`);
  console.log(`Sentry Errors:     ${activeErrors.count} active`);
  console.log('');

  print.status('Summary statistics generated');
}

// Main function
async function main() {
  print.header('üåê OlderGay.Men Monitoring Data Sync');
  console.log('Syncing monitoring data for bin/today planning...');

  const db = new Database(DB_PATH);

  try {
    // Initialize database
    initDatabase(db);

    // Sync each data source
    await syncGitHubIssues(db);
    await syncSentryIssues(db);
    await syncScoutMetrics(db);

    // Generate summary
    generateSummary(db);

    print.header('‚úÖ OGM Data Sync Complete');

    print.info('Data now available for bin/today planning:');
    console.log('  ‚Ä¢ GitHub open issues and recent activity');
    console.log('  ‚Ä¢ Sentry unresolved errors and patterns');
    console.log('  ‚Ä¢ Scout performance metrics and slow endpoints');
    console.log('  ‚Ä¢ Summary statistics and trends');
    console.log('');
    console.log("Run 'bin/today' to get AI recommendations based on this data");

  } catch (error) {
    print.error(`Sync failed: ${error.message}`);
    console.error(error.stack);
    process.exit(1);
  } finally {
    db.close();
  }
}

// Handle command line arguments
const command = process.argv[2];

switch (command) {
  case 'issues': {
    const db = new Database(DB_PATH);
    try {
      initDatabase(db);
      await syncGitHubIssues(db);
    } finally {
      db.close();
    }
    break;
  }
  case 'errors': {
    const db = new Database(DB_PATH);
    try {
      initDatabase(db);
      await syncSentryIssues(db);
    } finally {
      db.close();
    }
    break;
  }
  case 'performance': {
    const db = new Database(DB_PATH);
    try {
      initDatabase(db);
      await syncScoutMetrics(db);
    } finally {
      db.close();
    }
    break;
  }
  case 'summary': {
    const db = new Database(DB_PATH);
    try {
      generateSummary(db);
    } finally {
      db.close();
    }
    break;
  }
  default:
    await main();
}
