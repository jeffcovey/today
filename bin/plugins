#!/usr/bin/env node

// Plugin management CLI
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import chalk from 'chalk';
import fs from 'fs';
import os from 'os';
import { execSync } from 'child_process';
import inquirer from 'inquirer';
import {
  discoverPlugins,
  getPluginSources,
  getEnabledPlugins,
  syncPluginSource
} from '../src/plugin-loader.js';
import { parse as parseToml, stringify as stringifyToml } from 'smol-toml';
import { getDatabase } from '../src/database-service.js';
import { ensureHealthyDatabase } from '../src/db-health.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.dirname(__dirname);
const CONFIG_PATH = path.join(PROJECT_ROOT, 'config.toml');
const CONFIG_EXAMPLE_PATH = path.join(PROJECT_ROOT, 'config.toml.example');

/**
 * Ensure config.toml has entries for all available plugins.
 * Adds commented-out defaults for new plugins, removes entries for deleted plugins.
 */
async function ensurePluginConfig() {
  const plugins = await discoverPlugins();

  if (plugins.size === 0) return;

  // Read current config
  let configContent = '';
  try {
    configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
  } catch {
    return; // No config file yet
  }

  // Build the plugin config section
  const pluginConfigs = [];
  for (const [name, plugin] of plugins) {
    const sectionHeader = `[plugins.${name}.`;

    // Check if this plugin already has any configuration
    if (configContent.includes(sectionHeader) || configContent.includes(`# ${sectionHeader}`)) {
      continue; // Already configured (enabled or commented)
    }

    // Generate commented-out default config
    const lines = [];
    lines.push(`# [plugins.${name}.default]`);
    lines.push(`# enabled = true`);

    if (plugin.settings) {
      for (const [key, schema] of Object.entries(plugin.settings)) {
        const defaultValue = schema.default;
        if (defaultValue !== undefined) {
          const valueStr = typeof defaultValue === 'string' ? `"${defaultValue}"` : defaultValue;
          lines.push(`# ${key} = ${valueStr}`);
        }
      }
    }

    pluginConfigs.push(lines.join('\n'));
  }

  // Update config.toml if there are new plugins
  if (pluginConfigs.length > 0) {
    // Find where to insert - after existing plugins section or at the end
    const pluginsHeaderMatch = configContent.match(/^# =+\n# Plugins\n# =+/m);

    if (pluginsHeaderMatch) {
      // Find the end of the plugins section (next header or EOF)
      const afterHeader = configContent.indexOf(pluginsHeaderMatch[0]) + pluginsHeaderMatch[0].length;
      const nextHeaderMatch = configContent.slice(afterHeader).match(/\n# =+\n#[^=]/);
      const insertPoint = nextHeaderMatch
        ? afterHeader + nextHeaderMatch.index
        : configContent.length;

      // Insert new plugin configs before the next section
      const before = configContent.slice(0, insertPoint).trimEnd();
      const after = configContent.slice(insertPoint);

      configContent = before + '\n\n' + pluginConfigs.join('\n\n') + after;
    } else {
      // No plugins section yet, append at the end
      configContent = configContent.trimEnd() + '\n\n' +
        '# =============================================================================\n' +
        '# Plugins\n' +
        '# =============================================================================\n' +
        '# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]\n' +
        '# Uncomment and set enabled = true to activate a plugin\n\n' +
        pluginConfigs.join('\n\n') + '\n';
    }

    fs.writeFileSync(CONFIG_PATH, configContent);
  }

  // Also update config.toml.example if it exists
  try {
    let exampleContent = fs.readFileSync(CONFIG_EXAMPLE_PATH, 'utf8');
    let exampleModified = false;

    for (const [name, plugin] of plugins) {
      const sectionHeader = `[plugins.${name}.`;
      if (exampleContent.includes(sectionHeader) || exampleContent.includes(`# ${sectionHeader}`)) {
        continue;
      }

      // Add plugins section header if needed
      if (!exampleContent.includes('# Plugins')) {
        exampleContent = exampleContent.trimEnd() + '\n\n' +
          '# =============================================================================\n' +
          '# Plugins\n' +
          '# =============================================================================\n' +
          '# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]\n' +
          '# Uncomment and set enabled = true to activate a plugin\n';
      }

      const lines = [];
      lines.push(`# [plugins.${name}.default]`);
      lines.push(`# enabled = true`);

      if (plugin.settings) {
        for (const [key, schema] of Object.entries(plugin.settings)) {
          const defaultValue = schema.default;
          if (defaultValue !== undefined) {
            const valueStr = typeof defaultValue === 'string' ? `"${defaultValue}"` : defaultValue;
            lines.push(`# ${key} = ${valueStr}`);
          }
        }
      }

      exampleContent = exampleContent.trimEnd() + '\n\n' + lines.join('\n') + '\n';
      exampleModified = true;
    }

    if (exampleModified) {
      fs.writeFileSync(CONFIG_EXAMPLE_PATH, exampleContent);
    }
  } catch {
    // Example file doesn't exist, that's fine
  }
}

async function cmdList() {
  const plugins = await discoverPlugins();

  console.log(chalk.cyan('Available Plugins:'));
  console.log('');

  for (const [name, plugin] of plugins) {
    const sources = getPluginSources(name);
    const status = sources.length > 0
      ? chalk.green(`${sources.length} source(s) enabled`)
      : chalk.gray('not configured');

    console.log(`  ${chalk.bold(plugin.displayName || name)} ${chalk.gray(`(${name})`)}`);
    console.log(`    Type: ${plugin.type} | Access: ${plugin.access}`);
    console.log(`    ${plugin.description}`);
    console.log(`    Status: ${status}`);

    if (sources.length > 0) {
      for (const { sourceName } of sources) {
        console.log(`      - ${sourceName}`);
      }
    }
    console.log('');
  }
}

async function cmdStatus() {
  const enabledPlugins = await getEnabledPlugins();

  if (enabledPlugins.length === 0) {
    console.log(chalk.yellow('No plugins are currently enabled.'));
    console.log('');
    console.log('Configure plugins in config.toml:');
    console.log('');
    console.log('  [plugins.time-tracking.local]');
    console.log('  enabled = true');
    return;
  }

  console.log(chalk.cyan('Enabled Plugins:'));
  console.log('');

  for (const { plugin, sources } of enabledPlugins) {
    console.log(`  ${chalk.bold(plugin.displayName || plugin.name)}`);

    for (const { sourceName, config } of sources) {
      const tableName = `${plugin.name.replace(/-/g, '_')}_${sourceName.replace(/-/g, '_')}`;
      console.log(`    ${chalk.green('●')} ${sourceName} → ${tableName}`);
    }
    console.log('');
  }
}

async function cmdSync(pluginName, sourceName, options = {}) {
  // Ensure database is healthy and migrations are run
  const healthResult = await ensureHealthyDatabase({ verbose: false });
  if (!healthResult.success) {
    console.error(chalk.red('Database health check failed'));
    process.exit(1);
  }

  const db = getDatabase();
  const vaultPath = path.join(PROJECT_ROOT, 'vault');

  const context = { db, vaultPath };

  // Get type filter from options
  const typeFilter = options.type || options.t;

  if (pluginName) {
    // Sync specific plugin
    const plugins = await discoverPlugins();
    const plugin = plugins.get(pluginName);

    if (!plugin) {
      console.error(chalk.red(`Plugin not found: ${pluginName}`));
      process.exit(1);
    }

    // Check if plugin has a read command
    if (!plugin.commands?.read) {
      console.log(chalk.yellow(`Plugin ${pluginName} does not have a read command.`));
      console.log(chalk.gray('This plugin provides read-only access to external data.'));
      return;
    }

    const sources = getPluginSources(pluginName);

    if (sources.length === 0) {
      console.error(chalk.red(`Plugin ${pluginName} has no enabled sources.`));
      process.exit(1);
    }

    // Filter to specific source if provided
    const toSync = sourceName
      ? sources.filter(s => s.sourceName === sourceName)
      : sources;

    if (sourceName && toSync.length === 0) {
      console.error(chalk.red(`Source not found: ${sourceName}`));
      process.exit(1);
    }

    for (const { sourceName: src, config } of toSync) {
      console.log(`Syncing ${pluginName}/${src}...`);
      const result = await syncPluginSource(plugin, src, config, context);

      if (result.success) {
        console.log(chalk.green(`  ✓ ${result.message}`));
      } else {
        console.log(chalk.red(`  ✗ ${result.message}`));
      }
    }
  } else {
    // Sync all enabled plugins (optionally filtered by type)
    const enabledPlugins = await getEnabledPlugins();

    // Filter to plugins that have read commands
    let syncablePlugins = enabledPlugins.filter(({ plugin }) => plugin.commands?.read);

    // Apply type filter if specified
    if (typeFilter) {
      syncablePlugins = syncablePlugins.filter(({ plugin }) => plugin.type === typeFilter);

      if (syncablePlugins.length === 0) {
        console.log(chalk.yellow(`No plugins of type '${typeFilter}' to sync.`));
        return;
      }
    }

    if (syncablePlugins.length === 0) {
      console.log(chalk.yellow('No plugins to sync.'));
      return;
    }

    const typeMsg = typeFilter ? ` (type: ${typeFilter})` : '';
    console.log(chalk.cyan(`Syncing plugins${typeMsg}...`));
    console.log('');

    for (const { plugin, sources } of syncablePlugins) {
      for (const { sourceName: src, config } of sources) {
        console.log(`  ${plugin.name}/${src}...`);
        const result = await syncPluginSource(plugin, src, config, context);

        if (result.success) {
          console.log(chalk.green(`    ✓ ${result.message}`));
        } else {
          console.log(chalk.red(`    ✗ ${result.message}`));
        }
      }
    }
  }
}

/**
 * Get the user's preferred editor
 */
function getEditor() {
  return process.env.EDITOR || process.env.VISUAL || 'nano';
}

/**
 * Edit text in an external editor
 * @param {string} currentText - Current text content
 * @param {string} filename - Suggested filename for the temp file
 * @returns {string|null} - Edited text, or null if cancelled/unchanged
 */
function editInEditor(currentText, filename = 'edit.txt') {
  const editor = getEditor();
  const tmpDir = os.tmpdir();
  const tmpFile = path.join(tmpDir, `plugins-${Date.now()}-${filename}`);

  try {
    // Write current content to temp file
    fs.writeFileSync(tmpFile, currentText || '');

    // Open editor (blocking)
    console.log(chalk.gray(`Opening ${editor}... (save and close to continue)`));
    execSync(`${editor} "${tmpFile}"`, { stdio: 'inherit' });

    // Read back the result
    const newText = fs.readFileSync(tmpFile, 'utf8');

    // Clean up
    fs.unlinkSync(tmpFile);

    return newText;
  } catch (error) {
    // Clean up on error
    try { fs.unlinkSync(tmpFile); } catch {}
    console.error(chalk.red(`Editor failed: ${error.message}`));
    return null;
  }
}

async function cmdConfigure(pluginNameArg) {
  const plugins = await discoverPlugins();

  if (plugins.size === 0) {
    console.log(chalk.yellow('No plugins available.'));
    return;
  }

  // Main loop - returns to plugin selection after configuring
  while (true) {
    let pluginName = pluginNameArg;

    // If no plugin specified, let user choose
    if (!pluginName) {
      const pluginChoices = Array.from(plugins.values()).map((p, i) => ({
        name: `${p.displayName || p.name} - ${p.description}`,
        value: p.name
      }));
      pluginChoices.push({ name: 'Exit', value: '__exit__' });

      const { selectedPlugin } = await inquirer.prompt([{
        type: 'rawlist',
        name: 'selectedPlugin',
        message: 'Select a plugin to configure:',
        choices: pluginChoices
      }]);

      if (!selectedPlugin || selectedPlugin === '__exit__') {
        return;
      }
      pluginName = selectedPlugin;
    }

    const plugin = plugins.get(pluginName);
    if (!plugin) {
      console.error(chalk.red(`Plugin not found: ${pluginName}`));
      process.exit(1);
    }

    // Configure the selected plugin
    const shouldExit = await configurePlugin(plugin, pluginName);

    // If a specific plugin was passed as argument, exit after configuring it
    if (pluginNameArg || shouldExit) {
      return;
    }
  }
}

async function configurePlugin(plugin, pluginName) {
  // Inner configuration loop for a single plugin
  while (true) {
    console.log('');
    console.log(chalk.cyan(`Configuring ${plugin.displayName || plugin.name}`));
    console.log(chalk.gray(plugin.description));
    if (plugin.longDescription) {
      console.log('');
      console.log(plugin.longDescription.trim());
    }

    // Refresh configured sources each iteration
    let allConfiguredSources = [];
    try {
      const configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
      const parsedConfig = parseToml(configContent);
      if (parsedConfig.plugins?.[pluginName]) {
        allConfiguredSources = Object.entries(parsedConfig.plugins[pluginName]).map(([name, cfg]) => ({
          sourceName: name,
          config: cfg
        }));
      }
    } catch {
      // No config yet
    }

    // Show current sources
    if (allConfiguredSources.length > 0) {
      console.log('');
      console.log('Current sources:');
      for (const s of allConfiguredSources) {
        const status = s.config.enabled === true ? chalk.green('enabled') : chalk.gray('disabled');
        console.log(`  ${s.sourceName} (${status})`);
      }
    }
    console.log('');

    // Ask what action to take
    const actionChoices = [
      { name: 'Add new source', value: 'add' }
    ];

    if (allConfiguredSources.length > 0) {
      actionChoices.push(
        { name: 'Edit source', value: 'edit' },
        { name: 'Remove source', value: 'remove' }
      );
    }

    actionChoices.push({ name: 'Back', value: '__back__' });

    const { action } = await inquirer.prompt([{
      type: 'rawlist',
      name: 'action',
      message: 'What would you like to do?',
      choices: actionChoices
    }]);

    if (!action || action === '__back__') {
      return false; // Return to plugin selection
    }

    // Read current config
    let config = {};
    try {
      const configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
      config = parseToml(configContent);
    } catch {
      // Config doesn't exist yet, that's fine
    }

    // Initialize plugins section if needed
    if (!config.plugins) {
      config.plugins = {};
    }
    if (!config.plugins[pluginName]) {
      config.plugins[pluginName] = {};
    }

    // Get existing source names for validation
    const existingSourceNames = allConfiguredSources.map(s => s.sourceName);

    if (action === 'add') {
      // Get source name
      const { sourceName } = await inquirer.prompt([{
        type: 'input',
        name: 'sourceName',
        message: 'Source name (e.g., "local", "work", "personal"):',
        default: 'default',
        validate: (input) => {
          if (!input.match(/^[a-z0-9_-]+$/)) {
            return 'Source name must be lowercase alphanumeric with dashes or underscores';
          }
          if (existingSourceNames.includes(input)) {
            return `Source "${input}" already exists. Choose a different name.`;
          }
          return true;
        }
      }]);

      // Get configuration values from settings
      const sourceConfig = { enabled: true };

      if (plugin.settings) {
        console.log('');
        console.log(chalk.cyan('Configure plugin options:'));

        for (const [key, schema] of Object.entries(plugin.settings)) {
          const promptConfig = {
            name: key,
            message: `${key}:`,
            default: schema.default
          };

          if (schema.type === 'number') {
            promptConfig.type = 'number';
          } else if (schema.type === 'boolean') {
            promptConfig.type = 'confirm';
          } else {
            promptConfig.type = 'input';
          }

          const answer = await inquirer.prompt([promptConfig]);
          sourceConfig[key] = answer[key];
        }
      }

      // Save to config
      config.plugins[pluginName][sourceName] = sourceConfig;
      writeConfig(config);

      console.log('');
      console.log(chalk.green('✓') + ` Added source "${sourceName}"`);

    } else if (action === 'edit') {
      // Choose source to edit (skip prompt if only one)
      let sourceToEdit;
      if (allConfiguredSources.length === 1) {
        sourceToEdit = allConfiguredSources[0].sourceName;
      } else {
        const { selected } = await inquirer.prompt([{
          type: 'rawlist',
          name: 'selected',
          message: 'Select source to edit:',
          choices: allConfiguredSources.map(s => ({
            name: `${s.sourceName} ${s.config.enabled === true ? chalk.green('(enabled)') : chalk.gray('(disabled)')}`,
            value: s.sourceName
          }))
        }]);
        sourceToEdit = selected;
      }

      if (sourceToEdit) {
        const currentConfig = config.plugins[pluginName][sourceToEdit] || {};

        // Edit enabled status
        const { enabled } = await inquirer.prompt([{
          type: 'confirm',
          name: 'enabled',
          message: 'Enable this source?',
          default: currentConfig.enabled === true
        }]);

        const sourceConfig = { enabled };

        // Edit other config values
        if (plugin.settings) {
          console.log('');
          console.log(chalk.cyan('Configure plugin options:'));

          for (const [key, schema] of Object.entries(plugin.settings)) {
            const currentValue = currentConfig[key] !== undefined ? currentConfig[key] : schema.default;

            const promptConfig = {
              name: key,
              message: `${key}:`,
              default: currentValue
            };

            if (schema.type === 'number') {
              promptConfig.type = 'number';
            } else if (schema.type === 'boolean') {
              promptConfig.type = 'confirm';
            } else {
              promptConfig.type = 'input';
            }

            const answer = await inquirer.prompt([promptConfig]);
            sourceConfig[key] = answer[key];
          }
        }

        // Ask about AI instructions
        const currentInstructions = currentConfig.ai_instructions || '';
        const hasInstructions = currentInstructions.length > 0;

        console.log('');
        const { editAiInstructions } = await inquirer.prompt([{
          type: 'confirm',
          name: 'editAiInstructions',
          message: hasInstructions ? 'Edit AI instructions?' : 'Add AI instructions? (tells AI how to use this data)',
          default: false
        }]);

        if (editAiInstructions) {
          const newInstructions = editInEditor(currentInstructions, 'ai-instructions.txt');
          if (newInstructions !== null) {
            const trimmed = newInstructions.trim();
            if (trimmed) {
              sourceConfig.ai_instructions = trimmed;
            }
            // If empty, just don't add it (effectively removes)
          }
        } else if (hasInstructions) {
          // Preserve existing instructions if not editing
          sourceConfig.ai_instructions = currentInstructions;
        }

        // Save to config
        config.plugins[pluginName][sourceToEdit] = sourceConfig;
        writeConfig(config);

        console.log('');
        console.log(chalk.green('✓') + ` Updated source "${sourceToEdit}"`);
      }

    } else if (action === 'remove') {
      // Choose source to remove (skip prompt if only one)
      let sourceToRemove;
      if (allConfiguredSources.length === 1) {
        sourceToRemove = allConfiguredSources[0].sourceName;
      } else {
        const { selected } = await inquirer.prompt([{
          type: 'rawlist',
          name: 'selected',
          message: 'Select source to remove:',
          choices: allConfiguredSources.map(s => s.sourceName)
        }]);
        sourceToRemove = selected;
      }

      if (sourceToRemove) {
        const { confirmRemove } = await inquirer.prompt([{
          type: 'confirm',
          name: 'confirmRemove',
          message: chalk.red(`Are you sure you want to remove "${sourceToRemove}"?`),
          default: false
        }]);

        if (confirmRemove) {
          delete config.plugins[pluginName][sourceToRemove];

          // Clean up empty plugin section
          if (Object.keys(config.plugins[pluginName]).length === 0) {
            delete config.plugins[pluginName];
          }

          writeConfig(config);

          console.log('');
          console.log(chalk.green('✓') + ` Removed source "${sourceToRemove}"`);
        } else {
          console.log(chalk.gray('Cancelled.'));
        }
      }
    }
  }
}

/**
 * Convert smol-toml output to use multi-line strings for ai_instructions
 * smol-toml uses \n escapes, but triple-quoted strings are more readable
 */
function formatMultilineStrings(tomlStr) {
  // Match ai_instructions = "..." and convert to triple-quoted if it contains \n
  return tomlStr.replace(
    /^(ai_instructions\s*=\s*)"((?:[^"\\]|\\.)*)"/gm,
    (match, prefix, content) => {
      // Check if it has escaped newlines
      if (!content.includes('\\n')) {
        return match; // Keep as-is if single line
      }
      // Unescape the content and use triple quotes
      const unescaped = content
        .replace(/\\n/g, '\n')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\');
      return `${prefix}"""\n${unescaped}\n"""`;
    }
  );
}

/**
 * Write config object to config.toml, preserving comments where possible
 */
function writeConfig(config) {
  // Read existing file to preserve structure/comments
  let existingContent = '';
  try {
    existingContent = fs.readFileSync(CONFIG_PATH, 'utf8');
  } catch {
    // File doesn't exist
  }

  if (existingContent) {
    // Try to update just the plugins section
    let pluginsSection = stringifyToml({ plugins: config.plugins });
    pluginsSection = formatMultilineStrings(pluginsSection);

    // Check if plugins section exists
    const pluginsMatch = existingContent.match(/^# =+\n# Plugins\n# =+.*?(?=\n# =|\n*$)/ms);

    if (pluginsMatch) {
      // Replace plugins section
      const before = existingContent.slice(0, pluginsMatch.index);
      const newPluginsSection = `# =============================================================================
# Plugins
# =============================================================================
# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]
# Uncomment and set enabled = true to activate a plugin

${pluginsSection}`;

      existingContent = before.trimEnd() + '\n\n' + newPluginsSection;
      fs.writeFileSync(CONFIG_PATH, existingContent);
    } else {
      // No plugins section yet, append it
      const newPluginsSection = `
# =============================================================================
# Plugins
# =============================================================================
# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]
# Uncomment and set enabled = true to activate a plugin

${pluginsSection}`;

      fs.writeFileSync(CONFIG_PATH, existingContent.trimEnd() + '\n' + newPluginsSection);
    }
  } else {
    // Write new config file
    let tomlOutput = stringifyToml(config);
    tomlOutput = formatMultilineStrings(tomlOutput);
    const content = `# Configuration for Today system
# See config.toml.example for all available options

${tomlOutput}`;
    fs.writeFileSync(CONFIG_PATH, content);
  }
}

async function cmdInfo(pluginName) {
  const plugins = await discoverPlugins();

  if (!pluginName) {
    console.error(chalk.red('Usage: plugins info <plugin-name>'));
    console.log('');
    console.log('Available plugins:');
    for (const [name] of plugins) {
      console.log(`  ${name}`);
    }
    process.exit(1);
  }

  const plugin = plugins.get(pluginName);
  if (!plugin) {
    console.error(chalk.red(`Plugin not found: ${pluginName}`));
    process.exit(1);
  }

  console.log('');
  console.log(chalk.bold(plugin.displayName || plugin.name));
  console.log(chalk.gray('─'.repeat(60)));
  console.log('');
  console.log(`Type: ${plugin.type}`);
  console.log(`Access: ${plugin.access}`);

  if (plugin.commands?.read) {
    console.log(`Sync: ${chalk.green('yes')}`);
  } else {
    console.log(`Sync: ${chalk.gray('no (read-only, external data)')}`);
  }

  console.log('');

  if (plugin.longDescription) {
    console.log(plugin.longDescription.trim());
  } else {
    console.log(plugin.description);
  }

  // Show configured sources
  const sources = getPluginSources(pluginName);
  if (sources.length > 0) {
    console.log('');
    console.log(chalk.cyan('Configured sources:'));
    for (const { sourceName, config } of sources) {
      const status = config.enabled === true ? chalk.green('enabled') : chalk.gray('disabled');
      console.log(`  ${sourceName} (${status})`);
      if (config.ai_instructions) {
        console.log(chalk.gray('    AI instructions from config.toml:'));
        const lines = config.ai_instructions.trim().split('\n');
        for (const line of lines) {
          console.log(chalk.gray(`      ${line}`));
        }
      }
    }
  }

  console.log('');
}

function showHelp() {
  console.log(`
${chalk.bold('Plugin Management CLI')}

Usage: plugins <command> [options]

Commands:
  list                      Show all available plugins
  info <plugin>             Show detailed plugin documentation
  status                    Show enabled plugins and their sources
  configure [plugin]        Interactive plugin configuration
  sync [plugin] [source]    Sync plugin data (all if no plugin specified)
    --type <type>           Only sync plugins of a specific type (e.g., time-logs)

Examples:
  plugins list
  plugins info markdown-time-tracking
  plugins status
  plugins configure
  plugins configure markdown-time-tracking
  plugins sync
  plugins sync --type time-logs
  plugins sync markdown-time-tracking
  plugins sync markdown-time-tracking local

Configuration:
  Plugins are configured in config.toml:

  [plugins.markdown-time-tracking.local]
  enabled = true
  days_to_sync = 365
`);
}

// Parse arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const result = {
    command: null,
    positional: [],
    options: {}
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const key = arg.slice(2);
      // Check if next arg is the value (not another flag)
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        result.options[key] = args[i + 1];
        i++;
      } else {
        result.options[key] = true;
      }
    } else if (arg.startsWith('-') && arg.length === 2) {
      const key = arg.slice(1);
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        result.options[key] = args[i + 1];
        i++;
      } else {
        result.options[key] = true;
      }
    } else if (!result.command) {
      result.command = arg;
    } else {
      result.positional.push(arg);
    }
  }

  return result;
}

// Main
const { command, positional, options } = parseArgs();
const arg1 = positional[0];
const arg2 = positional[1];

// Ensure config.toml has entries for all plugins
await ensurePluginConfig();

try {
  switch (command) {
    case 'list':
      await cmdList();
      break;
    case 'info':
      await cmdInfo(arg1);
      break;
    case 'status':
      await cmdStatus();
      break;
    case 'configure':
      await cmdConfigure(arg1);
      break;
    case 'sync':
      await cmdSync(arg1, arg2, options);
      break;
    case '--help':
    case '-h':
    case undefined:
      showHelp();
      break;
    default:
      console.error(chalk.red(`Unknown command: ${command}`));
      showHelp();
      process.exit(1);
  }
} catch (error) {
  console.error(chalk.red('Error:'), error.message);
  process.exit(1);
}
