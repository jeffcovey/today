#!/usr/bin/env node

// Plugin management CLI
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs';
import os from 'os';
import { execSync } from 'child_process';
import * as p from '@clack/prompts';
import color from 'picocolors';
import { colors } from '../src/cli-utils.js';
import {
  discoverPlugins,
  getPluginSources,
  getEnabledPlugins,
  syncPluginSource,
  getSyncMetadata
} from '../src/plugin-loader.js';
import { parse as parseToml, stringify as stringifyToml } from 'smol-toml';
import { getDatabase } from '../src/database-service.js';
import { ensureHealthyDatabase } from '../src/db-health.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.dirname(__dirname);
const CONFIG_PATH = path.join(PROJECT_ROOT, 'config.toml');
const CONFIG_EXAMPLE_PATH = path.join(PROJECT_ROOT, 'config.toml.example');

/**
 * Ensure config.toml has entries for all available plugins.
 * Adds commented-out defaults for new plugins, removes entries for deleted plugins.
 */
async function ensurePluginConfig() {
  const plugins = await discoverPlugins();

  if (plugins.size === 0) return;

  // Read current config
  let configContent = '';
  try {
    configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
  } catch {
    return; // No config file yet
  }

  // Build the plugin config section
  const pluginConfigs = [];
  for (const [name, plugin] of plugins) {
    const sectionHeader = `[plugins.${name}.`;

    // Check if this plugin already has any configuration
    if (configContent.includes(sectionHeader) || configContent.includes(`# ${sectionHeader}`)) {
      continue; // Already configured (enabled or commented)
    }

    // Generate commented-out default config
    const lines = [];
    lines.push(`# [plugins.${name}.default]`);
    lines.push(`# enabled = true`);

    if (plugin.settings) {
      for (const [key, schema] of Object.entries(plugin.settings)) {
        const defaultValue = schema.default;
        if (defaultValue !== undefined) {
          const valueStr = typeof defaultValue === 'string' ? `"${defaultValue}"` : defaultValue;
          lines.push(`# ${key} = ${valueStr}`);
        }
      }
    }

    pluginConfigs.push(lines.join('\n'));
  }

  // Update config.toml if there are new plugins
  if (pluginConfigs.length > 0) {
    // Find where to insert - after existing plugins section or at the end
    const pluginsHeaderMatch = configContent.match(/^# =+\n# Plugins\n# =+/m);

    if (pluginsHeaderMatch) {
      // Find the end of the plugins section (next header or EOF)
      const afterHeader = configContent.indexOf(pluginsHeaderMatch[0]) + pluginsHeaderMatch[0].length;
      const nextHeaderMatch = configContent.slice(afterHeader).match(/\n# =+\n#[^=]/);
      const insertPoint = nextHeaderMatch
        ? afterHeader + nextHeaderMatch.index
        : configContent.length;

      // Insert new plugin configs before the next section
      const before = configContent.slice(0, insertPoint).trimEnd();
      const after = configContent.slice(insertPoint);

      configContent = before + '\n\n' + pluginConfigs.join('\n\n') + after;
    } else {
      // No plugins section yet, append at the end
      configContent = configContent.trimEnd() + '\n\n' +
        '# =============================================================================\n' +
        '# Plugins\n' +
        '# =============================================================================\n' +
        '# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]\n' +
        '# Uncomment and set enabled = true to activate a plugin\n\n' +
        pluginConfigs.join('\n\n') + '\n';
    }

    fs.writeFileSync(CONFIG_PATH, configContent);
  }

  // Also update config.toml.example if it exists
  try {
    let exampleContent = fs.readFileSync(CONFIG_EXAMPLE_PATH, 'utf8');
    let exampleModified = false;

    for (const [name, plugin] of plugins) {
      const sectionHeader = `[plugins.${name}.`;
      if (exampleContent.includes(sectionHeader) || exampleContent.includes(`# ${sectionHeader}`)) {
        continue;
      }

      // Add plugins section header if needed
      if (!exampleContent.includes('# Plugins')) {
        exampleContent = exampleContent.trimEnd() + '\n\n' +
          '# =============================================================================\n' +
          '# Plugins\n' +
          '# =============================================================================\n' +
          '# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]\n' +
          '# Uncomment and set enabled = true to activate a plugin\n';
      }

      const lines = [];
      lines.push(`# [plugins.${name}.default]`);
      lines.push(`# enabled = true`);

      if (plugin.settings) {
        for (const [key, schema] of Object.entries(plugin.settings)) {
          const defaultValue = schema.default;
          if (defaultValue !== undefined) {
            const valueStr = typeof defaultValue === 'string' ? `"${defaultValue}"` : defaultValue;
            lines.push(`# ${key} = ${valueStr}`);
          }
        }
      }

      exampleContent = exampleContent.trimEnd() + '\n\n' + lines.join('\n') + '\n';
      exampleModified = true;
    }

    if (exampleModified) {
      fs.writeFileSync(CONFIG_EXAMPLE_PATH, exampleContent);
    }
  } catch {
    // Example file doesn't exist, that's fine
  }
}

async function cmdList() {
  const plugins = await discoverPlugins();

  console.log(colors.cyan('Available Plugins:'));
  console.log('');

  for (const [name, plugin] of plugins) {
    const sources = getPluginSources(name);
    const status = sources.length > 0
      ? colors.green(`${sources.length} source(s) enabled`)
      : colors.gray('not configured');

    console.log(`  ${colors.bold(plugin.displayName || name)} ${colors.gray(`(${name})`)}`);
    console.log(`    Type: ${plugin.type} | Access: ${plugin.access}`);
    console.log(`    ${plugin.description}`);
    console.log(`    Status: ${status}`);

    if (sources.length > 0) {
      for (const { sourceName } of sources) {
        console.log(`      - ${sourceName}`);
      }
    }
    console.log('');
  }
}

async function cmdStatus() {
  const enabledPlugins = await getEnabledPlugins();

  if (enabledPlugins.length === 0) {
    console.log(colors.yellow('No plugins are currently enabled.'));
    console.log('');
    console.log('Configure plugins in config.toml:');
    console.log('');
    console.log('  [plugins.time-tracking.local]');
    console.log('  enabled = true');
    return;
  }

  console.log(colors.cyan('Enabled Plugins:'));
  console.log('');

  for (const { plugin, sources } of enabledPlugins) {
    console.log(`  ${colors.bold(plugin.displayName || plugin.name)}`);

    for (const { sourceName, config } of sources) {
      const tableName = `${plugin.name.replace(/-/g, '_')}_${sourceName.replace(/-/g, '_')}`;
      console.log(`    ${colors.green('●')} ${sourceName} → ${tableName}`);
    }
    console.log('');
  }
}

async function cmdSync(pluginName, sourceName, options = {}) {
  // Handle help flag
  if (options.help || options.h) {
    console.log(`
Usage: bin/plugins sync [plugin-name] [source-name] [options]

Sync data from plugins to the database.

Arguments:
  plugin-name    Sync only this plugin (optional)
  source-name    Sync only this source within the plugin (optional)

Options:
  --type TYPE    Sync only plugins of this type (e.g., events, issues, time-logs)

Examples:
  bin/plugins sync                        # Sync all enabled plugins
  bin/plugins sync --type events          # Sync only calendar/event plugins
  bin/plugins sync github-issues          # Sync only github-issues plugin
  bin/plugins sync github-issues today    # Sync only the 'today' source

Note: CLI tools (bin/calendar, bin/issues, etc.) auto-sync stale data before
displaying results. Use 'bin/plugins sync' to force an immediate refresh.
`);
    return;
  }

  // Ensure database is healthy and migrations are run
  const healthResult = await ensureHealthyDatabase({ verbose: false });
  if (!healthResult.success) {
    console.error(colors.red('Database health check failed'));
    process.exit(1);
  }

  const db = getDatabase();
  const vaultPath = path.join(PROJECT_ROOT, 'vault');

  const context = { db, vaultPath };

  // Get type filter from options
  const typeFilter = options.type || options.t;

  // Staleness check: skip sync if data is fresh (--if-stale <minutes>)
  const staleMinutes = options['if-stale'] ? parseInt(options['if-stale'], 10) : null;

  if (pluginName) {
    // Sync specific plugin
    const plugins = await discoverPlugins();
    const plugin = plugins.get(pluginName);

    if (!plugin) {
      console.error(colors.red(`Plugin not found: ${pluginName}`));
      process.exit(1);
    }

    // Check if plugin has a read command
    if (!plugin.commands?.read) {
      console.log(colors.yellow(`Plugin ${pluginName} does not have a read command.`));
      console.log(colors.gray('This plugin provides read-only access to external data.'));
      return;
    }

    const sources = getPluginSources(pluginName);

    if (sources.length === 0) {
      console.error(colors.red(`Plugin ${pluginName} has no enabled sources.`));
      process.exit(1);
    }

    // Filter to specific source if provided
    const toSync = sourceName
      ? sources.filter(s => s.sourceName === sourceName)
      : sources;

    if (sourceName && toSync.length === 0) {
      console.error(colors.red(`Source not found: ${sourceName}`));
      process.exit(1);
    }

    for (const { sourceName: src, config } of toSync) {
      console.log(`Syncing ${pluginName}/${src}...`);
      const result = await syncPluginSource(plugin, src, config, context);

      if (result.success) {
        console.log(colors.green(`  ✓ ${result.message}`));
      } else {
        console.log(colors.red(`  ✗ ${result.message}`));
      }
    }
  } else {
    // Sync all enabled plugins (optionally filtered by type)
    const enabledPlugins = await getEnabledPlugins();

    // Filter to plugins that have read commands
    let syncablePlugins = enabledPlugins.filter(({ plugin }) => plugin.commands?.read);

    // Apply type filter if specified
    if (typeFilter) {
      syncablePlugins = syncablePlugins.filter(({ plugin }) => plugin.type === typeFilter);

      if (syncablePlugins.length === 0) {
        console.log(colors.yellow(`No plugins of type '${typeFilter}' to sync.`));
        return;
      }
    }

    if (syncablePlugins.length === 0) {
      console.log(colors.yellow('No plugins to sync.'));
      return;
    }

    const typeMsg = typeFilter ? ` (type: ${typeFilter})` : '';
    console.log(colors.cyan(`Syncing plugins${typeMsg}...`));
    console.log('');

    let skippedCount = 0;
    for (const { plugin, sources } of syncablePlugins) {
      for (const { sourceName: src, config } of sources) {
        const sourceId = `${plugin.name}/${src}`;

        // Check staleness if --if-stale is specified
        if (staleMinutes !== null) {
          const syncMeta = getSyncMetadata(db, sourceId);
          if (syncMeta?.last_synced_at) {
            const lastSync = new Date(syncMeta.last_synced_at + 'Z');
            const ageMs = Date.now() - lastSync.getTime();
            const ageMinutes = ageMs / 1000 / 60;
            if (ageMinutes < staleMinutes) {
              skippedCount++;
              continue; // Skip - data is fresh
            }
          }
        }

        console.log(`  ${plugin.name}/${src}...`);
        const result = await syncPluginSource(plugin, src, config, context);

        if (result.success) {
          console.log(colors.green(`    ✓ ${result.message}`));
        } else {
          console.log(colors.red(`    ✗ ${result.message}`));
        }
      }
    }

    if (skippedCount > 0 && staleMinutes !== null) {
      console.log(colors.gray(`  (${skippedCount} source(s) skipped - synced within ${staleMinutes} minutes)`));
    }
  }

  // Force WAL checkpoint to ensure all writes are visible to other processes
  // This is critical for rapid start/stop timer cycles where the parent process
  // needs to immediately see the changes we just wrote
  // FULL mode waits for readers to finish, ensuring consistency without truncating WAL
  db.pragma('wal_checkpoint(FULL)');
}

/**
 * Get the user's preferred editor
 */
function getEditor() {
  return process.env.EDITOR || process.env.VISUAL || 'nano';
}

/**
 * Edit text in an external editor
 * @param {string} currentText - Current text content
 * @param {string} filename - Suggested filename for the temp file
 * @returns {string|null} - Edited text, or null if cancelled/unchanged
 */
function editInEditor(currentText, filename = 'edit.txt') {
  const editor = getEditor();
  const tmpDir = os.tmpdir();
  const tmpFile = path.join(tmpDir, `plugins-${Date.now()}-${filename}`);

  try {
    // Write current content to temp file
    fs.writeFileSync(tmpFile, currentText || '');

    // Open editor (blocking)
    console.log(colors.gray(`Opening ${editor}... (save and close to continue)`));
    execSync(`${editor} "${tmpFile}"`, { stdio: 'inherit' });

    // Read back the result
    const newText = fs.readFileSync(tmpFile, 'utf8');

    // Clean up
    fs.unlinkSync(tmpFile);

    return newText;
  } catch (error) {
    // Clean up on error
    try { fs.unlinkSync(tmpFile); } catch {}
    console.error(colors.red(`Editor failed: ${error.message}`));
    return null;
  }
}

async function cmdConfigure(pluginNameArg) {
  const plugins = await discoverPlugins();

  if (plugins.size === 0) {
    p.outro(color.yellow('No plugins available.'));
    return;
  }

  p.intro(color.bgCyan(color.black(' Plugin Configuration ')));

  // Main loop - returns to plugin selection after configuring
  while (true) {
    let pluginName = pluginNameArg;

    // If no plugin specified, let user choose
    if (!pluginName) {
      const pluginChoices = Array.from(plugins.values()).map((plugin) => ({
        label: plugin.displayName || plugin.name,
        value: plugin.name,
        hint: plugin.description
      }));

      pluginName = await p.select({
        message: 'Select a plugin to configure',
        options: [
          ...pluginChoices,
          { label: color.dim('Exit'), value: '__exit__' }
        ]
      });

      if (p.isCancel(pluginName) || pluginName === '__exit__') {
        p.outro('Configuration complete');
        return;
      }
    }

    const plugin = plugins.get(pluginName);
    if (!plugin) {
      p.cancel(`Plugin not found: ${pluginName}`);
      process.exit(1);
    }

    // Configure the selected plugin
    const shouldExit = await configurePlugin(plugin, pluginName);

    // If a specific plugin was passed as argument, exit after configuring it
    if (pluginNameArg || shouldExit) {
      p.outro('Configuration saved');
      return;
    }
  }
}

async function configurePlugin(plugin, pluginName) {
  // Inner configuration loop for a single plugin
  while (true) {
    // Show plugin info in a nice box
    p.note(
      plugin.longDescription?.trim() || plugin.description,
      plugin.displayName || plugin.name
    );

    // Refresh configured sources each iteration
    const allConfiguredSources = getConfiguredSources(pluginName);

    // Show current sources if any exist
    if (allConfiguredSources.length > 0) {
      const sourceList = allConfiguredSources
        .map(s => {
          const status = s.config.enabled
            ? color.green('●')
            : color.dim('○');
          return `${status} ${s.sourceName}`;
        })
        .join('\n');

      p.note(sourceList, 'Current sources');
    }

    // Build action choices based on current state
    const actionOptions = [
      { value: 'add', label: 'Add new source', hint: 'Create a new configuration' }
    ];

    if (allConfiguredSources.length > 0) {
      actionOptions.push(
        { value: 'edit', label: 'Edit source', hint: 'Modify existing configuration' },
        { value: 'remove', label: 'Remove source', hint: color.red('Delete a source') }
      );
    }

    actionOptions.push(
      { value: '__back__', label: color.dim('← Back to plugin list') }
    );

    const action = await p.select({
      message: 'What would you like to do?',
      options: actionOptions
    });

    if (p.isCancel(action) || action === '__back__') {
      return false; // Return to plugin selection
    }

    // Handle the selected action
    if (action === 'add') {
      await addSource(plugin, pluginName, allConfiguredSources);
    } else if (action === 'edit') {
      await editSource(plugin, pluginName, allConfiguredSources);
    } else if (action === 'remove') {
      await removeSource(pluginName, allConfiguredSources);
    }
  }
}

// Get configured sources for a plugin from config.toml
function getConfiguredSources(pluginName) {
  try {
    const configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
    const parsedConfig = parseToml(configContent);
    if (parsedConfig.plugins?.[pluginName]) {
      return Object.entries(parsedConfig.plugins[pluginName]).map(([name, cfg]) => ({
        sourceName: name,
        config: cfg
      }));
    }
  } catch {
    // No config yet
  }
  return [];
}

async function addSource(plugin, pluginName, existingSources) {
  const existingNames = existingSources.map(s => s.sourceName);

  const sourceName = await p.text({
    message: 'Source name',
    placeholder: 'e.g., local, work, personal',
    defaultValue: 'default',
    validate: (value) => {
      if (!value) return 'Source name is required';
      if (!value.match(/^[a-z0-9_-]+$/)) {
        return 'Must be lowercase alphanumeric with dashes or underscores';
      }
      if (existingNames.includes(value)) {
        return `Source "${value}" already exists`;
      }
    }
  });

  if (p.isCancel(sourceName)) {
    p.cancel('Cancelled');
    return;
  }

  // Collect settings
  const sourceConfig = { enabled: true };

  if (plugin.settings) {
    p.log.info(color.cyan('Configure plugin settings:'));

    for (const [key, schema] of Object.entries(plugin.settings)) {
      const value = await promptForSetting(key, schema, schema.default);
      if (p.isCancel(value)) {
        p.cancel('Cancelled');
        return;
      }
      if (value !== undefined) {
        sourceConfig[key] = value;
      }
    }
  }

  // Save
  const s = p.spinner();
  s.start('Saving configuration');
  saveSourceConfig(pluginName, sourceName, sourceConfig);
  s.stop(color.green(`✓ Added source "${sourceName}"`));
}

async function editSource(plugin, pluginName, allSources) {
  // Select source to edit
  let sourceToEdit;

  if (allSources.length === 1) {
    sourceToEdit = allSources[0].sourceName;
  } else {
    sourceToEdit = await p.select({
      message: 'Select source to edit',
      options: allSources.map(s => ({
        value: s.sourceName,
        label: s.sourceName,
        hint: s.config.enabled ? color.green('enabled') : color.dim('disabled')
      }))
    });

    if (p.isCancel(sourceToEdit)) return;
  }

  const currentConfig = allSources.find(s => s.sourceName === sourceToEdit)?.config || {};

  // Edit enabled status
  const enabled = await p.confirm({
    message: 'Enable this source?',
    initialValue: currentConfig.enabled === true
  });

  if (p.isCancel(enabled)) return;

  const sourceConfig = { enabled };

  // Edit settings
  if (plugin.settings) {
    p.log.info(color.cyan('Configure plugin settings:'));

    for (const [key, schema] of Object.entries(plugin.settings)) {
      const currentValue = currentConfig[key] ?? schema.default;
      const value = await promptForSetting(key, schema, currentValue);
      if (p.isCancel(value)) {
        p.cancel('Cancelled');
        return;
      }
      if (value !== undefined) {
        sourceConfig[key] = value;
      }
    }
  }

  // Handle AI instructions
  const hasInstructions = !!currentConfig.ai_instructions;

  const editInstructions = await p.confirm({
    message: hasInstructions
      ? 'Edit AI instructions?'
      : 'Add AI instructions? (tells AI how to use this data)',
    initialValue: false
  });

  if (!p.isCancel(editInstructions) && editInstructions) {
    const newInstructions = editInEditor(
      currentConfig.ai_instructions || '',
      'ai-instructions.txt'
    );
    if (newInstructions?.trim()) {
      sourceConfig.ai_instructions = newInstructions.trim();
    }
  } else if (hasInstructions) {
    sourceConfig.ai_instructions = currentConfig.ai_instructions;
  }

  // Save
  const s = p.spinner();
  s.start('Saving changes');
  saveSourceConfig(pluginName, sourceToEdit, sourceConfig);
  s.stop(color.green(`✓ Updated "${sourceToEdit}"`));
}

async function removeSource(pluginName, allSources) {
  let sourceToRemove;

  if (allSources.length === 1) {
    sourceToRemove = allSources[0].sourceName;
  } else {
    sourceToRemove = await p.select({
      message: 'Select source to remove',
      options: allSources.map(s => ({
        value: s.sourceName,
        label: s.sourceName
      }))
    });

    if (p.isCancel(sourceToRemove)) return;
  }

  const confirmed = await p.confirm({
    message: `Are you sure you want to remove "${sourceToRemove}"?`,
    initialValue: false
  });

  if (p.isCancel(confirmed) || !confirmed) {
    p.log.info('Cancelled');
    return;
  }

  const s = p.spinner();
  s.start('Removing source');
  deleteSourceConfig(pluginName, sourceToRemove);
  s.stop(color.green(`✓ Removed "${sourceToRemove}"`));
}

// Helper to prompt for a single setting based on schema
async function promptForSetting(key, schema, currentValue) {
  const message = schema.description || key;

  if (schema.type === 'boolean') {
    return p.confirm({
      message,
      initialValue: currentValue ?? false
    });
  } else if (schema.type === 'number') {
    const result = await p.text({
      message,
      defaultValue: currentValue != null ? String(currentValue) : '',
      validate: (v) => {
        if (v && isNaN(Number(v))) return 'Must be a number';
      }
    });
    return result ? Number(result) : undefined;
  } else if (schema.enum) {
    return p.select({
      message,
      options: schema.enum.map(opt => ({ value: opt, label: String(opt) })),
      initialValue: currentValue
    });
  } else {
    return p.text({
      message,
      defaultValue: currentValue ?? '',
      placeholder: schema.placeholder
    });
  }
}

// Save a source configuration
function saveSourceConfig(pluginName, sourceName, sourceConfig) {
  let config = {};
  try {
    const configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
    config = parseToml(configContent);
  } catch {
    // Config doesn't exist yet
  }

  if (!config.plugins) config.plugins = {};
  if (!config.plugins[pluginName]) config.plugins[pluginName] = {};

  config.plugins[pluginName][sourceName] = sourceConfig;
  writeConfig(config);
}

// Delete a source configuration
function deleteSourceConfig(pluginName, sourceName) {
  let config = {};
  try {
    const configContent = fs.readFileSync(CONFIG_PATH, 'utf8');
    config = parseToml(configContent);
  } catch {
    return;
  }

  if (config.plugins?.[pluginName]) {
    delete config.plugins[pluginName][sourceName];
    if (Object.keys(config.plugins[pluginName]).length === 0) {
      delete config.plugins[pluginName];
    }
  }

  writeConfig(config);
}

/**
 * Convert smol-toml output to use multi-line strings for ai_instructions
 * smol-toml uses \n escapes, but triple-quoted strings are more readable
 */
function formatMultilineStrings(tomlStr) {
  // Match ai_instructions = "..." and convert to triple-quoted if it contains \n
  return tomlStr.replace(
    /^(ai_instructions\s*=\s*)"((?:[^"\\]|\\.)*)"/gm,
    (match, prefix, content) => {
      // Check if it has escaped newlines
      if (!content.includes('\\n')) {
        return match; // Keep as-is if single line
      }
      // Unescape the content and use triple quotes
      const unescaped = content
        .replace(/\\n/g, '\n')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\');
      return `${prefix}"""\n${unescaped}\n"""`;
    }
  );
}

/**
 * Write config object to config.toml, preserving comments where possible
 */
function writeConfig(config) {
  // Read existing file to preserve structure/comments
  let existingContent = '';
  try {
    existingContent = fs.readFileSync(CONFIG_PATH, 'utf8');
  } catch {
    // File doesn't exist
  }

  if (existingContent) {
    // Try to update just the plugins section
    let pluginsSection = stringifyToml({ plugins: config.plugins });
    pluginsSection = formatMultilineStrings(pluginsSection);

    // Check if plugins section exists
    const pluginsMatch = existingContent.match(/^# =+\n# Plugins\n# =+.*?(?=\n# =|\n*$)/ms);

    if (pluginsMatch) {
      // Replace plugins section
      const before = existingContent.slice(0, pluginsMatch.index);
      const newPluginsSection = `# =============================================================================
# Plugins
# =============================================================================
# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]
# Uncomment and set enabled = true to activate a plugin

${pluginsSection}`;

      existingContent = before.trimEnd() + '\n\n' + newPluginsSection;
      fs.writeFileSync(CONFIG_PATH, existingContent);
    } else {
      // No plugins section yet, append it
      const newPluginsSection = `
# =============================================================================
# Plugins
# =============================================================================
# Each plugin source is configured under [plugins.<plugin-name>.<source-name>]
# Uncomment and set enabled = true to activate a plugin

${pluginsSection}`;

      fs.writeFileSync(CONFIG_PATH, existingContent.trimEnd() + '\n' + newPluginsSection);
    }
  } else {
    // Write new config file
    let tomlOutput = stringifyToml(config);
    tomlOutput = formatMultilineStrings(tomlOutput);
    const content = `# Configuration for Today system
# See config.toml.example for all available options

${tomlOutput}`;
    fs.writeFileSync(CONFIG_PATH, content);
  }
}

async function cmdInfo(pluginName) {
  const plugins = await discoverPlugins();

  if (!pluginName) {
    console.error(colors.red('Usage: plugins info <plugin-name>'));
    console.log('');
    console.log('Available plugins:');
    for (const [name] of plugins) {
      console.log(`  ${name}`);
    }
    process.exit(1);
  }

  const plugin = plugins.get(pluginName);
  if (!plugin) {
    console.error(colors.red(`Plugin not found: ${pluginName}`));
    process.exit(1);
  }

  console.log('');
  console.log(colors.bold(plugin.displayName || plugin.name));
  console.log(colors.gray('─'.repeat(60)));
  console.log('');
  console.log(`Type: ${plugin.type}`);
  console.log(`Access: ${plugin.access}`);

  if (plugin.commands?.read) {
    console.log(`Sync: ${colors.green('yes')}`);
  } else {
    console.log(`Sync: ${colors.gray('no (read-only, external data)')}`);
  }

  console.log('');

  if (plugin.longDescription) {
    console.log(plugin.longDescription.trim());
  } else {
    console.log(plugin.description);
  }

  // Show configured sources
  const sources = getPluginSources(pluginName);
  if (sources.length > 0) {
    console.log('');
    console.log(colors.cyan('Configured sources:'));
    for (const { sourceName, config } of sources) {
      const status = config.enabled === true ? colors.green('enabled') : colors.gray('disabled');
      console.log(`  ${sourceName} (${status})`);
      if (config.ai_instructions) {
        console.log(colors.gray('    AI instructions from config.toml:'));
        const lines = config.ai_instructions.trim().split('\n');
        for (const line of lines) {
          console.log(colors.gray(`      ${line}`));
        }
      }
    }
  }

  console.log('');
}

function showHelp() {
  console.log(`
${colors.bold('Plugin Management CLI')}

Usage: plugins <command> [options]

Commands:
  list                      Show all available plugins
  info <plugin>             Show detailed plugin documentation
  status                    Show enabled plugins and their sources
  configure [plugin]        Interactive plugin configuration
  sync [plugin] [source]    Sync plugin data (all if no plugin specified)
    --type <type>           Only sync plugins of a specific type (e.g., time-logs)

Examples:
  plugins list
  plugins info markdown-time-tracking
  plugins status
  plugins configure
  plugins configure markdown-time-tracking
  plugins sync
  plugins sync --type time-logs
  plugins sync markdown-time-tracking
  plugins sync markdown-time-tracking local

Configuration:
  Plugins are configured in config.toml:

  [plugins.markdown-time-tracking.local]
  enabled = true
  days_to_sync = 365
`);
}

// Parse arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const result = {
    command: null,
    positional: [],
    options: {}
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const key = arg.slice(2);
      // Check if next arg is the value (not another flag)
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        result.options[key] = args[i + 1];
        i++;
      } else {
        result.options[key] = true;
      }
    } else if (arg.startsWith('-') && arg.length === 2) {
      const key = arg.slice(1);
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        result.options[key] = args[i + 1];
        i++;
      } else {
        result.options[key] = true;
      }
    } else if (!result.command) {
      result.command = arg;
    } else {
      result.positional.push(arg);
    }
  }

  return result;
}

// Main
const { command, positional, options } = parseArgs();
const arg1 = positional[0];
const arg2 = positional[1];

// Ensure config.toml has entries for all plugins
await ensurePluginConfig();

try {
  switch (command) {
    case 'list':
      await cmdList();
      break;
    case 'info':
      await cmdInfo(arg1);
      break;
    case 'status':
      await cmdStatus();
      break;
    case 'configure':
      await cmdConfigure(arg1);
      break;
    case 'sync':
      await cmdSync(arg1, arg2, options);
      break;
    case '--help':
    case '-h':
    case undefined:
      showHelp();
      break;
    default:
      console.error(colors.red(`Unknown command: ${command}`));
      showHelp();
      process.exit(1);
  }
} catch (error) {
  console.error(colors.red('Error:'), error.message);
  process.exit(1);
}
