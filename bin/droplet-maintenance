#!/bin/bash
# Automated droplet maintenance script
# Prevents high load and disk space issues

set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_status() { echo -e "${GREEN}âœ“${NC} $1"; }
print_warning() { echo -e "${YELLOW}âš ${NC} $1"; }
print_error() { echo -e "${RED}âœ—${NC} $1"; }

# Configuration
MAX_PROCESS_AGE_MINUTES=60  # Kill processes older than this
MAX_LOG_SIZE_MB=100         # Truncate logs larger than this
DISK_WARNING_PERCENT=85     # Warn if disk usage exceeds this
LOAD_WARNING_THRESHOLD=4    # Warn if load average exceeds this

echo "ðŸ§¹ Running droplet maintenance..."

# 1. Check and kill stuck processes
print_status "Checking for stuck processes..."
STUCK_PROCESSES=$(ps aux | grep -E 'node.*bin/today.*--non-interactive' | grep -v grep | awk '{print $2}' || true)
if [ -n "$STUCK_PROCESSES" ]; then
    print_warning "Found stuck bin/today processes, killing..."
    echo "$STUCK_PROCESSES" | xargs -r kill -9
    print_status "Killed stuck processes: $STUCK_PROCESSES"
else
    print_status "No stuck bin/today processes found"
fi

# Kill any test processes running for more than 1 hour
OLD_TEST_PROCS=$(ps aux | grep -E 'jest|npm test' | grep -v grep | awk '{if ($10 !~ /^[0-9]+:[0-9]+$/) print $2}' || true)
if [ -n "$OLD_TEST_PROCS" ]; then
    print_warning "Found old test processes, killing..."
    echo "$OLD_TEST_PROCS" | xargs -r kill -9
    print_status "Killed old test processes"
fi

# 2. Clean up large log files
print_status "Checking log files..."

# System logs
if [ -f /var/log/syslog ]; then
    SYSLOG_SIZE=$(du -m /var/log/syslog | cut -f1)
    if [ "$SYSLOG_SIZE" -gt 500 ]; then
        print_warning "Syslog is ${SYSLOG_SIZE}MB, truncating..."
        sudo truncate -s 0 /var/log/syslog
        print_status "Truncated syslog"
    fi
fi

# Remove old rotated logs
sudo rm -f /var/log/syslog.*.gz /var/log/syslog.1 2>/dev/null || true

# Application logs
for LOG_FILE in /opt/today/.data/*.log; do
    if [ -f "$LOG_FILE" ]; then
        LOG_SIZE=$(du -m "$LOG_FILE" | cut -f1)
        if [ "$LOG_SIZE" -gt "$MAX_LOG_SIZE_MB" ]; then
            LOG_NAME=$(basename "$LOG_FILE")
            print_warning "$LOG_NAME is ${LOG_SIZE}MB, truncating to ${MAX_LOG_SIZE_MB}MB..."
            truncate -s "${MAX_LOG_SIZE_MB}M" "$LOG_FILE"
            print_status "Truncated $LOG_NAME"
        fi
    fi
done

# 3. Database maintenance
print_status "Checking database..."
if [ -f /opt/today/.data/today.db ]; then
    WAL_SIZE=$(du -m /opt/today/.data/today.db-wal 2>/dev/null | cut -f1 || echo 0)
    if [ "$WAL_SIZE" -gt 100 ]; then
        print_warning "WAL file is ${WAL_SIZE}MB, checkpointing..."
        sqlite3 /opt/today/.data/today.db 'PRAGMA wal_checkpoint(TRUNCATE);' 2>/dev/null || true
        print_status "Database WAL checkpointed"
    fi

    # Vacuum database weekly (on Sundays)
    if [ "$(date +%w)" -eq "0" ]; then
        print_status "Running weekly database vacuum..."
        sqlite3 /opt/today/.data/today.db 'VACUUM;' 2>/dev/null || true
        print_status "Database vacuumed"
    fi
fi

# 4. Clean up old journal logs
print_status "Cleaning journal logs..."
sudo journalctl --vacuum-time=7d --vacuum-size=500M 2>/dev/null || true

# 5. Check disk space
DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -gt "$DISK_WARNING_PERCENT" ]; then
    print_error "Disk usage is ${DISK_USAGE}% - needs attention!"

    # Emergency cleanup if over 95%
    if [ "$DISK_USAGE" -gt 95 ]; then
        print_warning "Emergency cleanup - disk critically full!"
        # Clear package cache
        sudo apt-get clean
        # Clear npm cache
        npm cache clean --force 2>/dev/null || true
        # Remove old database backups (keep last 3)
        ls -t /opt/today/.data/*.backup-* 2>/dev/null | tail -n +4 | xargs -r rm
    fi
else
    print_status "Disk usage is ${DISK_USAGE}%"
fi

# 6. Check system load
LOAD_1MIN=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
LOAD_INT=$(echo "$LOAD_1MIN" | cut -d. -f1)
if [ "$LOAD_INT" -ge "$LOAD_WARNING_THRESHOLD" ]; then
    print_warning "High load detected: $LOAD_1MIN"
    # Restart scheduler if load is very high
    if [ "$LOAD_INT" -ge 8 ]; then
        print_warning "Very high load - restarting scheduler..."
        systemctl restart today-scheduler
        print_status "Scheduler restarted"
    fi
else
    print_status "System load is $LOAD_1MIN"
fi

# 7. Report status
echo ""
echo "ðŸ“Š System Status:"
echo "  Disk: ${DISK_USAGE}% used"
echo "  Load: $LOAD_1MIN"
echo "  Memory: $(free -m | awk '/^Mem:/{printf "%.0f%% used", $3/$2 * 100}')"
echo ""
print_status "Maintenance complete!"