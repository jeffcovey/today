#!/usr/bin/env node

// Auto-use dotenvx if available
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import { program } from 'commander';
import { config } from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables (fallback if not using dotenvx)
if (!process.env.DOTENVX_RUNNING) {
  config();
}

// Try to load TODAY_ANTHROPIC_KEY from encrypted env (same as bin/today uses)
function loadTodayApiKey() {
  try {
    const result = execSync('npx dotenvx get TODAY_ANTHROPIC_KEY 2>/dev/null', {
      encoding: 'utf-8'
    }).trim();
    if (result) {
      process.env.TODAY_ANTHROPIC_KEY = result;
      return true;
    }
  } catch (e) {
    // No API key available
  }
  return false;
}

// Load the API key
loadTodayApiKey();

// Import commands
// Note: EmailManager and EmailOrganizer commented out - see GitHub issues for chat/organize features
Promise.all([
  import('../src/email-downloader.js'),
  import('../src/email-manager.js'),
  // import('../src/email-organizer.js')  // TODO: Re-enable when organize plugin is ready
]).then(([{ EmailDownloader }, { EmailManager }/*, { EmailOrganizer }*/]) => {
  program
    .name('email')
    .description('Email management CLI for downloading and managing emails');

  program
    .command('download [emailId]')
    .description('Download emails (or fetch specific email body by ID)')
    .option('-d, --days <number>', 'Number of days to download', '30')
    .option('-a, --account <email>', 'Email account to download from', process.env.EMAIL_ACCOUNT || 'jeff.covey@icloud.com')
    .action(async (emailId, options) => {
      try {
        if (emailId) {
          // Fetch specific email body by ID
          // ID format: source:folder:uid (e.g., imap-email/icloud:INBOX:196336)
          const { ImapFlow } = await import('imapflow');
          const { simpleParser } = await import('mailparser');
          const Database = (await import('better-sqlite3')).default;
          const toml = await import('smol-toml');
          const fs = await import('fs');
          const nodePath = await import('path');

          // Parse the email ID
          const match = emailId.match(/^([^:]+\/[^:]+):(.+):(\d+)$/);
          if (!match) {
            console.error(chalk.red('Invalid email ID format. Expected: source:folder:uid'));
            console.error(chalk.gray('Example: imap-email/icloud:INBOX:196336'));
            process.exit(1);
          }

          const [, sourceId, folder, uidStr] = match;
          const uid = parseInt(uidStr);
          const [pluginName, sourceName] = sourceId.split('/');

          console.log(chalk.blue(`ðŸ“§ Fetching email body: ${emailId}`));

          // Load config to get IMAP settings
          const configPath = nodePath.join(process.cwd(), 'config.toml');
          const configContent = fs.readFileSync(configPath, 'utf-8');
          const config = toml.parse(configContent);

          const sourceConfig = config.plugins?.[pluginName]?.[sourceName];
          if (!sourceConfig) {
            console.error(chalk.red(`Source not found in config: ${sourceId}`));
            process.exit(1);
          }

          const { host, port = 993, secure = true, username, password_env = 'EMAIL_PASSWORD' } = sourceConfig;
          const password = process.env[password_env];

          if (!password) {
            console.error(chalk.red(`Password not found in ${password_env}`));
            process.exit(1);
          }

          // Connect to IMAP
          const client = new ImapFlow({
            host,
            port,
            secure,
            auth: { user: username, pass: password },
            logger: false
          });

          await client.connect();
          const lock = await client.getMailboxLock(folder);

          try {
            const message = await client.fetchOne(uid, { source: true }, { uid: true });

            if (!message || !message.source) {
              console.error(chalk.red('Email not found or no content'));
              process.exit(1);
            }

            const parsed = await simpleParser(message.source);
            let textContent = parsed.text || '';
            let htmlContent = parsed.html || '';
            const attachments = parsed.attachments?.map(a => ({
              filename: a.filename,
              contentType: a.contentType,
              size: a.size
            })) || [];

            const maxBodySize = 50000;
            if (textContent.length > maxBodySize) {
              textContent = textContent.substring(0, maxBodySize) + '\n[truncated]';
            }
            if (htmlContent.length > maxBodySize) {
              htmlContent = htmlContent.substring(0, maxBodySize) + '\n[truncated]';
            }

            const snippet = textContent
              ? textContent.substring(0, 200).replace(/\s+/g, ' ').trim()
              : '';

            // Update database
            const dbPath = nodePath.join(process.cwd(), '.data', 'today.db');
            const db = new Database(dbPath);

            const result = db.prepare(`
              UPDATE email
              SET snippet = ?, text_content = ?, html_content = ?, attachments = ?,
                  metadata = json_set(COALESCE(metadata, '{}'), '$.needs_body', false)
              WHERE id = ?
            `).run(
              snippet,
              textContent,
              htmlContent,
              attachments.length > 0 ? JSON.stringify(attachments) : null,
              emailId
            );

            db.close();

            if (result.changes > 0) {
              console.log(chalk.green('âœ“ Email body fetched and saved'));
              console.log(chalk.gray(`  Snippet: ${snippet.substring(0, 80)}...`));
              if (attachments.length > 0) {
                console.log(chalk.gray(`  Attachments: ${attachments.map(a => a.filename).join(', ')}`));
              }
            } else {
              console.log(chalk.yellow('Email not found in database'));
            }

          } finally {
            lock.release();
            await client.logout();
          }

          process.exit(0);

        } else {
          // Original download behavior
          console.log(chalk.blue(`ðŸ“§ Downloading emails from the last ${options.days} days...`));
          const downloader = new EmailDownloader();
          await downloader.downloadEmails(options.account, parseInt(options.days));
          process.exit(0);
        }
      } catch (error) {
        console.error(chalk.red('Error downloading emails:'), error.message);
        process.exit(1);
      }
    });

  program
    .command('setup')
    .description('Setup email account credentials')
    .action(async () => {
      console.log(chalk.blue('ðŸ“§ Email Account Setup'));
      console.log(chalk.yellow('\nFor iCloud/Apple Mail:'));
      console.log('1. Go to https://appleid.apple.com');
      console.log('2. Sign in and go to "Sign-In and Security"');
      console.log('3. Select "App-Specific Passwords"');
      console.log('4. Generate a new password for "today-cli email"');
      console.log('5. Add the following to your .env file:');
      console.log(chalk.green('\nEMAIL_ACCOUNT=your@icloud.com'));
      console.log(chalk.green('EMAIL_PASSWORD=xxxx-xxxx-xxxx-xxxx'));
      console.log(chalk.gray('\n(Replace xxxx-xxxx-xxxx-xxxx with your app-specific password)'));
    });

  program
    .command('stats')
    .description('Show email database statistics')
    .action(async () => {
      try {
        console.log(chalk.blue('ðŸ“Š Email Database Statistics'));
        const downloader = new EmailDownloader();
        const stats = await downloader.getEmailStats();
        
        if (stats.total === 0) {
          console.log(chalk.yellow('No emails downloaded yet.'));
          console.log('Run "email download" to download emails.');
        } else {
          console.log(chalk.green(`\nTotal emails: ${stats.total}`));
          console.log(chalk.gray(`Oldest email: ${stats.oldest ? new Date(stats.oldest).toLocaleDateString() : 'N/A'}`));
          console.log(chalk.gray(`Newest email: ${stats.newest ? new Date(stats.newest).toLocaleDateString() : 'N/A'}`));
          console.log(chalk.gray(`Total size: ${(stats.total_size / 1024 / 1024).toFixed(2)} MB`));
          
          if (stats.folders && stats.folders.length > 0) {
            console.log(chalk.blue('\nðŸ“ Emails by folder:'));
            stats.folders.forEach(folder => {
              console.log(chalk.gray(`  ${folder.folder}: ${folder.count} emails`));
            });
          }
        }
      } catch (error) {
        console.error(chalk.red('Error getting stats:'), error.message);
        process.exit(1);
      }
    });

  program
    .command('list')
    .description('List recent emails')
    .option('-l, --limit <number>', 'Number of emails to show', '10')
    .option('-f, --from <email>', 'Filter by sender')
    .option('-s, --subject <text>', 'Filter by subject')
    .action(async (options) => {
      try {
        const manager = new EmailManager();
        const filter = {};
        
        if (options.from) filter.from = options.from;
        if (options.subject) filter.subject = options.subject;
        filter.limit = parseInt(options.limit);
        
        const emails = await manager.getLocalEmails(filter);
        
        if (emails.length === 0) {
          console.log(chalk.yellow('No emails found.'));
        } else {
          console.log(chalk.blue(`\nðŸ“§ Recent Emails (${emails.length}):`));
          emails.forEach((email, i) => {
            const date = new Date(email.date).toLocaleDateString();
            console.log(`${i + 1}. ${chalk.bold(email.subject || '(no subject)')}`);
            console.log(`   From: ${email.from_address} | Date: ${date}`);
          });
        }
        process.exit(0); // Explicitly exit after listing emails
      } catch (error) {
        console.error(chalk.red('Error listing emails:'), error.message);
        process.exit(1);
      }
    });

  program
    .command('search <query>')
    .description('Search emails (use --server for historical IMAP search)')
    .option('-s, --server', 'Search IMAP server directly (for historical emails)')
    .option('-f, --folder <folder>', 'Limit to specific folder (default: search all)')
    .option('-l, --limit <number>', 'Max results to return', '20')
    .action(async (query, options) => {
      try {
        if (options.server) {
          // Search IMAP server directly
          console.log(chalk.blue(`ðŸ” Searching IMAP server for: ${query}`));
          const { ImapFlow } = await import('imapflow');

          const client = new ImapFlow({
            host: 'imap.mail.me.com',  // TODO: Read from config
            port: 993,
            secure: true,
            auth: {
              user: process.env.EMAIL_ACCOUNT || 'jeff.covey@icloud.com',
              pass: process.env.EMAIL_PASSWORD
            },
            logger: false
          });

          await client.connect();

          // Determine which folders to search
          let foldersToSearch = [];
          if (options.folder) {
            foldersToSearch = [options.folder];
          } else {
            // Search common folders
            const allFolders = await client.list();
            const priorityFolders = ['INBOX', 'Sent Messages', 'Sent', 'Archive'];
            foldersToSearch = allFolders
              .filter(f => !f.path.startsWith('[') && f.path !== 'Notes')
              .map(f => f.path)
              .sort((a, b) => {
                const aIdx = priorityFolders.indexOf(a);
                const bIdx = priorityFolders.indexOf(b);
                if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;
                if (aIdx >= 0) return -1;
                if (bIdx >= 0) return 1;
                return 0;
              });
          }

          const allResults = [];
          const limit = parseInt(options.limit);

          for (const folder of foldersToSearch) {
            if (allResults.length >= limit) break;

            try {
              const lock = await client.getMailboxLock(folder);
              try {
                for await (const msg of client.fetch(
                  { or: [
                    { subject: query },
                    { from: query },
                    { body: query }
                  ]},
                  { envelope: true, size: true }
                )) {
                  allResults.push({
                    uid: msg.uid,
                    folder: folder,
                    subject: msg.envelope?.subject || '(no subject)',
                    from: msg.envelope?.from?.[0]?.address || 'unknown',
                    date: msg.envelope?.date
                  });
                }
              } finally {
                lock.release();
              }
            } catch (e) {
              // Skip folders we can't access
            }
          }

          await client.logout();

          if (allResults.length === 0) {
            console.log(chalk.yellow('No emails found matching your query.'));
          } else {
            // Sort by date descending (most recent first)
            allResults.sort((a, b) => {
              const dateA = a.date ? new Date(a.date).getTime() : 0;
              const dateB = b.date ? new Date(b.date).getTime() : 0;
              return dateB - dateA;
            });

            const results = allResults.slice(0, limit);
            console.log(chalk.green(`\nðŸ“§ Found ${allResults.length} emails on server (showing ${results.length}):\n`));
            results.forEach((email, i) => {
              const date = email.date ? new Date(email.date).toLocaleDateString() : 'unknown';
              console.log(`${i + 1}. ${chalk.bold(email.subject)}`);
              console.log(`   From: ${email.from} | Date: ${date} | Folder: ${email.folder}`);
            });
          }
        } else {
          // Search local database
          console.log(chalk.blue(`ðŸ” Searching local cache for: ${query}`));
          const manager = new EmailManager();
          const emails = await manager.getLocalEmails({
            content: query,
            limit: parseInt(options.limit)
          });

          if (emails.length === 0) {
            console.log(chalk.yellow('No emails found. Try --server to search IMAP directly.'));
          } else {
            console.log(chalk.green(`\nðŸ“§ Found ${emails.length} emails:\n`));
            emails.forEach((email, i) => {
              const date = new Date(email.date).toLocaleDateString();
              console.log(`${i + 1}. ${chalk.bold(email.subject || '(no subject)')}`);
              console.log(`   From: ${email.from_address} | Date: ${date}`);
            });
          }
        }
        process.exit(0);
      } catch (error) {
        console.error(chalk.red('Error searching emails:'), error.message);
        process.exit(1);
      }
    });

  // TODO: Move chat feature to separate plugin - see GitHub issue #60
  // program
  //   .command('chat')
  //   .description('Have a conversation about your emails')
  //   .action(async () => {
  //     try {
  //       console.log(chalk.blue('ðŸ’¬ Email Conversation Mode'));
  //       console.log(chalk.gray('Examples:'));
  //       console.log(chalk.gray('  â€¢ "Show me emails from GitHub"'));
  //       console.log(chalk.gray('  â€¢ "Delete all emails about Patreon"'));
  //       console.log(chalk.gray('  â€¢ "How many emails from last week?"'));
  //       console.log(chalk.gray('  â€¢ "Move Heroku emails to a folder"'));
  //       console.log(chalk.gray('  â€¢ "Summarize my recent emails"\n'));
  //
  //       const manager = new EmailManager();
  //       await manager.conversationMode();
  //     } catch (error) {
  //       console.error(chalk.red('Error in conversation mode:'), error.message);
  //       console.error(chalk.gray('Stack trace:'), error.stack);
  //       // Don't exit on error, just return
  //     }
  //   });

  // TODO: Move organize feature to separate plugin - see GitHub issue #61
  // program
  //   .command('organize')
  //   .description('Organize inbox emails into stage-based folders')
  //   .action(async () => {
  //     try {
  //       console.log(chalk.blue('ðŸ“ Organizing emails by stage...'));
  //       console.log(chalk.gray('This will categorize emails into:'));
  //       console.log(chalk.gray('  â€¢ _Front Stage: Meetings, calls, support, communications'));
  //       console.log(chalk.gray('  â€¢ _Back Stage: Maintenance, bills, bug fixes, organizing'));
  //       console.log(chalk.gray('  â€¢ _Off Stage: Personal time, nature, friends, reading\n'));
  //
  //       const organizer = new EmailOrganizer();
  //       await organizer.run();
  //       process.exit(0); // Explicitly exit after successful completion
  //     } catch (error) {
  //       console.error(chalk.red('Error organizing emails:'), error.message);
  //       process.exit(1);
  //     }
  //   });

  program.parse();
}).catch(error => {
  console.error(chalk.red('Failed to load email commands:'), error.message);
  process.exit(1);
});