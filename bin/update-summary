#!/usr/bin/env node

// Auto-use dotenvx if available
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SUMMARY_FILE = path.join(__dirname, '..', 'SUMMARY.json');
const DB_PATH = path.join(__dirname, '..', '.notion-cache', 'notion-cache.db');
const NOTES_DIR = path.join(__dirname, '..', 'notes');

async function loadSummary() {
  try {
    const content = await fs.readFile(SUMMARY_FILE, 'utf-8');
    const summary = JSON.parse(content);
    // Ensure content object exists for older versions
    if (!summary.content) {
      summary.content = {
        concerns: [],
        people_to_contact: [],
        urgent_tasks: [],
        overdue_tasks: [],
        task_categories: {},
        recent_notes: [],
        important_emails: [],
        top_email_senders: {},
        calendar_today: [],
        calendar_week: []
      };
    }
    return summary;
  } catch (error) {
    console.error('Creating new summary file...');
    return {
      meta: {
        version: "3.0.0",
        last_updated: "",
        last_sync: {
          emails: "",
          tasks: "",
          notes: "",
          todoist: ""
        },
        update_count: 0,
        retention_days: 7,
        format: "ai-content-summary"
      },
      state: {
        email_ids_seen: [],
        task_ids_seen: [],
        note_files_seen: {},
        todoist_ids_seen: []
      },
      changes: {
        new_emails: [],
        deleted_emails: [],
        replied_emails: [],
        new_tasks: [],
        completed_tasks: [],
        modified_tasks: [],
        new_notes: [],
        modified_notes: [],
        deleted_notes: []
      },
      patterns: {
        recurring_tasks: [],
        time_blocks: {
          morning: [],
          afternoon: [],
          evening: []
        },
        energy_patterns: {},
        completion_velocity: {}
      },
      insights: {
        bottlenecks: [],
        strengths: [],
        opportunities: [],
        risks: []
      },
      content: {
        concerns: [],
        people_to_contact: [],
        urgent_tasks: [],
        overdue_tasks: [],
        task_categories: {},
        recent_notes: [],
        important_emails: [],
        top_email_senders: {},
        calendar_today: [],
        calendar_week: [],
        ogm_work: []
      },
      active_context: {
        projects: {},
        relationships: {},
        commitments: {},
        deadlines: {}
      },
      communications: {
        pending_responses: [],
        follow_ups: [],
        key_conversations: {}
      },
      metrics: {
        task_completion_rate: 0,
        email_response_time: 0,
        focus_time_available: 0,
        wellbeing_indicators: {}
      },
      recommendations: {
        daily_focus: [],
        weekly_goals: [],
        process_improvements: []
      },
      history: {
        recent_completions: [],
        recent_decisions: [],
        lessons_learned: []
      }
    };
  }
}

// Get table columns dynamically
async function getTableColumns(tableName) {
  try {
    const result = execSync(
      `sqlite3 "${DB_PATH}" "PRAGMA table_info(${tableName});"`,
      { encoding: 'utf-8' }
    );
    const lines = result.trim().split('\n');
    return lines.map(line => {
      const parts = line.split('|');
      return parts[1]; // Column name is in second position
    });
  } catch (error) {
    return [];
  }
}

// Check if table exists
async function tableExists(tableName) {
  try {
    const result = execSync(
      `sqlite3 "${DB_PATH}" "SELECT name FROM sqlite_master WHERE type='table' AND name='${tableName}';"`,
      { encoding: 'utf-8' }
    );
    return result.trim().length > 0;
  } catch (error) {
    return false;
  }
}

async function getRecentEmails(summary) {
  // First check if emails table exists
  if (!await tableExists('emails')) {
    console.log('No emails table found');
    return [];
  }

  const columns = await getTableColumns('emails');
  if (columns.length === 0) {
    return [];
  }

  // Build query based on available columns
  const selectCols = [];
  if (columns.includes('id')) selectCols.push('id');
  if (columns.includes('uid')) selectCols.push('uid');
  if (columns.includes('subject')) selectCols.push('subject');
  if (columns.includes('from_address')) selectCols.push('from_address');
  if (columns.includes('date')) selectCols.push('date');
  if (columns.includes('folder')) selectCols.push('folder');
  
  if (selectCols.length === 0) {
    console.log('No useful columns in emails table');
    return [];
  }

  const hasDateCol = columns.includes('date');
  
  let query;
  if (hasDateCol) {
    // Get emails from last 3 days for content analysis
    query = `
      SELECT ${selectCols.join(', ')}
      FROM emails 
      WHERE date > datetime('now', '-3 days')
      ORDER BY date DESC
      LIMIT 100
    `;
  } else {
    // No date column, just get recent emails by ID
    query = `
      SELECT ${selectCols.join(', ')}
      FROM emails 
      ORDER BY id DESC
      LIMIT 100
    `;
  }
  
  try {
    const result = execSync(`sqlite3 -json "${DB_PATH}" "${query}"`, { encoding: 'utf-8' });
    return JSON.parse(result || '[]');
  } catch (error) {
    console.error('Error fetching emails:', error.message);
    return [];
  }
}

async function getTasks(summary) {
  // First check if task_cache table exists
  if (!await tableExists('task_cache')) {
    console.log('No task_cache table found');
    return [];
  }

  const columns = await getTableColumns('task_cache');
  if (columns.length === 0) {
    return [];
  }

  // Build query based on available columns
  const selectCols = [];
  if (columns.includes('id')) selectCols.push('id');
  if (columns.includes('title')) selectCols.push('title');
  if (columns.includes('properties')) selectCols.push('properties');
  if (columns.includes('last_edited_time')) selectCols.push('last_edited_time');
  if (columns.includes('database_id')) selectCols.push('database_id');
  
  if (selectCols.length === 0) {
    console.log('No useful columns in task_cache table');
    return [];
  }

  // Simple query - just get all tasks since we can't filter by stage/due_date if they don't exist
  const query = `
    SELECT ${selectCols.join(', ')}
    FROM task_cache
    LIMIT 500
  `;
  
  try {
    const result = execSync(`sqlite3 -json "${DB_PATH}" "${query}"`, { encoding: 'utf-8' });
    const tasks = JSON.parse(result || '[]');
    
    // If properties column exists, try to parse it for more info
    if (columns.includes('properties')) {
      return tasks.map(task => {
        try {
          const props = JSON.parse(task.properties || '{}');
          return {
            ...task,
            // Extract useful fields from properties if they exist
            stage: props.Stage?.select?.name,
            due_date: props['Due Date']?.date?.start,
            tags: props.Tags?.multi_select?.map(t => t.name).join(', ')
          };
        } catch (e) {
          return task;
        }
      });
    }
    
    return tasks;
  } catch (error) {
    console.error('Error fetching tasks:', error.message);
    return [];
  }
}

async function getNoteChanges(summary) {
  const notesDir = path.join(__dirname, '..', 'notes');
  const changes = {
    new: [],
    modified: [],
    deleted: []
  };
  
  try {
    // Find all markdown files modified in last 7 days
    const findCmd = `find "${notesDir}" -type f -name "*.md" -mtime -7 2>/dev/null || true`;
    const files = execSync(findCmd, { encoding: 'utf-8' })
      .split('\n')
      .filter(f => f.length > 0);
    
    const currentFiles = {};
    
    for (const file of files) {
      const stats = await fs.stat(file).catch(() => null);
      if (stats) {
        const relPath = path.relative(notesDir, file);
        currentFiles[relPath] = stats.mtime.toISOString();
        
        if (!summary.state.note_files_seen[relPath]) {
          changes.new.push(relPath);
        } else if (summary.state.note_files_seen[relPath] < stats.mtime.toISOString()) {
          changes.modified.push(relPath);
        }
      }
    }
    
    // Check for deleted files
    for (const file in summary.state.note_files_seen) {
      if (!currentFiles[file]) {
        changes.deleted.push(file);
      }
    }
    
    return { files: currentFiles, changes };
  } catch (error) {
    console.error('Error checking notes:', error.message);
    return { files: {}, changes };
  }
}

async function extractContentFromNotes(summary) {
  const content = {
    concerns: [],
    people_to_contact: [],
    recent_notes: [],
    ogm_work: []
  };
  
  try {
    // Read concerns note if it exists
    const concernsPath = path.join(NOTES_DIR, 'daily', '2025-08-08-concerns.md');
    const concernsText = await fs.readFile(concernsPath, 'utf-8').catch(() => '');
    
    if (concernsText) {
      // Extract bullet points from concerns
      content.concerns = concernsText.split('\n')
        .filter(line => line.startsWith('- '))
        .slice(0, 10)  // Top 10 concerns
        .map(line => line.substring(2).trim());
      
      // Extract mentions of people to contact
      const peopleRegex = /(?:reply|respond|contact|email|call|meet|talk)\s+(?:to\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/g;
      const peopleSet = new Set([...concernsText.matchAll(peopleRegex)].map(m => m[1]));
      content.people_to_contact = Array.from(peopleSet);
    }
    
    // Get other recent notes
    const recentNotes = execSync(
      `find "${NOTES_DIR}" -name "*.md" -mtime -3 -type f 2>/dev/null | head -5`,
      { encoding: 'utf-8' }
    ).trim().split('\n').filter(Boolean);
    
    for (const notePath of recentNotes) {
      const name = path.basename(notePath);
      const text = await fs.readFile(notePath, 'utf-8').catch(() => '');
      const firstLine = text.split('\n').find(l => l.trim() && !l.startsWith('#')) || '';
      content.recent_notes.push({
        file: name,
        preview: firstLine.slice(0, 100)
      });
    }
    
    // Extract OGM work items
    const ogmWorkDir = path.join(NOTES_DIR, 'ogm-work');
    try {
      const ogmFiles = execSync(
        `find "${ogmWorkDir}" -name "*.md" -type f 2>/dev/null`,
        { encoding: 'utf-8' }
      ).trim().split('\n').filter(Boolean);
      
      for (const ogmFile of ogmFiles) {
        const text = await fs.readFile(ogmFile, 'utf-8').catch(() => '');
        const lines = text.split('\n');
        
        // Extract unchecked tasks (- [ ])
        const tasks = lines.filter(line => line.match(/^- \[ \]/));
        
        // Find priority indicators (look for P0, Critical, Urgent in the task or its parent section)
        const criticalTasks = tasks.filter(t => {
          // Check if task contains critical keywords
          if (t.match(/P0|Critical.*Crisis|Urgent.*\(P0\)/i)) return true;
          // Check if task is under a Critical/Urgent section
          const taskIndex = lines.indexOf(t);
          // Look backwards for section header
          for (let i = taskIndex - 1; i >= 0; i--) {
            if (lines[i].startsWith('##')) {
              return lines[i].match(/Critical|Urgent.*\(P0\)/i);
            }
          }
          return false;
        });
        const highPriorityTasks = tasks.filter(t => t.match(/P1|High Priority/i));
        
        if (tasks.length > 0) {
          content.ogm_work.push({
            file: path.basename(ogmFile),
            total_tasks: tasks.length,
            critical_count: criticalTasks.length,
            high_priority_count: highPriorityTasks.length,
            sample_tasks: tasks.slice(0, 3).map(t => t.replace(/^- \[ \] /, '').trim())
          });
        }
      }
    } catch (e) {
      // No OGM work directory or files
    }
  } catch (error) {
    console.error('Error extracting note content:', error.message);
  }
  
  return content;
}

async function extractTaskContent(tasks) {
  const content = {
    urgent_tasks: [],
    overdue_tasks: [],
    task_categories: {}
  };
  
  try {
    const today = new Date().toISOString().split('T')[0];
    
    // Parse tasks to extract meaningful info
    const parsed = tasks.map(t => {
      try {
        const props = typeof t.properties === 'string' ? JSON.parse(t.properties) : (t.properties || {});
        return {
          id: t.id,
          title: t.title || props.title || props.Name?.title?.[0]?.text?.content || 'Untitled',
          due_date: props.due_date || props['Due Date']?.date?.start,
          stage: props.stage || props.Stage?.select?.name,
          database: t.database_id || props.database || 'Uncategorized',
          priority: props.priority || props.Priority?.select?.name
        };
      } catch (e) {
        return { 
          id: t.id,
          title: t.title || 'Untitled',
          database: 'Uncategorized'
        };
      }
    }).filter(t => t.title && t.title !== 'Untitled');
    
    // Find urgent tasks (due today or tomorrow)
    content.urgent_tasks = parsed
      .filter(t => t.due_date && t.due_date >= today && 
              t.due_date <= new Date(Date.now() + 48*60*60*1000).toISOString().split('T')[0])
      .slice(0, 10)
      .map(t => ({
        title: t.title,
        due_date: t.due_date,
        priority: t.priority
      }));
    
    // Find overdue tasks
    content.overdue_tasks = parsed
      .filter(t => t.due_date && t.due_date < today)
      .slice(0, 10)
      .map(t => ({
        title: t.title,
        due_date: t.due_date,
        days_overdue: Math.floor((Date.now() - new Date(t.due_date)) / (24*60*60*1000))
      }));
    
    // Categorize tasks
    parsed.forEach(t => {
      const category = t.database || 'Uncategorized';
      if (!content.task_categories[category]) {
        content.task_categories[category] = 0;
      }
      content.task_categories[category]++;
    });
  } catch (error) {
    console.error('Error extracting task content:', error.message);
  }
  
  return content;
}

async function extractCalendarContent() {
  const content = {
    calendar_today: [],
    calendar_week: []
  };
  
  try {
    // Check if calendar cache exists
    const cacheFile = path.join(__dirname, '..', '.calendar-cache', 'events.json');
    const cacheData = await fs.readFile(cacheFile, 'utf-8')
      .then(JSON.parse)
      .catch(() => null);
    
    if (!cacheData || !cacheData.events) {
      return content;
    }
    
    const now = new Date();
    const today = new Date(now);
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const weekFromNow = new Date(today);
    weekFromNow.setDate(weekFromNow.getDate() + 7);
    
    // Extract today's events
    content.calendar_today = cacheData.events
      .filter(event => {
        const eventDate = new Date(event.start);
        return eventDate >= today && eventDate < tomorrow;
      })
      .map(event => {
        // Preserve the original time and timezone from the source
        // Don't convert - just extract and display what we have
        let timeDisplay = 'All day';
        
        if (!event.allDay) {
          const eventDate = new Date(event.start);
          // Show the time in its original timezone if we have it
          if (event.startTimeZone) {
            timeDisplay = eventDate.toLocaleTimeString('en-US', { 
              hour: 'numeric', 
              minute: '2-digit',
              timeZone: event.startTimeZone
            }) + ' ' + event.startTimeZone;
          } else {
            // Fall back to ISO string time if no timezone specified
            timeDisplay = event.start;
          }
        }
        
        return {
          time: timeDisplay,
          title: event.title,
          location: event.location,
          calendar: event.calendar || event.source,
          originalTime: event.start,  // Keep the raw time
          originalTimezone: event.startTimeZone || null // Keep the timezone
        };
      });
    
    // Extract this week's events
    content.calendar_week = cacheData.events
      .filter(event => {
        const eventDate = new Date(event.start);
        return eventDate >= today && eventDate < weekFromNow;
      })
      .slice(0, 20) // Limit to 20 events for the week
      .map(event => {
        // Preserve the original time and timezone from the source
        const eventDate = new Date(event.start);
        
        // Show date in the event's original timezone if available
        const dateDisplay = event.startTimeZone 
          ? eventDate.toLocaleDateString('en-US', { 
              weekday: 'short', 
              month: 'short', 
              day: 'numeric',
              timeZone: event.startTimeZone
            })
          : eventDate.toLocaleDateString('en-US', { 
              weekday: 'short', 
              month: 'short', 
              day: 'numeric'
            });
        
        let timeDisplay = 'All day';
        if (!event.allDay) {
          if (event.startTimeZone) {
            timeDisplay = eventDate.toLocaleTimeString('en-US', { 
              hour: 'numeric', 
              minute: '2-digit',
              timeZone: event.startTimeZone
            }) + ' ' + event.startTimeZone;
          } else {
            // Fall back to ISO string time if no timezone specified
            timeDisplay = event.start;
          }
        }
        
        return {
          date: dateDisplay,
          time: timeDisplay,
          title: event.title,
          location: event.location,
          originalTime: event.start,  // Keep the raw time
          originalTimezone: event.startTimeZone || null // Keep the timezone
        };
      });
  } catch (error) {
    console.error('Error extracting calendar content:', error.message);
  }
  
  return content;
}

async function extractEmailContent(emails) {
  const content = {
    important_emails: [],
    top_email_senders: {}
  };
  
  try {
    // Group by sender
    emails.forEach(e => {
      const sender = (e.from_address || 'Unknown').replace(/<.*>/, '').trim();
      if (!content.top_email_senders[sender]) {
        content.top_email_senders[sender] = 0;
      }
      content.top_email_senders[sender]++;
    });
    
    // Find important emails by keywords
    const importantKeywords = ['urgent', 'important', 'action', 'review', 'approve', 'deadline', 'overdue', 'reply', 'reminder'];
    content.important_emails = emails
      .filter(e => {
        const subject = (e.subject || '').toLowerCase();
        return importantKeywords.some(kw => subject.includes(kw));
      })
      .slice(0, 10)
      .map(e => ({
        subject: e.subject || 'No subject',
        from: (e.from_address || 'Unknown').split('<')[0].trim(),
        date: e.date
      }));
  } catch (error) {
    console.error('Error extracting email content:', error.message);
  }
  
  return content;
}

async function generateAIInsights(summary) {
  // Try local LLM first, then Claude, then fallback
  const ogmTotalTasks = summary.content.ogm_work ? 
    summary.content.ogm_work.reduce((sum, w) => sum + w.total_tasks, 0) : 0;
  const ogmCriticalTasks = summary.content.ogm_work ?
    summary.content.ogm_work.reduce((sum, w) => sum + w.critical_count, 0) : 0;
    
  const promptData = {
    concerns_count: summary.content.concerns.length,
    first_concern: summary.content.concerns[0] || 'None',
    overdue_count: summary.content.overdue_tasks.length,
    urgent_count: summary.content.urgent_tasks.length,
    email_count: summary.content.important_emails.length,
    contacts: summary.content.people_to_contact.length,
    events_today: summary.content.calendar_today.length,
    events_week: summary.content.calendar_week.length,
    ogm_tasks: ogmTotalTasks,
    ogm_critical: ogmCriticalTasks
  };
  
  // Try local LLM first (Ollama)
  try {
    const { localLLM } = await import('../src/local-llm.js');
    if (await localLLM.isAvailable()) {
      console.log('ðŸ¤– Generating insights with local LLM...');
      const insights = await localLLM.generateDailyRecommendations(promptData);
      if (Array.isArray(insights) && insights.length > 0) {
        return insights;
      }
    }
  } catch (error) {
    // Local LLM not available or failed
  }
  
  // Fallback to Claude if available
  try {
    // Check if Claude CLI is available
    execSync('which claude', { stdio: 'ignore' });
    console.log('ðŸ¤– Generating insights with Claude...');
    
    // Write prompt to temp file to avoid shell escaping issues
    const tempFile = path.join(os.tmpdir(), `claude-prompt-${Date.now()}.txt`);
    const prompt = `Analyze this daily summary and provide 3-5 specific actionable recommendations as a JSON array:

Current situation:
- ${promptData.concerns_count} concerns noted (top: "${promptData.first_concern.substring(0, 50)}...")
- ${promptData.overdue_count} overdue tasks
- ${promptData.urgent_count} urgent tasks for today
- ${promptData.email_count} important emails to address
- ${promptData.contacts} people to contact
- ${promptData.events_today} calendar events today
- ${promptData.events_week} events this week

Return ONLY a JSON array of recommendation strings, like:
["Address the financial tracking concern by...", "Clear overdue tasks starting with...", "Schedule time for..."]`;
    
    await fs.writeFile(tempFile, prompt);
    
    // Call Claude with the temp file
    const claudeResponse = execSync(
      `cat "${tempFile}" | claude 2>/dev/null || echo '[]'`,
      { encoding: 'utf-8', maxBuffer: 1024 * 1024 }
    ).trim();
    
    // Clean up temp file
    await fs.unlink(tempFile).catch(() => {});
    
    // Try to parse as JSON, fallback to basic recommendations
    try {
      const insights = JSON.parse(claudeResponse);
      if (Array.isArray(insights)) {
        return insights;
      }
    } catch (e) {
      // Fallback to parsing text response
      if (claudeResponse && claudeResponse.length > 10) {
        return claudeResponse.split('\n')
          .filter(line => line.trim().length > 0)
          .slice(0, 5);
      }
    }
  } catch (error) {
    console.log('Claude not available, using smart recommendations');
  }
  
  // Smart fallback recommendations based on actual data
  return generateSmartRecommendations(summary, promptData);
}

function generateSmartRecommendations(summary, data) {
  const recommendations = [];
  
  // OGM critical work takes precedence
  if (data.ogm_critical > 0) {
    recommendations.push(`Focus on ${data.ogm_critical} critical OGM production issues`);
  }
  
  // Priority-based recommendations
  if (data.overdue_count > 0) {
    const oldest = summary.content.overdue_tasks[0];
    if (oldest) {
      recommendations.push(`Clear ${data.overdue_count} overdue tasks, starting with "${oldest.title.substring(0, 30)}..."`);
    }
  }
  
  if (data.concerns_count > 0 && data.first_concern !== 'None') {
    const concern = data.first_concern.substring(0, 80);
    if (concern.includes('financial') || concern.includes('expense')) {
      recommendations.push('Set up expense tracking spreadsheet and log today\'s transactions');
    } else if (concern.includes('reply') || concern.includes('respond')) {
      recommendations.push(`Address overdue communications: ${concern}`);
    } else {
      recommendations.push(`Take action on: ${concern}`);
    }
  }
  
  if (data.urgent_count > 3) {
    recommendations.push(`Focus on ${data.urgent_count} urgent tasks - consider time-blocking your calendar`);
  }
  
  if (data.email_count > 5) {
    recommendations.push(`Process ${data.email_count} important emails in a dedicated 30-minute session`);
  }
  
  if (data.contacts > 0) {
    const people = summary.content.people_to_contact.slice(0, 3).join(', ');
    recommendations.push(`Reach out to: ${people}`);
  }
  
  if (data.events_today > 0) {
    const event = summary.content.calendar_today[0];
    recommendations.push(`Prepare for: ${event.title} at ${event.time}`);
  }
  
  // Add time-based recommendation if we have room
  const hour = new Date().getHours();
  if (recommendations.length < 5) {
    if (hour < 10) {
      recommendations.push('Start with a quick win to build momentum for the day');
    } else if (hour < 14) {
      recommendations.push('Use peak energy for complex problem-solving tasks');
    } else if (hour < 17) {
      recommendations.push('Handle administrative tasks and communications');
    } else {
      recommendations.push('Review tomorrow\'s priorities and prepare for a strong start');
    }
  }
  
  return recommendations.slice(0, 5);
}

async function generateBasicRecommendations(summary) {
  const hour = new Date().getHours();
  const recommendations = [];
  
  if (hour < 12) {
    recommendations.push(
      'Review urgent tasks and overdue items',
      'Check for important emails requiring response',
      'Plan deep work session for complex tasks'
    );
  } else if (hour < 17) {
    recommendations.push(
      'Complete quick wins to build momentum',
      'Address pending communications',
      'Review progress on today\'s priorities'
    );
  } else {
    recommendations.push(
      'Complete day-end chores',
      'Review tomorrow\'s priorities',
      'Capture thoughts and lessons learned'
    );
  }
  
  // Add specific recommendations based on data
  if (summary.content.overdue_tasks.length > 5) {
    recommendations.unshift(`Address ${summary.content.overdue_tasks.length} overdue tasks`);
  }
  if (summary.content.concerns.length > 0) {
    recommendations.push('Review and address noted concerns');
  }
  if (summary.content.people_to_contact.length > 0) {
    recommendations.push(`Reach out to: ${summary.content.people_to_contact.slice(0, 3).join(', ')}`);
  }
  
  return recommendations;
}

async function updateSummary(useAI = true) {
  const summary = await loadSummary();
  const now = new Date().toISOString();
  
  // Check if database exists
  let dbExists = false;
  try {
    await fs.access(DB_PATH);
    dbExists = true;
  } catch (error) {
    console.log('Database not found, skipping database queries');
  }

  // Always update notes and extract content
  const noteData = await getNoteChanges(summary);
  summary.changes.new_notes = noteData.changes.new;
  summary.changes.modified_notes = noteData.changes.modified;
  summary.changes.deleted_notes = noteData.changes.deleted;
  summary.state.note_files_seen = noteData.files;
  
  // Extract meaningful content from notes
  const noteContent = await extractContentFromNotes(summary);
  summary.content.concerns = noteContent.concerns;
  summary.content.people_to_contact = noteContent.people_to_contact;
  summary.content.recent_notes = noteContent.recent_notes;
  summary.content.ogm_work = noteContent.ogm_work;

  // Extract calendar content
  const calendarContent = await extractCalendarContent();
  summary.content.calendar_today = calendarContent.calendar_today;
  summary.content.calendar_week = calendarContent.calendar_week;

  if (dbExists) {
    // Get recent data from database for analysis
    const recentEmails = await getRecentEmails(summary);
    const tasks = await getTasks(summary);
    
    // Update state tracking for emails
    const previousEmailIds = new Set(summary.state.email_ids_seen);
    const currentEmailIds = new Set(recentEmails.map(e => e.id || e.uid));
    
    // Track email changes
    summary.changes.new_emails = recentEmails.filter(e => {
      const id = e.id || e.uid;
      return !previousEmailIds.has(id);
    });
    summary.changes.deleted_emails = summary.state.email_ids_seen.filter(id => !currentEmailIds.has(id));
    
    // Update state tracking for tasks
    const previousTaskIds = new Set(summary.state.task_ids_seen);
    const currentTaskIds = new Set(tasks.map(t => t.id));
    
    // Track task changes
    summary.changes.new_tasks = tasks.filter(t => !previousTaskIds.has(t.id));
    summary.changes.completed_tasks = summary.state.task_ids_seen
      .filter(id => !currentTaskIds.has(id));
    summary.changes.modified_tasks = tasks.filter(t => 
      previousTaskIds.has(t.id) && 
      t.last_edited_time && 
      t.last_edited_time > summary.meta.last_sync.tasks
    );
    
    // Extract meaningful task content
    const taskContent = await extractTaskContent(tasks);
    summary.content.urgent_tasks = taskContent.urgent_tasks;
    summary.content.overdue_tasks = taskContent.overdue_tasks;
    summary.content.task_categories = taskContent.task_categories;
    
    // Update state
    summary.state.email_ids_seen = Array.from(currentEmailIds);
    summary.state.task_ids_seen = Array.from(currentTaskIds);
    
    // Update sync timestamps
    if (recentEmails.length > 0 && recentEmails[0].date) {
      summary.meta.last_sync.emails = recentEmails[0].date;
    }
    summary.meta.last_sync.tasks = now;
    
    // Calculate simple metrics
    const completedToday = summary.changes.completed_tasks.length;
    const newToday = summary.changes.new_tasks.length;
    summary.metrics.task_completion_rate = newToday > 0 ? (completedToday / newToday) : 0;
    
    // Identify patterns from available data
    const urgentTasks = tasks.filter(t => 
      t.due_date && new Date(t.due_date) <= new Date(Date.now() + 24*60*60*1000)
    );
    
    if (urgentTasks.length > 0) {
      summary.insights.risks = [`${urgentTasks.length} tasks due within 24 hours`];
    }
    
    // Update active context with what we have
    summary.active_context.deadlines = {};
    urgentTasks.forEach(t => {
      summary.active_context.deadlines[t.id] = {
        title: t.title,
        due: t.due_date,
        stage: t.stage
      };
    });
    
    // Extract meaningful email content
    const emailContent = await extractEmailContent(recentEmails);
    summary.content.important_emails = emailContent.important_emails;
    summary.content.top_email_senders = emailContent.top_email_senders;
    
    // Identify pending email responses (simple version)
    summary.communications.pending_responses = emailContent.important_emails;
    
    // Log what we found
    console.log(`Found ${recentEmails.length} emails, ${tasks.length} tasks`);
  }
  
  // Generate AI-powered recommendations based on all the data
  if (useAI) {
    summary.recommendations.daily_focus = await generateAIInsights(summary);
  } else {
    summary.recommendations.daily_focus = await generateBasicRecommendations(summary);
  }
  
  // Update metadata
  summary.meta.last_updated = now;
  summary.meta.last_sync.notes = now;
  summary.meta.update_count++;
  
  // Save updated summary
  await fs.writeFile(SUMMARY_FILE, JSON.stringify(summary, null, 2));
  
  console.log(`âœ… Summary updated: ${summary.meta.update_count} updates today`);
  console.log(`ðŸ“Š Content extracted:`);
  console.log(`  - ${summary.content.concerns.length} concerns`);
  console.log(`  - ${summary.content.urgent_tasks.length} urgent tasks`);
  console.log(`  - ${summary.content.overdue_tasks.length} overdue tasks`);
  console.log(`  - ${summary.content.important_emails.length} important emails`);
  console.log(`  - ${Object.keys(summary.content.top_email_senders).length} email senders`);
  console.log(`  - ${summary.content.calendar_today.length} events today`);
  console.log(`  - ${summary.content.calendar_week.length} events this week`);
  
  // Show OGM work if present
  if (summary.content.ogm_work && summary.content.ogm_work.length > 0) {
    const totalOgmTasks = summary.content.ogm_work.reduce((sum, w) => sum + w.total_tasks, 0);
    const criticalOgmTasks = summary.content.ogm_work.reduce((sum, w) => sum + w.critical_count, 0);
    console.log(`  - ${totalOgmTasks} OGM tasks (${criticalOgmTasks} critical)`);
  }
  
  console.log(`ðŸ“ˆ Changes: ${summary.changes.new_emails.length} new emails, ${summary.changes.new_tasks.length} new tasks, ${summary.changes.new_notes.length} new notes`);
  
  return summary;
}

// Check for command line arguments
const args = process.argv.slice(2);
const useAI = !args.includes('--no-ai');

// Run the update with AI flag
if (import.meta.url === `file://${process.argv[1]}`) {
  updateSummary(useAI).catch(console.error);
}

export { updateSummary };