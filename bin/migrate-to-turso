#!/usr/bin/env node

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import { createClient } from '@libsql/client';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables
import dotenvx from '@dotenvx/dotenvx';
dotenvx.config();

const TURSO_PATH = path.join(process.env.HOME, '.turso', 'turso');
const LOCAL_DB = path.join(process.cwd(), '.data', 'today.db');

async function main() {
  console.log(chalk.blue.bold('üöÄ Turso Database Migration Tool\n'));

  // Check if local database exists
  if (!fs.existsSync(LOCAL_DB)) {
    console.error(chalk.red('‚ùå Local database not found at:', LOCAL_DB));
    process.exit(1);
  }

  // Check if Turso CLI is installed
  if (!fs.existsSync(TURSO_PATH)) {
    console.error(chalk.red('‚ùå Turso CLI not found. Please install it first.'));
    console.log(chalk.yellow('Run: curl -sSfL https://get.tur.so/install.sh | bash'));
    process.exit(1);
  }

  const args = process.argv.slice(2);
  const command = args[0] || 'help';

  switch (command) {
    case 'auth':
      console.log(chalk.yellow('üìù Setting up Turso authentication...'));
      
      // Check if we're in a container/remote environment
      const isContainer = process.env.CODESPACES === 'true' || 
                         process.env.REMOTE_CONTAINERS === 'true' ||
                         fs.existsSync('/.dockerenv') ||
                         process.env.BROWSER?.includes('vscode');
      
      if (isContainer || args[1] === '--headless') {
        // Use headless authentication for containers
        console.log(chalk.gray('Using headless authentication (container environment detected)...\n'));
        
        try {
          const result = execSync(`${TURSO_PATH} auth login --headless`, { encoding: 'utf8' });
          
          // Extract the URL from the output
          const urlMatch = result.match(/https:\/\/[^\s]+/);
          if (urlMatch) {
            console.log(chalk.cyan('üåê Please visit this URL to authenticate:'));
            console.log(chalk.white.bold(`\n${urlMatch[0]}\n`));
            
            console.log(chalk.yellow('After authenticating in your browser:'));
            console.log(chalk.gray('1. Copy the token from the success page'));
            console.log(chalk.gray('2. Run: ~/.turso/turso auth token <TOKEN>'));
            console.log(chalk.gray('   OR'));
            console.log(chalk.gray('3. Simply verify with: ~/.turso/turso auth whoami\n'));
          } else {
            console.log(result);
          }
        } catch (error) {
          console.error(chalk.red('‚ùå Authentication setup failed'));
          process.exit(1);
        }
      } else {
        // Try regular browser-based auth for local environments
        console.log(chalk.gray('Opening browser for authentication...\n'));
        
        try {
          execSync(`${TURSO_PATH} auth login`, { stdio: 'inherit' });
          console.log(chalk.green('\n‚úÖ Authentication successful!'));
        } catch (error) {
          console.log(chalk.yellow('\nüí° Browser authentication failed. Try headless mode:'));
          console.log(chalk.white('   bin/migrate-to-turso auth --headless'));
          process.exit(1);
        }
      }
      break;

    case 'create':
      const dbName = args[1] || 'today-db';
      console.log(chalk.yellow(`üì¶ Creating Turso database: ${dbName}...`));
      
      try {
        // Create database
        const output = execSync(`${TURSO_PATH} db create ${dbName} --wait`, 
          { encoding: 'utf8' });
        console.log(chalk.green('‚úÖ Database created successfully!'));
        
        // Get database URL
        const urlOutput = execSync(`${TURSO_PATH} db show ${dbName} --url`, 
          { encoding: 'utf8' }).trim();
        
        // Create auth token
        console.log(chalk.yellow('üîë Creating auth token...'));
        const tokenOutput = execSync(`${TURSO_PATH} db tokens create ${dbName}`, 
          { encoding: 'utf8' }).trim();
        
        console.log(chalk.green('\n‚úÖ Database setup complete!\n'));
        console.log(chalk.cyan('Database credentials:'));
        console.log(chalk.white(`TURSO_DATABASE_URL=${urlOutput}`));
        console.log(chalk.white(`TURSO_AUTH_TOKEN=${tokenOutput}`));
        
        // Append to .env for dotenvx encryption
        const envPath = path.join(process.cwd(), '.env');
        const envContent = `

# Turso Database Configuration
TURSO_DATABASE_URL=${urlOutput}
TURSO_AUTH_TOKEN=${tokenOutput}`;
        
        console.log(chalk.yellow('\nüìù Appending Turso configuration to .env...'));
        fs.appendFileSync(envPath, envContent);
        console.log(chalk.green('‚úÖ Configuration added to .env'));
        
        // Encrypt with dotenvx
        console.log(chalk.yellow('\nüîê Encrypting credentials with dotenvx...'));
        try {
          execSync('npx dotenvx encrypt', { stdio: 'inherit' });
          console.log(chalk.green('‚úÖ Credentials encrypted!'));
          console.log(chalk.cyan('\nIMPORTANT: Your Turso credentials are now encrypted in .env'));
          console.log(chalk.cyan('The .env.keys file remains the same for all deployments'));
        } catch (error) {
          console.log(chalk.yellow('‚ö†Ô∏è  Could not encrypt automatically. Run manually:'));
          console.log(chalk.white('   npx dotenvx encrypt'));
        }
      } catch (error) {
        console.error(chalk.red('‚ùå Failed to create database:'), error.message);
        process.exit(1);
      }
      break;

    case 'push':
      if (!process.env.TURSO_DATABASE_URL) {
        console.error(chalk.red('‚ùå TURSO_DATABASE_URL not found in environment'));
        console.log(chalk.yellow('Run: bin/migrate-to-turso create [database-name]'));
        process.exit(1);
      }
      
      console.log(chalk.yellow('üì§ Pushing local database to Turso...'));
      console.log(chalk.gray(`Source: ${LOCAL_DB}`));
      console.log(chalk.gray(`Target: ${process.env.TURSO_DATABASE_URL}\n`));
      
      try {
        // Make this async for the delay
        await (async () => {
        
        // Get list of tables in local database
        const localTables = execSync(
          `sqlite3 ${LOCAL_DB} "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name"`,
          { encoding: 'utf8' }
        ).split('\n').filter(t => t.trim());
        
        console.log(chalk.cyan(`Found ${localTables.length} tables to migrate\n`));
        
        // Check what's already in Turso
        let existingTables = [];
        try {
          const tursoOutput = execSync(
            `${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} "SELECT name FROM sqlite_master WHERE type='table'"`,
            { encoding: 'utf8' }
          );
          // Parse the output - skip header line and extract table names
          existingTables = tursoOutput
            .split('\n')
            .slice(1) // Skip header
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('-')) // Remove empty lines and separators
            .map(line => line.split(/\s+/)[0]) // Get first column (table name)
            .filter(name => name && name !== 'NAME'); // Remove any remaining headers
        } catch (e) {
          // No tables yet
        }
        
        if (existingTables.length > 0) {
          console.log(chalk.gray(`Found ${existingTables.length} existing tables in Turso\n`));
        }
        
        // Push each table incrementally
        let pushed = 0;
        let skipped = 0;
        let failed = 0;
        const largeTableThreshold = 10 * 1024 * 1024; // 10MB
        
        for (const table of localTables) {
          if (existingTables.includes(table)) {
            // Check if counts match
            const localCount = execSync(`sqlite3 ${LOCAL_DB} "SELECT COUNT(*) FROM ${table}"`, { encoding: 'utf8' }).trim();
            let tursoCount = '0';
            try {
              tursoCount = execSync(
                `${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} "SELECT COUNT(*) FROM ${table}"`,
                { encoding: 'utf8' }
              ).match(/\d+/)?.[0] || '0';
            } catch (e) {}
            
            if (localCount === tursoCount) {
              console.log(chalk.gray(`  ‚è≠Ô∏è  ${table} (already complete: ${localCount} rows)`));
              skipped++;
              continue;
            } else {
              console.log(chalk.yellow(`  ‚ö†Ô∏è  ${table} (partial: ${tursoCount}/${localCount} rows)`));
              // Don't try to recreate the table, just insert missing data
            }
          }
          
          process.stdout.write(chalk.gray(`  üì§ ${table}...`));
          
          try {
            const tableFile = path.join(process.cwd(), '.data', `${table}_export.sql`);
            
            // Only export schema if table doesn't exist
            if (!existingTables.includes(table)) {
              execSync(`sqlite3 ${LOCAL_DB} ".schema ${table}" > ${tableFile}`);
            } else {
              // Table exists, create empty file for data only
              fs.writeFileSync(tableFile, '');
            }
            
            // Check if table is large (like emails)
            const rowCount = parseInt(
              execSync(`sqlite3 ${LOCAL_DB} "SELECT COUNT(*) FROM ${table}"`, { encoding: 'utf8' }).trim()
            );
            
            if (table === 'emails' || rowCount > 1000) {
              // Large table - push in batches
              console.log(chalk.yellow(` (${rowCount} rows, batching)`));
              
              // Create table first if needed
              if (!existingTables.includes(table)) {
                process.stdout.write(chalk.gray(`    Creating table schema...`));
                try {
                  execSync(`${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} < ${tableFile}`, { stdio: 'pipe' });
                  console.log(chalk.green(' ‚úì'));
                } catch (e) {
                  console.log(chalk.red(' ‚úó'));
                }
              }
              
              // For partial tables, only push missing rows
              let startOffset = 0;
              if (existingTables.includes(table)) {
                const tursoCount = parseInt(
                  execSync(
                    `${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} "SELECT COUNT(*) FROM ${table}"`,
                    { encoding: 'utf8' }
                  ).match(/\d+/)?.[0] || '0'
                );
                startOffset = parseInt(tursoCount);
                if (startOffset > 0) {
                  console.log(chalk.gray(`    Resuming from row ${startOffset}...`));
                }
              }
              
              // Push data in batches
              const batchSize = table === 'emails' ? 50 : 500;
              let offset = startOffset;
              let successCount = 0;
              let failCount = 0;
              const totalBatches = Math.ceil((rowCount - startOffset) / batchSize);
              let currentBatch = 0;
              
              while (offset < rowCount) {
                currentBatch++;
                const batchEnd = Math.min(offset + batchSize, rowCount);
                process.stdout.write(chalk.gray(`    Batch ${currentBatch}/${totalBatches} (rows ${offset}-${batchEnd})...`));
                
                const batchFile = path.join(process.cwd(), '.data', `${table}_batch.sql`);
                execSync(`sqlite3 ${LOCAL_DB} ".mode insert ${table}" "SELECT * FROM ${table} LIMIT ${batchSize} OFFSET ${offset}" > ${batchFile}`);
                
                try {
                  execSync(`${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} < ${batchFile}`, { stdio: 'pipe' });
                  console.log(chalk.green(' ‚úì'));
                  successCount++;
                  offset += batchSize;
                } catch (e) {
                  console.log(chalk.yellow(' ‚ö†Ô∏è (duplicates/errors, continuing)'));
                  failCount++;
                  offset += batchSize;
                } finally {
                  if (fs.existsSync(batchFile)) fs.unlinkSync(batchFile);
                }
                
                // Add small delay for large tables to avoid overwhelming server
                if (table === 'emails' && currentBatch % 10 === 0) {
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
              
              if (successCount > 0) {
                console.log(chalk.green(`  ‚úì ${table} completed (${successCount} batches succeeded, ${failCount} had issues)`));
                pushed++;
              } else {
                console.log(chalk.red(`  ‚úó ${table} failed (all ${failCount} batches failed)`));
                failed++;
              }
            } else {
              // Small table - push all at once
              execSync(`sqlite3 ${LOCAL_DB} ".mode insert ${table}" "SELECT * FROM ${table}" >> ${tableFile}`);
              
              const stats = fs.statSync(tableFile);
              const sizeMB = (stats.size / 1024 / 1024).toFixed(2);
              process.stdout.write(chalk.gray(` (${sizeMB} MB)`));
              
              execSync(`${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} < ${tableFile}`, { stdio: 'pipe' });
              
              console.log(chalk.green(' ‚úì'));
              pushed++;
            }
            
            // Clean up
            if (fs.existsSync(tableFile)) fs.unlinkSync(tableFile);
            
          } catch (error) {
            console.log(chalk.red(' ‚úó'));
            console.log(chalk.red(`     Error: ${error.message.split('\n')[0]}`));
            failed++;
            
            // Clean up on error
            const tableFile = path.join(process.cwd(), '.data', `${table}_export.sql`);
            if (fs.existsSync(tableFile)) fs.unlinkSync(tableFile);
          }
        }
        
        console.log(chalk.green(`\n‚úÖ Push complete!`));
        console.log(chalk.cyan(`   Pushed: ${pushed} tables`));
        console.log(chalk.gray(`   Skipped: ${skipped} tables (already complete)`));
        if (failed > 0) {
          console.log(chalk.red(`   Failed: ${failed} tables`));
        }
        
        // Final verification
        const taskCount = execSync(
          `${TURSO_PATH} db shell ${process.env.TURSO_DATABASE_URL} "SELECT COUNT(*) FROM tasks"`,
          { encoding: 'utf8' }
        ).match(/\d+/)?.[0] || '0';
        
        console.log(chalk.cyan(`\nüìä Database stats:`));
        console.log(chalk.white(`   Tasks in Turso: ${taskCount}`));
        
        })(); // End async wrapper
        
      } catch (error) {
        console.error(chalk.red('\n‚ùå Push failed:'), error.message);
        process.exit(1);
      }
      break;

    case 'test':
      if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
        console.error(chalk.red('‚ùå Turso credentials not found in environment'));
        process.exit(1);
      }
      
      console.log(chalk.yellow('üß™ Testing Turso connection...'));
      
      try {
        const client = createClient({
          url: process.env.TURSO_DATABASE_URL,
          authToken: process.env.TURSO_AUTH_TOKEN,
        });
        
        const result = await client.execute('SELECT COUNT(*) as count FROM tasks');
        console.log(chalk.green('‚úÖ Connection successful!'));
        console.log(chalk.cyan(`Found ${result.rows[0].count} tasks in database`));
        
        client.close();
      } catch (error) {
        console.error(chalk.red('‚ùå Connection failed:'), error.message);
        process.exit(1);
      }
      break;

    case 'help':
    default:
      console.log(chalk.cyan('Usage: bin/migrate-to-turso [command]\n'));
      console.log('Commands:');
      console.log('  auth              - Authenticate with Turso');
      console.log('  create [name]     - Create a new Turso database');
      console.log('  push              - Push local database to Turso (incremental, with batching)');
      console.log('  test              - Test Turso connection');
      console.log('  help              - Show this help message');
      console.log('\nTypical workflow:');
      console.log('  1. bin/migrate-to-turso auth');
      console.log('  2. bin/migrate-to-turso create my-database');
      console.log('  3. bin/migrate-to-turso push');
      console.log('  4. bin/migrate-to-turso test');
      console.log('\nNotes:');
      console.log('  - Push is incremental: skips tables that are already complete');
      console.log('  - Large tables (emails) are automatically batched');
      console.log('  - You can run push multiple times to resume after interruption');
      break;
  }
}

// Run with async support
main().catch(error => {
  console.error(chalk.red('Fatal error:'), error);
  process.exit(1);
});