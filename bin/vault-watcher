#!/usr/bin/env node

import { watch } from 'fs';
import { execSync, spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

// Configuration
const VAULT_DIR = path.join(projectRoot, 'vault/'); // Add trailing slash for symlink
const DEBOUNCE_DELAY = 3000; // Wait 3 seconds after last change before syncing
const BATCH_DELAY = 1000; // Collect changes for 1 second before processing
const LOG_FILE = path.join(projectRoot, '.data/vault-watcher.log');

// Track processing state
let isProcessing = false;
let changedFiles = new Set();
let lastSyncTime = Date.now();

// Import fs at the top level
import fs from 'fs';
import { getDatabase } from '../src/database-service.js';

// Logging
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}`;
  
  if (type === 'error') {
    console.error(chalk.red(logMessage));
  } else if (type === 'warn') {
    console.log(chalk.yellow(logMessage));
  } else if (type === 'success') {
    console.log(chalk.green(logMessage));
  } else {
    console.log(chalk.blue(logMessage));
  }
  
  // Also write to log file
  try {
    fs.appendFileSync(LOG_FILE, logMessage + '\n');
  } catch (e) {
    // Ignore log file errors
  }
}

// Update markdown tasks cache for a file
async function updateMarkdownTasksCache(filePath) {
  try {
    const db = getDatabase();

    // Normalize the file path to be relative to project root
    // This ensures consistency with bin/tasks sync which uses relative paths
    let normalizedPath = filePath;
    if (filePath.startsWith('/')) {
      // Convert absolute path to relative
      normalizedPath = path.relative(projectRoot, filePath);
    }

    // Read file content
    const content = await fs.promises.readFile(filePath, 'utf-8');
    const lines = content.split('\n');

    // Delete existing tasks for this file (use normalized path)
    db.prepare('DELETE FROM markdown_tasks WHERE file_path = ?').run(normalizedPath);

    // Insert tasks (simple - just store raw line text)
    const insertStmt = db.prepare(`
      INSERT INTO markdown_tasks (file_path, line_number, line_text)
      VALUES (?, ?, ?)
    `);

    const taskRegex = /^(?:\s*>)*\s*- \[[ x]\] /i; // Match tasks with any indentation, including blockquotes
    let insertCount = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (taskRegex.test(line)) {
        const lineNumber = i + 1; // 1-based line numbers
        insertStmt.run(normalizedPath, lineNumber, line);
        insertCount++;
      }
    }

    if (insertCount > 0) {
      log(`Updated cache: ${insertCount} tasks from ${path.basename(filePath)}`);
    }
  } catch (error) {
    log(`Failed to update cache for ${filePath}: ${error.message}`, 'error');
  }
}

// Track files being processed for task enrichment to avoid loops
const filesBeingEnriched = new Set();
let enrichmentQueue = [];
let isEnriching = false;

// Process task enrichment queue (runs separately from main processing)
async function processEnrichmentQueue() {
  if (isEnriching || enrichmentQueue.length === 0) {
    return;
  }

  isEnriching = true;
  const filesToEnrich = enrichmentQueue.splice(0, 5); // Process up to 5 files at a time

  try {
    for (const file of filesToEnrich) {
      if (filesBeingEnriched.has(file)) {
        continue; // Skip if already being processed
      }

      filesBeingEnriched.add(file);

      try {
        // Use bin/tasks commands to enrich the file
        // Run all three enrichment commands for the file
        const commands = [
          `bin/tasks prioritize-status "${file}"`,
          `bin/tasks add-topics "${file}"`,
          `bin/tasks classify-stages "${file}"`
        ];

        for (const cmd of commands) {
          try {
            execSync(cmd, {
              cwd: projectRoot,
              encoding: 'utf8',
              stdio: 'pipe' // Suppress output
            });
          } catch (error) {
            // Individual command failure shouldn't stop other enrichments
            log(`Enrichment command failed for ${path.basename(file)}: ${error.message}`, 'warn');
          }
        }

        log(`Enriched tasks in ${path.basename(file)}`, 'success');
      } catch (error) {
        log(`Failed to enrich ${path.basename(file)}: ${error.message}`, 'warn');
      } finally {
        // Remove from tracking after a delay to prevent immediate re-processing
        setTimeout(() => {
          filesBeingEnriched.delete(file);
        }, 30000); // 30 second cooldown
      }
    }
  } catch (error) {
    log(`Enrichment error: ${error.message}`, 'error');
  } finally {
    isEnriching = false;

    // Process more if queue has items
    if (enrichmentQueue.length > 0) {
      setTimeout(processEnrichmentQueue, 2000); // Process more after 2 seconds
    }
  }
}

// Sort and deduplicate tasks.md (pending tasks first, completed last)
async function sortTasksFile(filePath) {
  try {
    if (!filePath.endsWith('tasks.md')) {
      return false;
    }

    const content = await fs.promises.readFile(filePath, 'utf-8');
    const lines = content.split('\n').filter(line => line.trim() !== '');

    // Only process lines that are tasks
    const tasks = lines.filter(line => line.startsWith('- [ ]') || line.startsWith('- [x]'));

    if (tasks.length === 0) {
      return false;
    }

    // Separate and deduplicate
    const pendingTasks = [...new Set(tasks.filter(line => line.startsWith('- [ ]')))];
    const completedTasks = [...new Set(tasks.filter(line => line.startsWith('- [x]')))];

    // Sort each group alphabetically
    pendingTasks.sort();
    completedTasks.sort();

    // Combine: pending first, then completed
    const sortedTasks = [...pendingTasks, ...completedTasks];
    const newContent = sortedTasks.join('\n') + '\n';

    // Only write if content actually changed
    if (content !== newContent) {
      const oldCount = tasks.length;
      const newCount = sortedTasks.length;
      const duplicatesRemoved = oldCount - newCount;

      await fs.promises.writeFile(filePath, newContent, 'utf-8');
      log(`Sorted tasks.md: ${pendingTasks.length} pending, ${completedTasks.length} completed${duplicatesRemoved > 0 ? `, ${duplicatesRemoved} duplicates removed` : ''}`, 'success');
      return true;
    }

    return false;
  } catch (error) {
    log(`Failed to sort tasks.md: ${error.message}`, 'error');
    return false;
  }
}

// Process changed files
async function processChanges() {
  if (isProcessing || changedFiles.size === 0) {
    return;
  }

  isProcessing = true;
  const filesToProcess = Array.from(changedFiles);
  changedFiles.clear();

  try {
    // Filter for markdown files only
    const markdownFiles = filesToProcess.filter(f => f.endsWith('.md'));

    if (markdownFiles.length === 0) {
      isProcessing = false;
      return;
    }

    log(`Processing ${markdownFiles.length} changed file(s)...`);
    
    // Determine what type of sync to run
    const hasTaskFile = markdownFiles.some(f => 
      f.includes('/tasks/') || 
      f.includes('/projects/') || 
      f.includes('/plans/') ||
      f.includes('/topics/')
    );
    
    const hasInbox = markdownFiles.some(f => f.includes('/inbox/'));
    
    // Run appropriate sync command
    if (hasTaskFile) {
      log('Running task sync...', 'info');
      try {
        // Use SKIP_CLASSIFICATION to make it faster
        const output = execSync('SKIP_CLASSIFICATION=1 bin/tasks sync', {
          cwd: projectRoot,
          encoding: 'utf8',
          env: { ...process.env, SKIP_CLASSIFICATION: '1' }
        });
        
        // Count updates from output
        const updateMatch = output.match(/(\d+) total updates/);
        if (updateMatch) {
          log(`Task sync completed: ${updateMatch[1]} updates`, 'success');
        } else {
          log('Task sync completed', 'success');
        }
      } catch (error) {
        log(`Task sync failed: ${error.message}`, 'error');
      }
    }
    
    if (hasInbox) {
      log('Processing inbox...', 'info');
      try {
        // Skip markdown cleaning since we handle that separately for changed files only
        execSync('SKIP_MARKDOWN_CLEAN=1 bin/sync --vault', {
          cwd: projectRoot,
          encoding: 'utf8',
          env: { ...process.env, SKIP_MARKDOWN_CLEAN: '1' }
        });
        log('Inbox processed', 'success');
      } catch (error) {
        log(`Inbox processing failed: ${error.message}`, 'error');
      }
    }
    
    // Check if tasks.md needs sorting
    const tasksFile = markdownFiles.find(f => f.endsWith('/tasks.md'));
    if (tasksFile) {
      log('Checking if tasks.md needs sorting...', 'info');
      const wasSorted = await sortTasksFile(tasksFile);
      if (wasSorted) {
        // Remove from list to avoid double processing
        const index = markdownFiles.indexOf(tasksFile);
        if (index > -1) {
          markdownFiles.splice(index, 1);
        }
      }
    }

    // Update markdown tasks cache
    if (markdownFiles.length > 0) {
      log('Updating markdown tasks cache...', 'info');
      for (const file of markdownFiles) {
        await updateMarkdownTasksCache(file);
      }
      log('Markdown tasks cache updated', 'success');
    }

    // Always clean markdown files
    if (markdownFiles.length > 0) {
      log('Cleaning markdown formatting...', 'info');
      try {
        execSync(`npx markdownlint-cli2 --fix ${markdownFiles.map(f => `"${f}"`).join(' ')}`, {
          cwd: projectRoot,
          encoding: 'utf8',
          stdio: 'pipe'
        });
        log('Markdown cleaned', 'success');
      } catch (error) {
        // Markdownlint returns non-zero even on successful fixes sometimes
        if (!error.message.includes('Command failed')) {
          log(`Markdown cleaning failed: ${error.message}`, 'warn');
        }
      }
    }

    // Queue files for task enrichment (but not files we're already tracking)
    // This runs after main processing to avoid delays
    for (const file of markdownFiles) {
      // Skip files that are being or were recently enriched
      if (!filesBeingEnriched.has(file) && !enrichmentQueue.includes(file)) {
        // Queue all markdown files - any could have tasks
        enrichmentQueue.push(file);
      }
    }

    // Start enrichment process if not already running
    if (enrichmentQueue.length > 0 && !isEnriching) {
      // Run enrichment after a delay so it doesn't interfere with main processing
      setTimeout(processEnrichmentQueue, 5000); // 5 second delay
    }

    lastSyncTime = Date.now();
    
  } catch (error) {
    log(`Processing error: ${error.message}`, 'error');
  } finally {
    isProcessing = false;
    
    // If more changes accumulated while processing, schedule another run
    if (changedFiles.size > 0) {
      setTimeout(processChanges, BATCH_DELAY);
    }
  }
}

// Simple debounce implementation
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// Debounced version of processChanges
const debouncedProcess = debounce(processChanges, DEBOUNCE_DELAY);

// Initial scan to populate cache
async function initialCacheScan() {
  log('Performing initial scan to populate task cache...', 'info');
  try {
    const { execSync } = await import('child_process');
    // Find all markdown files in vault
    const findCmd = `find ${VAULT_DIR} -name "*.md" -type f ! -path "*/.*" ! -path "*/@inbox/*" 2>/dev/null || true`;
    const output = execSync(findCmd, { encoding: 'utf8' });
    const files = output.split('\n').filter(Boolean);

    log(`Found ${files.length} markdown files to scan`);

    // Process files in batches
    const batchSize = 20;
    for (let i = 0; i < files.length; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      await Promise.all(batch.map(file => updateMarkdownTasksCache(file)));
    }

    // Get total task count
    const db = getDatabase();
    const count = db.prepare('SELECT COUNT(*) as count FROM markdown_tasks').get();
    log(`Initial scan complete: ${count.count} tasks cached from ${files.length} files`, 'success');
  } catch (error) {
    log(`Initial cache scan failed: ${error.message}`, 'error');
  }
}

// Watch for changes
async function startWatching() {
  log('Vault watcher started', 'success');
  log(`Watching for changes in: ${VAULT_DIR}`);
  log(`Debounce delay: ${DEBOUNCE_DELAY}ms`);

  // Perform initial scan
  await initialCacheScan();
  
  // Recursive watch
  const watcher = watch(VAULT_DIR, { recursive: true }, (eventType, filename) => {
    if (!filename) return;
    
    // Ignore certain files and directories
    if (filename.includes('.stfolder') || 
        filename.includes('.stversions') ||
        filename.includes('.backups') ||
        filename.includes('.DS_Store') ||
        filename.includes('.sync-conflict-') ||
        filename.startsWith('.')) {
      return;
    }
    
    // Only process markdown files
    if (!filename.endsWith('.md')) {
      return;
    }
    
    const fullPath = path.join(VAULT_DIR, filename);
    
    // Add to changed files set
    changedFiles.add(fullPath);
    
    // Log the change (but not too frequently)
    const timeSinceLastSync = Date.now() - lastSyncTime;
    if (timeSinceLastSync > 10000) { // Only log if it's been >10s since last sync
      log(`Change detected: ${filename}`);
    }
    
    // Schedule processing
    debouncedProcess();
  });
  
  // Handle graceful shutdown
  process.on('SIGINT', () => {
    log('Shutting down vault watcher...', 'warn');
    watcher.close();
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    log('Received SIGTERM, shutting down...', 'warn');
    watcher.close();
    process.exit(0);
  });
  
  // Keep process alive
  // When running as a service, stdin might not be available
  if (process.stdin.isTTY) {
    process.stdin.resume();
  } else {
    // For non-TTY environments (like systemd), use setInterval to keep alive
    setInterval(() => {}, 1000 * 60 * 60); // Keep alive check every hour
  }
}

// Check if we're already running
async function checkAlreadyRunning() {
  // Skip PID check if running under systemd
  if (process.env.INVOCATION_ID || process.env.SYSTEMD_EXEC_PID) {
    return false; // Let systemd handle process management
  }

  try {
    const pidFile = path.join(projectRoot, '.data/vault-watcher.pid');

    if (fs.existsSync(pidFile)) {
      const pid = fs.readFileSync(pidFile, 'utf8').trim();
      try {
        // Check if process is actually running
        process.kill(parseInt(pid), 0);
        return true; // Process exists
      } catch (e) {
        // Process doesn't exist, remove stale PID file
        fs.unlinkSync(pidFile);
      }
    }

    // Write our PID
    fs.writeFileSync(pidFile, process.pid.toString());

    // Clean up PID file on exit
    process.on('exit', () => {
      try {
        fs.unlinkSync(pidFile);
      } catch (e) {
        // Ignore
      }
    });

    return false;
  } catch (e) {
    return false;
  }
}

// Main
async function main() {
  // Check if already running
  if (await checkAlreadyRunning()) {
    console.error(chalk.red('Vault watcher is already running'));
    console.log(chalk.gray('Use "bin/vault-watcher stop" to stop it'));
    process.exit(1);
  }
  
  // Ensure .data directory exists
  const dataDir = path.join(projectRoot, '.data');
  if (!fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir, { recursive: true });
  }
  
  // Start watching
  await startWatching();
}

// Handle command line arguments
const command = process.argv[2];

if (command === 'stop') {
  // Stop the daemon
  const pidFile = path.join(projectRoot, '.data/vault-watcher.pid');
  if (fs.existsSync(pidFile)) {
    const pid = parseInt(fs.readFileSync(pidFile, 'utf8').trim());
    try {
      process.kill(pid, 'SIGTERM');
      console.log(chalk.green('Vault watcher stopped'));
    } catch (e) {
      console.error(chalk.red('Failed to stop vault watcher'));
      // Remove stale PID file
      fs.unlinkSync(pidFile);
    }
  } else {
    console.log(chalk.yellow('Vault watcher is not running'));
  }
} else if (command === 'status') {
  // Check status
  const pidFile = path.join(projectRoot, '.data/vault-watcher.pid');
  if (fs.existsSync(pidFile)) {
    const pid = parseInt(fs.readFileSync(pidFile, 'utf8').trim());
    try {
      process.kill(pid, 0);
      console.log(chalk.green(`Vault watcher is running (PID: ${pid})`));
      
      // Show recent log entries
      if (fs.existsSync(LOG_FILE)) {
        const logs = fs.readFileSync(LOG_FILE, 'utf8').split('\n');
        const recentLogs = logs.slice(-10).filter(l => l).join('\n');
        if (recentLogs) {
          console.log(chalk.gray('\nRecent activity:'));
          console.log(chalk.gray(recentLogs));
        }
      }
    } catch (e) {
      console.log(chalk.yellow('Vault watcher is not running'));
      fs.unlinkSync(pidFile);
    }
  } else {
    console.log(chalk.yellow('Vault watcher is not running'));
  }
} else if (command === 'logs') {
  // Show logs
  if (fs.existsSync(LOG_FILE)) {
    const logs = fs.readFileSync(LOG_FILE, 'utf8');
    console.log(logs);
  } else {
    console.log(chalk.yellow('No log file found'));
  }
} else if (command === '--help' || command === 'help') {
  console.log(`
${chalk.bold('Vault Watcher - Real-time vault synchronization')}

${chalk.gray('Usage:')}
  bin/vault-watcher          Start the watcher daemon
  bin/vault-watcher stop     Stop the watcher daemon
  bin/vault-watcher status   Check if watcher is running
  bin/vault-watcher logs     Show watcher logs

${chalk.gray('Description:')}
  Watches for changes in the vault directory and automatically:
  - Syncs tasks when task-related files change
  - Processes inbox when new files arrive
  - Cleans markdown formatting
  - Updates the database in real-time

${chalk.gray('Configuration:')}
  Debounce delay: ${DEBOUNCE_DELAY}ms (waits for changes to settle)
  Batch delay: ${BATCH_DELAY}ms (collects multiple changes)
  
${chalk.gray('Excluded from watching:')}
  - Hidden files/directories (starting with .)
  - .stfolder, .stversions, .backups
  - .DS_Store files
  - sync-conflict files
  `);
} else {
  // Start the daemon
  main().catch(error => {
    console.error(chalk.red('Fatal error:'), error);
    process.exit(1);
  });
}