#!/usr/bin/env node

// Import Notion Action Items to local task manager
// This script connects directly to Notion API to get proper task data

// Auto-use dotenvx if available
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import { Client } from '@notionhq/client';
import { TaskManager } from '../src/task-manager.js';
import chalk from 'chalk';
import inquirer from 'inquirer';

const notionToken = process.env.NOTION_TOKEN;
if (!notionToken) {
  console.error(chalk.red('Error: NOTION_TOKEN environment variable not set'));
  process.exit(1);
}

const notion = new Client({ auth: notionToken });
const tm = new TaskManager();

// Helper to extract title from Notion page
function extractTitle(page) {
  if (page.properties?.Name?.title?.length > 0) {
    return page.properties.Name.title.map(t => t.plain_text).join('');
  }
  if (page.properties?.Title?.title?.length > 0) {
    return page.properties.Title.title.map(t => t.plain_text).join('');
  }
  // Check for any property that looks like a title
  for (const [key, value] of Object.entries(page.properties || {})) {
    if (value.type === 'title' && value.title?.length > 0) {
      return value.title.map(t => t.plain_text).join('');
    }
  }
  return 'Untitled';
}

async function findActionItemsDatabase() {
  try {
    console.log(chalk.blue('üîç Finding Action Items database...'));
    
    const response = await notion.search({
      filter: { property: 'object', value: 'database' },
      page_size: 100
    });
    
    const databases = response.results.filter(db => 
      db.title?.[0]?.plain_text?.toLowerCase().includes('action items')
    );
    
    if (databases.length === 0) {
      throw new Error('Action Items database not found');
    }
    
    const actionItemsDB = databases[0];
    console.log(chalk.green(`‚úì Found: ${actionItemsDB.title[0].plain_text}`));
    return actionItemsDB.id;
  } catch (error) {
    throw new Error(`Failed to find Action Items database: ${error.message}`);
  }
}

async function getActionItems(databaseId, options = {}) {
  try {
    const { limit = 100, filterDone = true, onlyJeffrey = true } = options;
    
    console.log(chalk.blue('üìã Fetching Action Items...'));
    
    // Build filter
    const filters = [];
    
    if (filterDone) {
      filters.push({
        property: 'Status',
        status: { does_not_equal: '‚úÖ Done' }
      });
    }
    
    // Notion API limits page_size to 100, so we need to paginate for more
    let allResults = [];
    let hasMore = true;
    let startCursor = undefined;
    
    const startTime = Date.now();
    const maxDuration = 60000; // 60 second timeout for fetching
    
    while (hasMore && allResults.length < limit) {
      // Check for timeout
      if (Date.now() - startTime > maxDuration) {
        console.log(chalk.yellow(`\n‚ö†Ô∏è  Fetch timeout after ${allResults.length} tasks (60s limit)`));
        break;
      }
      const queryParams = {
        database_id: databaseId,
        page_size: Math.min(limit - allResults.length, 100),
        sorts: [
          { property: 'Do Date', direction: 'ascending' },
          { property: 'Status', direction: 'ascending' }
        ]
      };
      
      if (filters.length > 0) {
        queryParams.filter = filters.length === 1 ? filters[0] : { and: filters };
      }
      
      if (startCursor) {
        queryParams.start_cursor = startCursor;
      }
      
      const response = await notion.databases.query(queryParams);
      allResults = allResults.concat(response.results);
      hasMore = response.has_more;
      startCursor = response.next_cursor;
      
      // Show progress for large fetches
      if (allResults.length % 100 === 0 && allResults.length > 0) {
        console.log(chalk.gray(`  Fetched ${allResults.length} tasks so far...`));
      }
    }
    
    // Process and filter tasks
    let tasks = allResults.map(page => ({
      id: page.id,
      title: extractTitle(page),
      properties: page.properties,
      url: page.url,
      created: page.created_time,
      updated: page.last_edited_time
    }));
    
    // Filter for Jeffrey's tasks if requested
    if (onlyJeffrey) {
      tasks = tasks.filter(task => {
        const assignedTo = task.properties['Assigned To']?.people;
        
        // Include if no one assigned (personal task)
        if (!assignedTo || assignedTo.length === 0) return true;
        
        // Include if Jeffrey is assigned
        return assignedTo.some(person => {
          const name = person.name || '';
          return name.toLowerCase().includes('jeffrey') || 
                 name.toLowerCase().includes('covey');
        });
      });
    }
    
    console.log(chalk.green(`‚úì Found ${tasks.length} tasks`));
    return tasks;
  } catch (error) {
    throw new Error(`Failed to fetch Action Items: ${error.message}`);
  }
}

async function importTask(notionTask) {
  const props = notionTask.properties;
  
  // Extract task details
  const title = notionTask.title;
  const status = props.Status?.status?.name || 'üé≠ Stage';
  const doDate = props['Do Date']?.date?.start || null;
  const repeatDays = props['Repeat Every (Days)']?.number || null;
  const content = props.Description?.rich_text?.map(t => t.plain_text).join('') || '';
  
  // Check if already imported
  const existing = tm.db.prepare('SELECT id FROM tasks WHERE notion_id = ?').get(notionTask.id);
  if (existing) {
    return { status: 'exists', id: existing.id };
  }
  
  // Create task
  const localId = tm.createTask({
    title,
    status,
    do_date: doDate,
    repeat_interval: repeatDays,
    content,
    notion_id: notionTask.id,
    notion_url: notionTask.url
  });
  
  // Handle topics/tags
  const topicRelations = props['Tag/Knowledge Vault']?.relation || [];
  const topicNames = [];
  
  for (const topicRef of topicRelations) {
    try {
      // Fetch the topic page to get its name
      const topicPage = await notion.pages.retrieve({ page_id: topicRef.id });
      const topicTitle = extractTitle(topicPage);
      if (topicTitle && topicTitle !== 'Untitled') {
        topicNames.push(topicTitle);
        // Add topic to task
        tm.addTopicToTask(localId, topicTitle);
      }
    } catch (error) {
      console.warn(chalk.yellow(`  ‚ö†Ô∏è  Could not fetch topic ${topicRef.id}: ${error.message}`));
    }
  }
  
  if (topicNames.length > 0) {
    console.log(chalk.gray(`    Topics: ${topicNames.join(', ')}`));
  }
  
  return { status: 'imported', id: localId };
}

async function main() {
  try {
    console.log(chalk.bold('\nüöÄ Notion Action Items Importer\n'));
    
    // Parse command line arguments
    const args = process.argv.slice(2);
    const showHelp = args.includes('--help') || args.includes('-h');
    const importAll = args.includes('--all');
    const dryRun = args.includes('--dry-run');
    const searchTerm = args.find(arg => !arg.startsWith('--'));
    
    // Show help if requested
    if (showHelp) {
      console.log('Usage: bin/import-notion-tasks [search-term] [options]\n');
      console.log('Options:');
      console.log('  --all        Import all available tasks without prompting');
      console.log('  --dry-run    Show what would be imported without actually importing');
      console.log('  --help, -h   Show this help message\n');
      console.log('Examples:');
      console.log('  bin/import-notion-tasks              # Interactive selection');
      console.log('  bin/import-notion-tasks "spam"       # Search for tasks with "spam"');
      console.log('  bin/import-notion-tasks --all        # Import all unimported tasks');
      console.log('  bin/import-notion-tasks --all --dry-run  # Preview all imports');
      return;
    }
    
    // Find the Action Items database
    const databaseId = await findActionItemsDatabase();
    
    // Get tasks (no limit for --all, disable Jeffrey filter for --all)
    const tasks = await getActionItems(databaseId, {
      limit: importAll ? 10000 : 100,  // Very high limit for --all to get everything
      filterDone: true,
      onlyJeffrey: !importAll  // Include all users if --all flag is set
    });
    
    if (tasks.length === 0) {
      console.log(chalk.yellow('No tasks to import'));
      return;
    }
    
    // Check what's already imported
    const imported = tm.db.prepare('SELECT notion_id FROM tasks WHERE notion_id IS NOT NULL').all();
    const importedIds = new Set(imported.map(t => t.notion_id));
    
    let toImport = tasks.filter(t => !importedIds.has(t.id));
    
    // If search term provided, filter tasks
    if (searchTerm) {
      console.log(chalk.blue(`üîç Searching for: "${searchTerm}"`));
      toImport = toImport.filter(task => 
        task.title.toLowerCase().includes(searchTerm.toLowerCase())
      );
      
      if (toImport.length === 0) {
        console.log(chalk.yellow(`No unimported tasks matching "${searchTerm}"`));
        
        // Check if it exists but is already imported
        const alreadyImported = tasks.filter(task => 
          task.title.toLowerCase().includes(searchTerm.toLowerCase()) &&
          importedIds.has(task.id)
        );
        
        if (alreadyImported.length > 0) {
          console.log(chalk.blue('\nAlready imported:'));
          alreadyImported.forEach(task => {
            console.log(`  ‚Ä¢ ${task.title}`);
          });
        }
        return;
      }
    }
    
    // Show task summary
    console.log(chalk.blue('\nüìä Status:'));
    console.log(`  Total tasks: ${tasks.length}`);
    console.log(`  Already imported: ${tasks.length - toImport.length}`);
    console.log(`  Available to import: ${toImport.length}`);
    
    if (toImport.length === 0) {
      console.log(chalk.green('\n‚úÖ All tasks are already imported!'));
      return;
    }
    
    let selectedTasks = [];
    
    if (importAll) {
      // Import all available tasks without prompting
      console.log(chalk.yellow(`\n‚ö†Ô∏è  Importing ALL ${toImport.length} tasks without confirmation`));
      console.log(chalk.gray('This may take a while...'));
      selectedTasks = toImport;
    } else if (toImport.length === 1) {
      // Single task - show details and confirm
      const task = toImport[0];
      console.log(chalk.blue('\nüìã Task to import:'));
      console.log(`  Title: ${chalk.bold(task.title)}`);
      console.log(`  Status: ${task.properties.Status?.status?.name || 'No status'}`);
      console.log(`  Do Date: ${task.properties['Do Date']?.date?.start || 'Not set'}`);
      console.log(`  Repeat: ${task.properties['Repeat Every (Days)']?.number ? 
        `Every ${task.properties['Repeat Every (Days)'].number} days` : 'No'}`);
      
      const { proceed } = await inquirer.prompt([{
        type: 'confirm',
        name: 'proceed',
        message: 'Import this task?',
        default: true
      }]);
      
      if (proceed) {
        selectedTasks = [task];
      }
    } else {
      // Multiple tasks - let user select
      console.log(chalk.blue('\nüìã Select tasks to import:'));
      console.log(chalk.gray(`Showing first 20 of ${toImport.length} tasks. Use --all to import all.`));
      
      const choices = toImport.slice(0, 20).map(task => {
        const doDate = task.properties['Do Date']?.date?.start;
        const status = task.properties.Status?.status?.name || '';
        const extras = [];
        if (doDate) extras.push(doDate);
        if (status && status !== 'üé≠ Stage') extras.push(status);
        
        return {
          name: `${task.title}${extras.length ? ` (${extras.join(', ')})` : ''}`,
          value: task,
          short: task.title
        };
      });
      
      if (toImport.length > 20) {
        choices.push({
          name: chalk.gray(`... and ${toImport.length - 20} more (use --all flag to import all)`),
          value: null,
          disabled: true
        });
      }
      
      const { selected } = await inquirer.prompt([{
        type: 'checkbox',
        name: 'selected',
        message: 'Choose tasks (space to select, enter to confirm):',
        choices,
        pageSize: 15
      }]);
      
      selectedTasks = selected.filter(t => t !== null);
    }
    
    if (selectedTasks.length === 0) {
      console.log(chalk.yellow('No tasks selected'));
      return;
    }
    
    // Dry run mode - just show what would be imported
    if (dryRun) {
      console.log(chalk.yellow(`\n[DRY RUN] Would import ${selectedTasks.length} task(s):\n`));
      
      // Show first 50 tasks in dry run
      const tasksToShow = selectedTasks.slice(0, 50);
      tasksToShow.forEach((task, i) => {
        const doDate = task.properties['Do Date']?.date?.start || '';
        const status = task.properties.Status?.status?.name || '';
        console.log(`  ${i + 1}. ${task.title}${doDate ? ` (${doDate})` : ''}${status && status !== 'üé≠ Stage' ? ` [${status}]` : ''}`);
      });
      
      if (selectedTasks.length > 50) {
        console.log(chalk.gray(`  ... and ${selectedTasks.length - 50} more tasks`));
      }
      
      console.log(chalk.yellow('\nNo tasks were imported (dry run mode)'));
      return;
    }
    
    // Import selected tasks
    console.log(chalk.blue(`\nüîÑ Importing ${selectedTasks.length} task(s)...`));
    
    let importedCount = 0;
    
    for (const task of selectedTasks) {
      process.stdout.write(`  ${task.title}...`);
      
      try {
        const result = await importTask(task);
        if (result.status === 'imported') {
          process.stdout.write(chalk.green(' ‚úì\n'));
          importedCount++;
        } else {
          process.stdout.write(chalk.yellow(' (already exists)\n'));
        }
      } catch (error) {
        process.stdout.write(chalk.red(` ‚úó ${error.message}\n`));
      }
    }
    
    if (importedCount > 0) {
      console.log(chalk.green(`\n‚úÖ Imported ${importedCount} task(s)`));
      
      // Run task sync to update markdown files
      console.log(chalk.blue('\nüìù Syncing to markdown...'));
      const { exec } = await import('child_process');
      const { promisify } = await import('util');
      const execAsync = promisify(exec);
      
      await execAsync('bin/tasks sync');
      console.log(chalk.green('‚úÖ Markdown files updated'));
    }
    
  } catch (error) {
    console.error(chalk.red('\n‚ùå Error:'), error.message);
    process.exit(1);
  } finally {
    tm.close();
  }
}

main();