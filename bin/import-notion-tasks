#!/usr/bin/env node

// Import Notion Action Items to local task manager
// This script connects directly to Notion API to get proper task data

// Auto-use dotenvx if available
import { autoDotenvx } from './lib/dotenvx-loader.js';
autoDotenvx();

import { Client } from '@notionhq/client';
import { TaskManager } from '../src/task-manager.js';
import chalk from 'chalk';
import inquirer from 'inquirer';

const notionToken = process.env.NOTION_TOKEN;
if (!notionToken) {
  console.error(chalk.red('Error: NOTION_TOKEN environment variable not set'));
  process.exit(1);
}

const notion = new Client({ auth: notionToken });
const tm = new TaskManager();

// Helper to extract title from Notion page
function extractTitle(page) {
  if (page.properties?.Name?.title?.length > 0) {
    return page.properties.Name.title.map(t => t.plain_text).join('');
  }
  if (page.properties?.Title?.title?.length > 0) {
    return page.properties.Title.title.map(t => t.plain_text).join('');
  }
  // Check for any property that looks like a title
  for (const [key, value] of Object.entries(page.properties || {})) {
    if (value.type === 'title' && value.title?.length > 0) {
      return value.title.map(t => t.plain_text).join('');
    }
  }
  return 'Untitled';
}

async function findActionItemsDatabase() {
  try {
    console.log(chalk.blue('üîç Finding Action Items database...'));
    
    const response = await notion.search({
      filter: { property: 'object', value: 'database' },
      page_size: 100
    });
    
    const databases = response.results.filter(db => 
      db.title?.[0]?.plain_text?.toLowerCase().includes('action items')
    );
    
    if (databases.length === 0) {
      throw new Error('Action Items database not found');
    }
    
    const actionItemsDB = databases[0];
    console.log(chalk.green(`‚úì Found: ${actionItemsDB.title[0].plain_text}`));
    return actionItemsDB.id;
  } catch (error) {
    throw new Error(`Failed to find Action Items database: ${error.message}`);
  }
}

async function getActionItems(databaseId, options = {}) {
  try {
    const { limit = 100, filterDone = true, onlyJeffrey = true } = options;
    
    console.log(chalk.blue('üìã Fetching Action Items...'));
    
    // Build filter
    const filters = [];
    
    if (filterDone) {
      filters.push({
        property: 'Status',
        status: { does_not_equal: '‚úÖ Done' }
      });
    }
    
    const queryParams = {
      database_id: databaseId,
      page_size: Math.min(limit, 100),
      sorts: [
        { property: 'Do Date', direction: 'ascending' },
        { property: 'Status', direction: 'ascending' }
      ]
    };
    
    if (filters.length > 0) {
      queryParams.filter = filters.length === 1 ? filters[0] : { and: filters };
    }
    
    const response = await notion.databases.query(queryParams);
    
    // Process and filter tasks
    let tasks = response.results.map(page => ({
      id: page.id,
      title: extractTitle(page),
      properties: page.properties,
      url: page.url,
      created: page.created_time,
      updated: page.last_edited_time
    }));
    
    // Filter for Jeffrey's tasks if requested
    if (onlyJeffrey) {
      tasks = tasks.filter(task => {
        const assignedTo = task.properties['Assigned To']?.people;
        
        // Include if no one assigned (personal task)
        if (!assignedTo || assignedTo.length === 0) return true;
        
        // Include if Jeffrey is assigned
        return assignedTo.some(person => {
          const name = person.name || '';
          return name.toLowerCase().includes('jeffrey') || 
                 name.toLowerCase().includes('covey');
        });
      });
    }
    
    console.log(chalk.green(`‚úì Found ${tasks.length} tasks`));
    return tasks;
  } catch (error) {
    throw new Error(`Failed to fetch Action Items: ${error.message}`);
  }
}

async function importTask(notionTask) {
  const props = notionTask.properties;
  
  // Extract task details
  const title = notionTask.title;
  const status = props.Status?.status?.name || 'üé≠ Stage';
  const doDate = props['Do Date']?.date?.start || null;
  const repeatDays = props['Repeat Every (Days)']?.number || null;
  const content = props.Description?.rich_text?.map(t => t.plain_text).join('') || '';
  
  // Check if already imported
  const existing = tm.db.prepare('SELECT id FROM tasks WHERE notion_id = ?').get(notionTask.id);
  if (existing) {
    return { status: 'exists', id: existing.id };
  }
  
  // Create task
  const localId = tm.createTask({
    title,
    status,
    do_date: doDate,
    repeat_interval: repeatDays,
    content,
    notion_id: notionTask.id,
    notion_url: notionTask.url
  });
  
  // Handle topics/tags
  const topics = props['Tag/Knowledge Vault']?.relation || [];
  for (const topicRef of topics) {
    // We'd need to fetch the topic name from Notion
    // For now, we'll skip topics
  }
  
  return { status: 'imported', id: localId };
}

async function main() {
  try {
    console.log(chalk.bold('\nüöÄ Notion Action Items Importer\n'));
    
    // Check for search term argument
    const searchTerm = process.argv[2];
    
    // Find the Action Items database
    const databaseId = await findActionItemsDatabase();
    
    // Get tasks
    const tasks = await getActionItems(databaseId, {
      limit: 100,
      filterDone: true,
      onlyJeffrey: true
    });
    
    if (tasks.length === 0) {
      console.log(chalk.yellow('No tasks to import'));
      return;
    }
    
    // Check what's already imported
    const imported = tm.db.prepare('SELECT notion_id FROM tasks WHERE notion_id IS NOT NULL').all();
    const importedIds = new Set(imported.map(t => t.notion_id));
    
    let toImport = tasks.filter(t => !importedIds.has(t.id));
    
    // If search term provided, filter tasks
    if (searchTerm) {
      console.log(chalk.blue(`üîç Searching for: "${searchTerm}"`));
      toImport = toImport.filter(task => 
        task.title.toLowerCase().includes(searchTerm.toLowerCase())
      );
      
      if (toImport.length === 0) {
        console.log(chalk.yellow(`No unimported tasks matching "${searchTerm}"`));
        
        // Check if it exists but is already imported
        const alreadyImported = tasks.filter(task => 
          task.title.toLowerCase().includes(searchTerm.toLowerCase()) &&
          importedIds.has(task.id)
        );
        
        if (alreadyImported.length > 0) {
          console.log(chalk.blue('\nAlready imported:'));
          alreadyImported.forEach(task => {
            console.log(`  ‚Ä¢ ${task.title}`);
          });
        }
        return;
      }
    }
    
    // Show task summary
    console.log(chalk.blue('\nüìä Status:'));
    console.log(`  Total tasks: ${tasks.length}`);
    console.log(`  Already imported: ${tasks.length - toImport.length}`);
    console.log(`  Available to import: ${toImport.length}`);
    
    if (toImport.length === 0) {
      console.log(chalk.green('\n‚úÖ All tasks are already imported!'));
      return;
    }
    
    let selectedTasks = [];
    
    if (toImport.length === 1) {
      // Single task - show details and confirm
      const task = toImport[0];
      console.log(chalk.blue('\nüìã Task to import:'));
      console.log(`  Title: ${chalk.bold(task.title)}`);
      console.log(`  Status: ${task.properties.Status?.status?.name || 'No status'}`);
      console.log(`  Do Date: ${task.properties['Do Date']?.date?.start || 'Not set'}`);
      console.log(`  Repeat: ${task.properties['Repeat Every (Days)']?.number ? 
        `Every ${task.properties['Repeat Every (Days)'].number} days` : 'No'}`);
      
      const { proceed } = await inquirer.prompt([{
        type: 'confirm',
        name: 'proceed',
        message: 'Import this task?',
        default: true
      }]);
      
      if (proceed) {
        selectedTasks = [task];
      }
    } else {
      // Multiple tasks - let user select
      console.log(chalk.blue('\nüìã Select tasks to import:'));
      
      const choices = toImport.slice(0, 20).map(task => {
        const doDate = task.properties['Do Date']?.date?.start;
        const status = task.properties.Status?.status?.name || '';
        const extras = [];
        if (doDate) extras.push(doDate);
        if (status && status !== 'üé≠ Stage') extras.push(status);
        
        return {
          name: `${task.title}${extras.length ? ` (${extras.join(', ')})` : ''}`,
          value: task,
          short: task.title
        };
      });
      
      if (toImport.length > 20) {
        choices.push({
          name: chalk.gray(`... and ${toImport.length - 20} more (use search to find specific tasks)`),
          value: null,
          disabled: true
        });
      }
      
      const { selected } = await inquirer.prompt([{
        type: 'checkbox',
        name: 'selected',
        message: 'Choose tasks (space to select, enter to confirm):',
        choices,
        pageSize: 15
      }]);
      
      selectedTasks = selected.filter(t => t !== null);
    }
    
    if (selectedTasks.length === 0) {
      console.log(chalk.yellow('No tasks selected'));
      return;
    }
    
    // Import selected tasks
    console.log(chalk.blue(`\nüîÑ Importing ${selectedTasks.length} task(s)...`));
    
    let importedCount = 0;
    
    for (const task of selectedTasks) {
      process.stdout.write(`  ${task.title}...`);
      
      try {
        const result = await importTask(task);
        if (result.status === 'imported') {
          process.stdout.write(chalk.green(' ‚úì\n'));
          importedCount++;
        } else {
          process.stdout.write(chalk.yellow(' (already exists)\n'));
        }
      } catch (error) {
        process.stdout.write(chalk.red(` ‚úó ${error.message}\n`));
      }
    }
    
    if (importedCount > 0) {
      console.log(chalk.green(`\n‚úÖ Imported ${importedCount} task(s)`));
      
      // Run task sync to update markdown files
      console.log(chalk.blue('\nüìù Syncing to markdown...'));
      const { exec } = await import('child_process');
      const { promisify } = await import('util');
      const execAsync = promisify(exec);
      
      await execAsync('bin/tasks sync');
      console.log(chalk.green('‚úÖ Markdown files updated'));
    }
    
  } catch (error) {
    console.error(chalk.red('\n‚ùå Error:'), error.message);
    process.exit(1);
  } finally {
    tm.close();
  }
}

main();