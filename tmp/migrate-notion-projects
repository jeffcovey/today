#!/usr/bin/env node

import { config } from 'dotenv';
import { NotionAPI } from '../src/notion-api.js';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';

config();

// Convert title to URL-safe slug
function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove special characters
    .replace(/\s+/g, '-')      // Replace spaces with hyphens
    .replace(/-+/g, '-')       // Replace multiple hyphens with single
    .trim();
}

// Format date for display
function formatDate(dateString) {
  if (!dateString) return null;
  const date = new Date(dateString);
  return date.toISOString().split('T')[0]; // YYYY-MM-DD format
}

// Convert Notion rich text to markdown
function richTextToMarkdown(richTextArray) {
  if (!richTextArray || !Array.isArray(richTextArray)) return '';
  
  return richTextArray.map(block => {
    let text = block.plain_text || '';
    
    // Apply formatting
    if (block.annotations) {
      if (block.annotations.bold) text = `**${text}**`;
      if (block.annotations.italic) text = `*${text}*`;
      if (block.annotations.code) text = `\`${text}\``;
      if (block.annotations.strikethrough) text = `~~${text}~~`;
    }
    
    // Add link if present
    if (block.href) {
      text = `[${text}](${block.href})`;
    }
    
    return text;
  }).join('');
}

async function migrateProjects(options = {}) {
  const notionToken = process.env.NOTION_TOKEN;
  
  if (!notionToken) {
    console.error(chalk.red('‚ùå NOTION_TOKEN not found in .env file'));
    process.exit(1);
  }

  const notion = new NotionAPI(notionToken);
  // Get the directory where this script lives, then go to parent (project root)
  const scriptDir = path.dirname(new URL(import.meta.url).pathname);
  const projectDir = path.resolve(scriptDir, '..');
  const outputDir = options.outputDir || path.join(projectDir, 'vault', 'projects');
  const archiveDir = path.join(outputDir, 'archive');
  const dryRun = options.dryRun || false;
  const limit = options.limit || null;
  const statusFilter = options.statusFilter || null;
  
  try {
    console.log(chalk.cyan('\nüöÄ Starting Notion Projects Migration\n'));
    
    if (dryRun) {
      console.log(chalk.yellow('‚ö†Ô∏è  DRY RUN MODE - No files will be created\n'));
    }
    
    // Ensure output directories exist
    if (!dryRun) {
      await fs.mkdir(outputDir, { recursive: true });
      await fs.mkdir(archiveDir, { recursive: true });
    }
    
    // Get the projects database
    const projectsDB = await notion.getProjectsDatabase();
    if (!projectsDB) {
      console.error(chalk.red('Projects database not found'));
      process.exit(1);
    }
    
    // Fetch all projects
    console.log(chalk.cyan('üìã Fetching projects from Notion...'));
    const response = await notion.notion.databases.query({
      database_id: projectsDB.id,
      page_size: 100,
      sorts: [
        {
          property: 'Status',
          direction: 'ascending'
        },
        {
          timestamp: 'last_edited_time',
          direction: 'descending'
        }
      ]
    });
    
    let projects = response.results;
    
    // Apply filters
    if (statusFilter) {
      projects = projects.filter(p => {
        const status = notion.getStatusValue(p.properties.Status);
        return status === statusFilter;
      });
      console.log(chalk.gray(`   Filtered to ${projects.length} projects with status: ${statusFilter}`));
    }
    
    if (limit) {
      projects = projects.slice(0, limit);
      console.log(chalk.gray(`   Limited to ${limit} projects`));
    }
    
    console.log(chalk.green(`‚úÖ Found ${projects.length} projects to migrate\n`));
    
    const migrationReport = {
      total: projects.length,
      successful: [],
      failed: [],
      skipped: []
    };
    
    // Process each project
    for (const [index, project] of projects.entries()) {
      const title = notion.extractTitle(project);
      const slug = slugify(title);
      const status = notion.getStatusValue(project.properties.Status) || 'No Status';
      
      console.log(chalk.cyan(`\n[${index + 1}/${projects.length}] Processing: ${title}`));
      console.log(chalk.gray(`   Status: ${status}`));
      
      try {
        // Determine output path (archive completed projects)
        const isCompleted = status === 'Completed';
        const dir = isCompleted ? archiveDir : outputDir;
        const filePath = path.join(dir, `${slug}.md`);
        
        // Check if file already exists
        const fileExists = !dryRun && await fs.access(filePath).then(() => true).catch(() => false);
        if (fileExists && !options.overwrite) {
          console.log(chalk.yellow(`   ‚ö†Ô∏è  File already exists: ${filePath}`));
          migrationReport.skipped.push({ title, reason: 'File exists' });
          continue;
        }
        
        // Fetch related data
        console.log(chalk.gray('   Fetching related data...'));
        
        // Fetch related tasks
        const taskRelations = project.properties['Action Items (Tasks)']?.relation || [];
        let tasks = [];
        if (taskRelations.length > 0) {
          console.log(chalk.gray(`   Fetching ${taskRelations.length} related tasks...`));
          for (const taskRelation of taskRelations.slice(0, 20)) { // Limit to 20 tasks to avoid rate limits
            try {
              const taskId = taskRelation.id; // Extract ID from relation object
              const task = await notion.notion.pages.retrieve({ page_id: taskId });
              tasks.push({
                id: task.id,
                title: notion.extractTitle(task),
                status: notion.getStatusValue(task.properties.Status),
                done: task.properties.Status?.status?.name === '‚úÖ Done'
              });
            } catch (e) {
              console.log(chalk.gray(`   Could not fetch task: ${e.message}`));
            }
          }
        }
        
        // Fetch tag names
        const tagRelations = project.properties['Tags/Knowledge Vault']?.relation || [];
        let tags = [];
        if (tagRelations.length > 0) {
          console.log(chalk.gray(`   Fetching ${tagRelations.length} tags...`));
          for (const tagRelation of tagRelations) {
            try {
              const tagId = tagRelation.id; // Extract ID from relation object
              const tag = await notion.notion.pages.retrieve({ page_id: tagId });
              tags.push(notion.extractTitle(tag));
            } catch (e) {
              console.log(chalk.gray(`   Could not fetch tag: ${e.message}`));
            }
          }
        }
        
        // Build markdown content
        let content = `# ${title}\n`;
        content += `<!-- notion-id: ${project.id} -->\n\n`;
        
        // Overview section
        content += `## Overview\n`;
        content += `**Status:** ${status}\n`;
        
        // Add priority if it's in the status
        const priorityMatch = status.match(/(\d+)(?:st|nd|rd|th) Priority/);
        if (priorityMatch) {
          content += `**Priority:** ${priorityMatch[1]}\n`;
        }
        
        content += `**Created:** ${formatDate(project.created_time)}\n`;
        content += `**Last Updated:** ${formatDate(project.last_edited_time)}\n`;
        
        if (project.properties['Timeline Dates']?.date?.start) {
          content += `**Timeline:** ${formatDate(project.properties['Timeline Dates'].date.start)}`;
          if (project.properties['Timeline Dates'].date.end) {
            content += ` to ${formatDate(project.properties['Timeline Dates'].date.end)}`;
          }
          content += `\n`;
        }
        
        if (project.properties['Review Date']?.date?.start) {
          content += `**Review Date:** ${formatDate(project.properties['Review Date'].date.start)}\n`;
        }
        
        content += `\n`;
        
        // Description section
        if (project.properties.Text?.rich_text?.length > 0) {
          content += `## Description\n`;
          content += richTextToMarkdown(project.properties.Text.rich_text) + `\n\n`;
        }
        
        // Tasks section
        if (tasks.length > 0) {
          content += `## Tasks\n`;
          
          const activeTasks = tasks.filter(t => !t.done);
          const completedTasks = tasks.filter(t => t.done);
          
          if (activeTasks.length > 0) {
            content += `### Active Tasks\n`;
            activeTasks.forEach(task => {
              content += `- [ ] ${task.title} <!-- task-id: ${task.id} -->\n`;
            });
            content += `\n`;
          }
          
          if (completedTasks.length > 0) {
            content += `### Completed Tasks\n`;
            completedTasks.forEach(task => {
              content += `- [x] ${task.title} <!-- task-id: ${task.id} -->\n`;
            });
            content += `\n`;
          }
        }
        
        // Related Projects section
        const blockingIds = project.properties.Blocking?.relation || [];
        const blockedByIds = project.properties['Blocked by']?.relation || [];
        
        if (blockingIds.length > 0 || blockedByIds.length > 0) {
          content += `## Related Projects\n`;
          
          if (blockingIds.length > 0) {
            content += `### This project blocks:\n`;
            for (const relation of blockingIds) {
              try {
                const relatedId = relation.id; // Extract ID from relation object
                const related = await notion.notion.pages.retrieve({ page_id: relatedId });
                const relatedTitle = notion.extractTitle(related);
                const relatedSlug = slugify(relatedTitle);
                content += `- [${relatedTitle}](./${relatedSlug}.md)\n`;
              } catch (e) {
                content += `- Related project\n`;
              }
            }
            content += `\n`;
          }
          
          if (blockedByIds.length > 0) {
            content += `### This project is blocked by:\n`;
            for (const relation of blockedByIds) {
              try {
                const relatedId = relation.id; // Extract ID from relation object
                const related = await notion.notion.pages.retrieve({ page_id: relatedId });
                const relatedTitle = notion.extractTitle(related);
                const relatedSlug = slugify(relatedTitle);
                content += `- [${relatedTitle}](./${relatedSlug}.md)\n`;
              } catch (e) {
                content += `- Related project\n`;
              }
            }
            content += `\n`;
          }
        }
        
        // Tags section
        if (tags.length > 0) {
          content += `## Tags\n`;
          tags.forEach(tag => {
            content += `- #${slugify(tag)}\n`;
          });
          content += `\n`;
        }
        
        // Metadata section
        content += `## Metadata\n`;
        
        if (project.properties['% Tasks Completed']?.rollup?.number) {
          const percentage = Math.round(project.properties['% Tasks Completed'].rollup.number * 100);
          content += `- **Completion:** ${percentage}%\n`;
        }
        
        if (project.properties.Active?.formula?.boolean !== undefined) {
          content += `- **Active:** ${project.properties.Active.formula.boolean ? 'Yes' : 'No'}\n`;
        }
        
        content += `- **Notion URL:** ${project.url}\n`;
        
        // Write file
        if (!dryRun) {
          await fs.writeFile(filePath, content);
          console.log(chalk.green(`   ‚úÖ Created: ${filePath}`));
        } else {
          console.log(chalk.gray(`   Would create: ${filePath}`));
        }
        
        migrationReport.successful.push({
          title,
          slug,
          path: filePath,
          status
        });
        
      } catch (error) {
        console.error(chalk.red(`   ‚ùå Error: ${error.message}`));
        migrationReport.failed.push({
          title,
          error: error.message
        });
      }
      
      // Add small delay to avoid rate limits
      if (index < projects.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    // Print summary
    console.log(chalk.cyan('\nüìä Migration Summary:\n'));
    console.log(chalk.green(`‚úÖ Successful: ${migrationReport.successful.length}`));
    console.log(chalk.yellow(`‚ö†Ô∏è  Skipped: ${migrationReport.skipped.length}`));
    console.log(chalk.red(`‚ùå Failed: ${migrationReport.failed.length}`));
    
    if (migrationReport.failed.length > 0) {
      console.log(chalk.red('\nFailed projects:'));
      migrationReport.failed.forEach(p => {
        console.log(`  - ${p.title}: ${p.error}`);
      });
    }
    
    // Save report
    if (!dryRun) {
      const reportPath = path.join(outputDir, 'migration-report.json');
      await fs.writeFile(reportPath, JSON.stringify(migrationReport, null, 2));
      console.log(chalk.gray(`\nMigration report saved to: ${reportPath}`));
    }
    
  } catch (error) {
    console.error(chalk.red(`\n‚ùå Fatal Error: ${error.message}`));
    process.exit(1);
  } finally {
    notion.close();
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  dryRun: args.includes('--dry-run'),
  overwrite: args.includes('--overwrite'),
  limit: null,
  statusFilter: null,
  outputDir: null
};

// Parse limit
const limitIndex = args.indexOf('--limit');
if (limitIndex !== -1 && args[limitIndex + 1]) {
  options.limit = parseInt(args[limitIndex + 1]);
}

// Parse status filter
const statusIndex = args.indexOf('--status');
if (statusIndex !== -1 && args[statusIndex + 1]) {
  options.statusFilter = args[statusIndex + 1];
}

// Parse output directory
const outputIndex = args.indexOf('--output');
if (outputIndex !== -1 && args[outputIndex + 1]) {
  options.outputDir = args[outputIndex + 1];
}

// Show help
if (args.includes('--help')) {
  console.log(`
${chalk.cyan('Notion Projects Migration Tool')}

Usage: bin/migrate-notion-projects [options]

Options:
  --dry-run          Preview migration without creating files
  --overwrite        Overwrite existing files
  --limit <n>        Limit migration to first n projects
  --status <status>  Only migrate projects with specific status
  --output <dir>     Custom output directory (default: vault/projects)
  --help            Show this help message

Examples:
  bin/migrate-notion-projects --dry-run
  bin/migrate-notion-projects --limit 5
  bin/migrate-notion-projects --status "1st Priority"
  bin/migrate-notion-projects --overwrite
`);
  process.exit(0);
}

// Run migration
migrateProjects(options);