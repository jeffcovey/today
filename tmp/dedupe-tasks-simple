#!/usr/bin/env node

import fs from 'fs';
import { glob } from 'glob';
import { execSync } from 'child_process';

// Safety: Create backup before any changes
function createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = `vault-backup-${timestamp}`;
    console.log(`üì¶ Creating backup: ${backupDir}`);
    execSync(`cp -r vault ${backupDir}`);
    console.log(`‚úÖ Backup created: ${backupDir}`);
    return backupDir;
}

// Natural home priority (higher number = higher priority)
const HOME_PRIORITY = {
    'vault/projects/': 100,
    'vault/plans/': 90,
    'vault/meetings/': 80,
    'vault/topics/': 70,
    'vault/tasks/': 10,  // Lowest priority
    'vault/': 50  // Other vault files
};

function getHomePriority(filePath) {
    for (const [prefix, priority] of Object.entries(HOME_PRIORITY)) {
        if (filePath.startsWith(prefix)) {
            return priority;
        }
    }
    return 0; // Unknown location
}

async function findAllTasksWithIds() {
    console.log('üîç Finding all tasks with task-ids...');

    const files = await glob('vault/**/*.md', {
        ignore: ['vault/.stversions/**', 'vault/.sync/**']
    });

    const taskMap = new Map(); // task-id -> [{file, line, content, priority}]

    for (const file of files) {
        try {
            const content = fs.readFileSync(file, 'utf-8');
            const lines = content.split('\n');

            lines.forEach((line, index) => {
                // Match task lines with task-id (excluding "task-id: none")
                const taskMatch = line.match(/^- \[[ x]\].*<!-- task-id: ([a-f0-9]{32}) -->/);
                if (taskMatch && !line.includes('task-id: none')) {
                    const taskId = taskMatch[1];
                    const priority = getHomePriority(file);

                    if (!taskMap.has(taskId)) {
                        taskMap.set(taskId, []);
                    }

                    taskMap.get(taskId).push({
                        file,
                        line: index,
                        content: line,
                        priority
                    });
                }
            });
        } catch (error) {
            console.warn(`‚ö†Ô∏è  Could not read ${file}: ${error.message}`);
        }
    }

    console.log(`üìä Found ${taskMap.size} unique tasks across ${files.length} files`);
    return taskMap;
}

function analyzeAndPlan(taskMap) {
    console.log('\\nüìà Analyzing duplicates...');

    const plan = {
        tasksWithHomes: [],
        orphanedTasks: [],
        filesToModify: new Map()
    };

    for (const [taskId, locations] of taskMap.entries()) {
        if (locations.length > 1) {
            // Find natural home (highest priority)
            const sortedLocations = locations.sort((a, b) => b.priority - a.priority);
            const naturalHome = sortedLocations[0];
            const duplicates = sortedLocations.slice(1);

            if (naturalHome.priority >= 70) {
                // Has a good natural home - keep there, remove duplicates
                plan.tasksWithHomes.push({
                    taskId,
                    title: naturalHome.content.match(/^- \[[ x]\]\s*(.+?)\s*<!--/)?.[1] || 'Unknown',
                    keepIn: naturalHome.file,
                    removeFrom: duplicates
                });
            } else {
                // No good home - move all to vault/tasks.md
                plan.orphanedTasks.push({
                    taskId,
                    title: naturalHome.content.match(/^- \[[ x]\]\s*(.+?)\s*<!--/)?.[1] || 'Unknown',
                    content: naturalHome.content,
                    removeFrom: locations
                });
            }
        }
    }

    // Group removals by file
    [...plan.tasksWithHomes, ...plan.orphanedTasks].forEach(task => {
        task.removeFrom.forEach(location => {
            if (!plan.filesToModify.has(location.file)) {
                plan.filesToModify.set(location.file, []);
            }
            plan.filesToModify.get(location.file).push({
                line: location.line,
                content: location.content,
                taskId: task.taskId
            });
        });
    });

    console.log(`üìä Summary:`);
    console.log(`   ‚Ä¢ ${plan.tasksWithHomes.length} tasks have natural homes`);
    console.log(`   ‚Ä¢ ${plan.orphanedTasks.length} tasks will move to vault/tasks.md`);
    console.log(`   ‚Ä¢ ${plan.filesToModify.size} files will be modified`);

    return plan;
}

function previewPlan(plan, limit = 10) {
    console.log(`\\nüëÄ Preview (first ${limit} with homes):`);

    plan.tasksWithHomes.slice(0, limit).forEach((task, i) => {
        console.log(`${i + 1}. ${task.title}`);
        console.log(`   Keep: ${task.keepIn}`);
        console.log(`   Remove from: ${task.removeFrom.map(r => r.file).join(', ')}`);
    });

    if (plan.orphanedTasks.length > 0) {
        console.log(`\\nüìù ${plan.orphanedTasks.length} orphaned tasks to move to vault/tasks.md`);
    }
}

function executePlan(plan, dryRun = true) {
    console.log(`\\n${dryRun ? 'üß™ DRY RUN:' : 'üöÄ EXECUTING:'} Task deduplication...`);

    // Process orphaned tasks first
    if (plan.orphanedTasks.length > 0) {
        const orphanContent = plan.orphanedTasks.map(task => task.content).join('\\n');

        if (!dryRun) {
            const tasksFile = 'vault/tasks.md';
            let existingContent = '';
            if (fs.existsSync(tasksFile)) {
                existingContent = fs.readFileSync(tasksFile, 'utf-8');
            }

            const newContent = existingContent +
                (existingContent ? '\\n\\n' : '') +
                '# Migrated Tasks\\n\\n' +
                orphanContent;

            fs.writeFileSync(tasksFile, newContent);
            console.log(`‚úÖ Added ${plan.orphanedTasks.length} orphaned tasks to vault/tasks.md`);
        } else {
            console.log(`üìù Would add ${plan.orphanedTasks.length} tasks to vault/tasks.md`);
        }
    }

    // Process file modifications
    for (const [filePath, removals] of plan.filesToModify.entries()) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const lines = content.split('\\n');

            // Sort removals by line number in descending order
            // This way we remove from bottom to top, avoiding line number shifts
            const sortedRemovals = removals.sort((a, b) => b.line - a.line);

            let removedCount = 0;
            for (const removal of sortedRemovals) {
                if (removal.line < lines.length && lines[removal.line] === removal.content) {
                    if (!dryRun) {
                        lines.splice(removal.line, 1);
                    }
                    removedCount++;
                    console.log(`${dryRun ? 'Would remove' : 'Removed'}: ${filePath}:${removal.line + 1}`);
                } else {
                    console.warn(`‚ö†Ô∏è  Line mismatch in ${filePath}:${removal.line + 1}, skipping`);
                }
            }

            if (!dryRun && removedCount > 0) {
                fs.writeFileSync(filePath, lines.join('\\n'));
            }

        } catch (error) {
            console.error(`‚ùå Error processing ${filePath}: ${error.message}`);
        }
    }

    console.log(`\\n‚úÖ ${dryRun ? 'Would process' : 'Processed'} ${plan.filesToModify.size} files`);
}

async function main() {
    const args = process.argv.slice(2);
    const dryRun = !args.includes('--execute');

    console.log('üßπ Simple Task Deduplication Tool');
    console.log('=' .repeat(50));

    if (dryRun) {
        console.log('üß™ Running in DRY RUN mode. Use --execute to apply changes.');
    } else {
        console.log('üöÄ EXECUTING mode - changes will be applied!');
        createBackup();
    }

    try {
        const taskMap = await findAllTasksWithIds();
        const plan = analyzeAndPlan(taskMap);
        previewPlan(plan);
        executePlan(plan, dryRun);

        console.log('\\n‚úÖ Task deduplication complete!');
        if (dryRun) {
            console.log('Run with --execute to apply changes.');
        }

    } catch (error) {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}