#!/usr/bin/env node

import fs from 'fs';
import { glob } from 'glob';
import { execSync } from 'child_process';

// Safety: Create backup before any changes
function createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = `vault-backup-${timestamp}`;
    console.log(`üì¶ Creating backup: ${backupDir}`);
    execSync(`cp -r vault ${backupDir}`);
    console.log(`‚úÖ Backup created: ${backupDir}`);
    return backupDir;
}

// Natural home priority (higher number = higher priority)
const HOME_PRIORITY = {
    'vault/projects/': 100,
    'vault/plans/': 90,
    'vault/meetings/': 80,
    'vault/topics/': 70,
    'vault/tasks/': 10,  // Lowest priority
    'vault/': 50  // Other vault files
};

function getHomePriority(filePath) {
    for (const [prefix, priority] of Object.entries(HOME_PRIORITY)) {
        if (filePath.startsWith(prefix)) {
            return priority;
        }
    }
    return 0; // Unknown location
}

async function findAllTasksWithIds() {
    console.log('üîç Finding all tasks with task-ids...');

    const files = await glob('vault/**/*.md', {
        ignore: ['vault/.stversions/**', 'vault/.sync/**', 'vault/.conflict-backup-*/**', 'vault/**/backup/**']
    });

    const taskMap = new Map(); // task-id -> [{file, line, content, priority}]

    for (const file of files) {
        try {
            const content = fs.readFileSync(file, 'utf-8');
            const lines = content.split('\n');

            lines.forEach((line, index) => {
                // Match any line with task-id (excluding "task-id: none")
                const taskMatch = line.match(/<!-- task-id: ([^\s]+) -->/);
                if (taskMatch && taskMatch[1] !== 'none') {
                    const taskId = taskMatch[1];
                    const priority = getHomePriority(file);

                    if (!taskMap.has(taskId)) {
                        taskMap.set(taskId, []);
                    }

                    taskMap.get(taskId).push({
                        file,
                        line: index,
                        content: line,
                        priority
                    });
                }
            });

        } catch (error) {
            console.warn(`‚ö†Ô∏è  Could not read ${file}: ${error.message}`);
        }
    }

    console.log(`üìä Found ${taskMap.size} unique tasks across ${files.length} files`);
    return taskMap;
}

function analyzeAndPlan(taskMap) {
    console.log('\nüìà Analyzing duplicates...');

    const plan = {
        tasksWithHomes: [],
        orphanedTasks: [],
        allRemovals: new Map() // file -> Set of task-ids to remove
    };

    let duplicatesFound = 0;
    for (const [taskId, locations] of taskMap.entries()) {
        if (locations.length > 1) {
            duplicatesFound++;
            if (duplicatesFound <= 5) {
                console.log(`üîç Debug: Task ${taskId} found in ${locations.length} locations: ${locations.map(l => l.file).join(', ')}`);
            }
            // Find natural home (highest priority)
            const sortedLocations = locations.sort((a, b) => b.priority - a.priority);
            const naturalHome = sortedLocations[0];
            const duplicates = sortedLocations.slice(1);

            if (naturalHome.priority >= 70) {
                // Has a good natural home - keep there, remove duplicates
                plan.tasksWithHomes.push({
                    taskId,
                    title: naturalHome.content.match(/^- \[[ x]\]\s*(.+?)\s*<!--/)?.[1] || 'Unknown',
                    keepIn: naturalHome.file,
                    removeFrom: duplicates.map(d => d.file)
                });

                // Queue duplicates for removal
                duplicates.forEach(duplicate => {
                    if (!plan.allRemovals.has(duplicate.file)) {
                        plan.allRemovals.set(duplicate.file, new Set());
                    }
                    plan.allRemovals.get(duplicate.file).add(taskId);
                });
            } else {
                // No good home - move all to vault/tasks.md, remove from everywhere else
                plan.orphanedTasks.push({
                    taskId,
                    title: naturalHome.content.match(/^- \[[ x]\]\s*(.+?)\s*<!--/)?.[1] || 'Unknown',
                    content: naturalHome.content
                });

                // Remove from all current locations (will be added to vault/tasks.md)
                locations.forEach(location => {
                    if (!plan.allRemovals.has(location.file)) {
                        plan.allRemovals.set(location.file, new Set());
                    }
                    plan.allRemovals.get(location.file).add(taskId);
                });
            }
        }
    }

    console.log(`üìä Summary:`);
    console.log(`   ‚Ä¢ ${duplicatesFound} total tasks with duplicates found`);
    console.log(`   ‚Ä¢ ${plan.tasksWithHomes.length} tasks have natural homes`);
    console.log(`   ‚Ä¢ ${plan.orphanedTasks.length} tasks will move to vault/tasks.md`);
    console.log(`   ‚Ä¢ ${plan.allRemovals.size} files will be modified`);

    return plan;
}

function previewPlan(plan, limit = 10) {
    console.log(`\nüëÄ Preview (first ${limit} with homes):`);

    plan.tasksWithHomes.slice(0, limit).forEach((task, i) => {
        console.log(`${i + 1}. ${task.title}`);
        console.log(`   Keep: ${task.keepIn}`);
        console.log(`   Remove from: ${task.removeFrom.join(', ')}`);
    });

    if (plan.orphanedTasks.length > 0) {
        console.log(`\nüìù ${plan.orphanedTasks.length} orphaned tasks to move to vault/tasks.md`);
    }
}

function executePlan(plan, dryRun = true) {
    console.log(`\n${dryRun ? 'üß™ DRY RUN:' : 'üöÄ EXECUTING:'} Task deduplication...`);

    // Step 1: Process each file completely, removing tasks by ID
    for (const [filePath, taskIdsToRemove] of plan.allRemovals.entries()) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const lines = content.split('\n');

            // Remove lines that contain any of the task IDs to remove
            const filteredLines = lines.filter(line => {
                const taskMatch = line.match(/<!-- task-id: ([^\s]+) -->/);
                if (taskMatch) {
                    const taskId = taskMatch[1];
                    return !taskIdsToRemove.has(taskId);
                }
                return true;
            });

            const removedCount = lines.length - filteredLines.length;
            console.log(`${dryRun ? 'Would remove' : 'Removed'} ${removedCount} tasks from ${filePath}`);

            if (!dryRun && removedCount > 0) {
                fs.writeFileSync(filePath, filteredLines.join('\n'));
            }

        } catch (error) {
            console.error(`‚ùå Error processing ${filePath}: ${error.message}`);
        }
    }

    // Step 2: Add orphaned tasks to vault/tasks.md
    if (plan.orphanedTasks.length > 0) {
        const orphanContent = plan.orphanedTasks.map(task => task.content).join('\n');

        if (!dryRun) {
            const tasksFile = 'vault/tasks.md';
            let existingContent = '';
            if (fs.existsSync(tasksFile)) {
                existingContent = fs.readFileSync(tasksFile, 'utf-8');
            }

            const newContent = existingContent +
                (existingContent ? '\n\n' : '') +
                '# Migrated Tasks\n\n' +
                orphanContent;

            fs.writeFileSync(tasksFile, newContent);
            console.log(`‚úÖ Added ${plan.orphanedTasks.length} orphaned tasks to vault/tasks.md`);
        } else {
            console.log(`üìù Would add ${plan.orphanedTasks.length} tasks to vault/tasks.md`);
        }
    }

    console.log(`\n‚úÖ ${dryRun ? 'Would process' : 'Processed'} ${plan.allRemovals.size} files`);
}

async function main() {
    const args = process.argv.slice(2);
    const dryRun = !args.includes('--execute');

    console.log('üßπ Fixed Task Deduplication Tool');
    console.log('=' .repeat(50));

    if (dryRun) {
        console.log('üß™ Running in DRY RUN mode. Use --execute to apply changes.');
    } else {
        console.log('üöÄ EXECUTING mode - changes will be applied!');
        createBackup();
    }

    try {
        const taskMap = await findAllTasksWithIds();
        const plan = analyzeAndPlan(taskMap);
        previewPlan(plan);
        executePlan(plan, dryRun);

        console.log('\n‚úÖ Task deduplication complete!');
        if (dryRun) {
            console.log('Run with --execute to apply changes.');
        }

    } catch (error) {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}